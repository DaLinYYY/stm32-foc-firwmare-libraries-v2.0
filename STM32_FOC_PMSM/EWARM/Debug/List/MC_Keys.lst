###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     04/Nov/2013  13:19:56 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\st\stm32 foc firwmare libraries                       #
#                    v2.0\STM32_FOC_PMSM\src\MC_Keys.c                        #
#    Command line =  "D:\st\stm32 foc firwmare libraries                      #
#                    v2.0\STM32_FOC_PMSM\src\MC_Keys.c" -D VECT_TAB_FLASH     #
#                    -lCN "D:\st\stm32 foc firwmare libraries                 #
#                    v2.0\STM32_FOC_PMSM\EWARM\Debug\List\" --diag_error      #
#                    Pe068,Pe069 -o "D:\st\stm32 foc firwmare libraries       #
#                    v2.0\STM32_FOC_PMSM\EWARM\Debug\Obj\" --debug            #
#                    --endian=little --cpu=Cortex-M3 --fpu=None               #
#                    --dlib_config D:\IAR\arm\INC\c\DLib_Config_Normal.h -I   #
#                    "D:\st\stm32 foc firwmare libraries                      #
#                    v2.0\STM32_FOC_PMSM\EWARM\..\" -I "D:\st\stm32 foc       #
#                    firwmare libraries v2.0\STM32_FOC_PMSM\EWARM\..\..\STM32 #
#                    F10XFWLIB\inc\" -I "D:\st\stm32 foc firwmare libraries   #
#                    v2.0\STM32_FOC_PMSM\EWARM\..\inc\" -Oh --use_c++_inline  #
#                    --require_prototypes                                     #
#    List file    =  D:\st\stm32 foc firwmare libraries                       #
#                    v2.0\STM32_FOC_PMSM\EWARM\Debug\List\MC_Keys.lst         #
#    Object file  =  D:\st\stm32 foc firwmare libraries                       #
#                    v2.0\STM32_FOC_PMSM\EWARM\Debug\Obj\MC_Keys.o            #
#                                                                             #
#                                                                             #
###############################################################################

D:\st\stm32 foc firwmare libraries v2.0\STM32_FOC_PMSM\src\MC_Keys.c
      1          /******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
      2          * File Name          : MC_Keys.c
      3          * Author             : IMS Systems Lab 
      4          * Date First Issued  : 21/11/07
      5          * Description        : This file handles Joystick and button management
      6          ********************************************************************************
      7          * History:
      8          * 21/11/07 v1.0
      9          * 29/05/08 v2.0
     10          * 14/07/08 v2.0.1
     11          ********************************************************************************
     12          * THE PRESENT SOFTWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     13          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
     14          * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT, 
     15          * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
     16          * CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING 
     17          * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     18          *
     19          * THIS SOURCE CODE IS PROTECTED BY A LICENSE.
     20          * FOR MORE INFORMATION PLEASE CAREFULLY READ THE LICENSE AGREEMENT FILE LOCATED
     21          * IN THE ROOT DIRECTORY OF THIS FIRMWARE PACKAGE.
     22          *******************************************************************************/
     23          /* Includes ------------------------------------------------------------------*/
     24          #include "stm32f10x_lib.h"
     25          #include "stm32f10x_MClib.h"
     26          #include "MC_Globals.h"
     27          
     28          
     29          /* Private typedef -----------------------------------------------------------*/
     30          /* Private define ------------------------------------------------------------*/
     31          #define KEY_UP_PORT GPIOD
     32          #define KEY_UP_BIT  GPIO_Pin_8
     33          
     34          #define KEY_DOWN_PORT GPIOD
     35          #define KEY_DOWN_BIT  GPIO_Pin_14
     36          
     37          #define KEY_RIGHT_PORT GPIOE
     38          #define KEY_RIGHT_BIT  GPIO_Pin_0
     39          
     40          #define KEY_LEFT_PORT GPIOE
     41          #define KEY_LEFT_BIT  GPIO_Pin_1
     42          
     43          #define KEY_SEL_PORT GPIOD
     44          #define KEY_SEL_BIT  GPIO_Pin_12
     45          
     46          #define USER_BUTTON_PORT GPIOB
     47          #define USER_BUTTON_BIT  GPIO_Pin_9
     48          
     49          #define  SEL_FLAG        (u8)0x02
     50          #define  RIGHT_FLAG      (u8)0x04
     51          #define  LEFT_FLAG       (u8)0x08
     52          #define  UP_FLAG         (u8)0x10
     53          #define  DOWN_FLAG       (u8)0x20
     54          
     55          //Variable increment and decrement
     56          
     57          #define SPEED_INC_DEC     (u16)10
     58          #define KP_GAIN_INC_DEC   (u16)250
     59          #define KI_GAIN_INC_DEC   (u16)25
     60          #define KD_GAIN_INC_DEC   (u16)100
     61          
     62          #ifdef FLUX_WEAKENING
     63          #define KP_VOLT_INC_DEC   (u8)50
     64          #define KI_VOLT_INC_DEC   (u8)10
     65          #define VOLT_LIM_INC_DEC  (u8)5 
     66          #endif
     67          
     68          #define TORQUE_INC_DEC    (u16)250
     69          #define FLUX_INC_DEC      (u16)250
     70          
     71          #define K1_INC_DEC        (s16)(250)
     72          #define K2_INC_DEC        (s16)(5000)
     73          
     74          #define PLL_IN_DEC        (u16)(25)
     75          
     76          /* Private macro -------------------------------------------------------------*/
     77          u8 KEYS_Read (void);
     78          /* Private variables ---------------------------------------------------------*/

   \                                 In section .bss, align 1
     79          static u8 bKey;
   \                     bKey:
   \   00000000                      DS8 1
     80          static u8 bPrevious_key;
     81          static u8 bKey_Flag;
     82          
     83          #ifdef FLUX_WEAKENING
     84          extern s16 hFW_P_Gain;
     85          extern s16 hFW_I_Gain;
     86          extern s16 hFW_V_Ref;
     87          #endif
     88          
     89          #ifdef OBSERVER_GAIN_TUNING
     90          extern volatile s32 wK1_LO;
     91          extern volatile s32 wK2_LO;
     92          extern volatile s16 hPLL_P_Gain, hPLL_I_Gain;
     93          #endif
     94          
     95          #ifdef FLUX_TORQUE_PIDs_TUNING
     96          u8 bMenu_index = CONTROL_MODE_MENU_6;
     97          #else
     98          u8 bMenu_index ;
   \                     bMenu_index:
   \   00000001                      DS8 1

   \                                 In section .bss, align 1
   \                     bPrevious_key:
   \   00000000                      DS8 1
   \   00000001                      DS8 1
     99          #endif
    100          
    101          /*******************************************************************************
    102          * Function Name  : KEYS_Init
    103          * Description    : Init GPIOs for joystick/button management
    104          * Input          : None
    105          * Output         : None
    106          * Return         : None
    107          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    108          void KEYS_Init(void)
    109          {
   \                     KEYS_Init:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    110            GPIO_InitTypeDef GPIO_InitStructure;
    111              
    112            /* Enable GPIOA, GPIOB, GPIOC, GPIOE clock */
    113            RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB | 
    114                                   RCC_APB2Periph_GPIOC | RCC_APB2Periph_GPIOD |
    115                                   RCC_APB2Periph_GPIOE, ENABLE);
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x207C             MOVS     R0,#+124
   \   00000006   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    116           
    117            GPIO_StructInit(&GPIO_InitStructure);
   \   0000000A   0xA800             ADD      R0,SP,#+0
   \   0000000C   0x.... 0x....      BL       GPIO_StructInit
    118            
    119            /* Joystick GPIOs configuration*/
    120            
    121            GPIO_InitStructure.GPIO_Pin = KEY_UP_BIT;
   \   00000010   0xF44F 0x7080      MOV      R0,#+256
   \   00000014   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    122            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
   \   00000018   0x2004             MOVS     R0,#+4
   \   0000001A   0xF88D 0x0003      STRB     R0,[SP, #+3]
    123            GPIO_Init(KEY_UP_PORT, &GPIO_InitStructure);
   \   0000001E   0x.... 0x....      LDR.W    R4,??DataTable3  ;; 0x40011400
   \   00000022   0xA900             ADD      R1,SP,#+0
   \   00000024   0x4620             MOV      R0,R4
   \   00000026   0x.... 0x....      BL       GPIO_Init
    124            
    125            GPIO_InitStructure.GPIO_Pin = KEY_DOWN_BIT;
   \   0000002A   0xF44F 0x4080      MOV      R0,#+16384
   \   0000002E   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    126            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
   \   00000032   0x2004             MOVS     R0,#+4
   \   00000034   0xF88D 0x0003      STRB     R0,[SP, #+3]
    127            GPIO_Init(KEY_DOWN_PORT, &GPIO_InitStructure);
   \   00000038   0xA900             ADD      R1,SP,#+0
   \   0000003A   0x4620             MOV      R0,R4
   \   0000003C   0x.... 0x....      BL       GPIO_Init
    128            
    129            GPIO_InitStructure.GPIO_Pin = KEY_RIGHT_BIT;
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    130            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
   \   00000046   0x2004             MOVS     R0,#+4
   \   00000048   0xF88D 0x0003      STRB     R0,[SP, #+3]
    131            GPIO_Init(KEY_RIGHT_PORT, &GPIO_InitStructure);
   \   0000004C   0x.... 0x....      LDR.W    R5,??DataTable3_1  ;; 0x40011800
   \   00000050   0xA900             ADD      R1,SP,#+0
   \   00000052   0x4628             MOV      R0,R5
   \   00000054   0x.... 0x....      BL       GPIO_Init
    132            
    133            GPIO_InitStructure.GPIO_Pin = KEY_LEFT_BIT;
   \   00000058   0x2002             MOVS     R0,#+2
   \   0000005A   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    134            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
   \   0000005E   0x2004             MOVS     R0,#+4
   \   00000060   0xF88D 0x0003      STRB     R0,[SP, #+3]
    135            GPIO_Init(KEY_LEFT_PORT, &GPIO_InitStructure);
   \   00000064   0xA900             ADD      R1,SP,#+0
   \   00000066   0x4628             MOV      R0,R5
   \   00000068   0x.... 0x....      BL       GPIO_Init
    136            
    137            GPIO_InitStructure.GPIO_Pin = KEY_SEL_BIT;
   \   0000006C   0xF44F 0x5080      MOV      R0,#+4096
   \   00000070   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    138            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
   \   00000074   0x2004             MOVS     R0,#+4
   \   00000076   0xF88D 0x0003      STRB     R0,[SP, #+3]
    139            GPIO_Init(KEY_SEL_PORT, &GPIO_InitStructure);
   \   0000007A   0xA900             ADD      R1,SP,#+0
   \   0000007C   0x4620             MOV      R0,R4
   \   0000007E   0x.... 0x....      BL       GPIO_Init
    140            
    141            /* User button GPIO configuration */
    142            
    143            GPIO_InitStructure.GPIO_Pin = USER_BUTTON_BIT;
   \   00000082   0xF44F 0x7000      MOV      R0,#+512
   \   00000086   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    144            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
   \   0000008A   0x2004             MOVS     R0,#+4
   \   0000008C   0xF88D 0x0003      STRB     R0,[SP, #+3]
    145            GPIO_Init(USER_BUTTON_PORT, &GPIO_InitStructure);
   \   00000090   0xA900             ADD      R1,SP,#+0
   \   00000092   0x.... 0x....      LDR.W    R0,??DataTable3_2  ;; 0x40010c00
   \   00000096   0x.... 0x....      BL       GPIO_Init
    146          }
   \   0000009A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    147            
    148          
    149          
    150          /*******************************************************************************
    151          * Function Name  : KEYS_Read
    152          * Description    : Reads key from demoboard.
    153          * Input          : None
    154          * Output         : None
    155          * Return         : Return RIGHT, LEFT, SEL, UP, DOWN, KEY_HOLD or NOKEY
    156          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    157          u8 KEYS_Read ( void )
    158          {
   \                     KEYS_Read:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    159            /* "RIGHT" key is pressed */
    160            if(!GPIO_ReadInputDataBit(KEY_RIGHT_PORT, KEY_RIGHT_BIT))
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable3_3
   \   00000006   0x.... 0x....      LDR.W    R5,??DataTable3_1  ;; 0x40011800
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0x4628             MOV      R0,R5
   \   0000000E   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \   00000012   0xB928             CBNZ.N   R0,??KEYS_Read_0
    161            {
    162              if (bPrevious_key == RIGHT) 
   \   00000014   0x7820             LDRB     R0,[R4, #+0]
   \   00000016   0x2802             CMP      R0,#+2
   \   00000018   0xD06E             BEQ.N    ??KEYS_Read_1
    163              {
    164                return KEY_HOLD;
    165              }
    166              else
    167              {
    168                bPrevious_key = RIGHT;
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0x7020             STRB     R0,[R4, #+0]
   \   0000001E   0xBD32             POP      {R1,R4,R5,PC}
    169                return RIGHT;
    170              }
    171            }
    172            /* "LEFT" key is pressed */
    173            else if(!GPIO_ReadInputDataBit(KEY_LEFT_PORT, KEY_LEFT_BIT))
   \                     ??KEYS_Read_0:
   \   00000020   0x2102             MOVS     R1,#+2
   \   00000022   0x4628             MOV      R0,R5
   \   00000024   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \   00000028   0xB928             CBNZ.N   R0,??KEYS_Read_2
    174            {
    175              if (bPrevious_key == LEFT) 
   \   0000002A   0x7820             LDRB     R0,[R4, #+0]
   \   0000002C   0x2803             CMP      R0,#+3
   \   0000002E   0xD063             BEQ.N    ??KEYS_Read_1
    176              {
    177                return KEY_HOLD;
    178              }
    179              else
    180              {
    181                bPrevious_key = LEFT;
   \   00000030   0x2003             MOVS     R0,#+3
   \   00000032   0x7020             STRB     R0,[R4, #+0]
   \   00000034   0xBD32             POP      {R1,R4,R5,PC}
    182                return LEFT;
    183              }
    184            }
    185            /* "SEL" key is pressed */
    186             if(!GPIO_ReadInputDataBit(KEY_SEL_PORT, KEY_SEL_BIT))
   \                     ??KEYS_Read_2:
   \   00000036   0x.... 0x....      LDR.W    R5,??DataTable3  ;; 0x40011400
   \   0000003A   0xF44F 0x5180      MOV      R1,#+4096
   \   0000003E   0x4628             MOV      R0,R5
   \   00000040   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \   00000044   0xB9A8             CBNZ.N   R0,??KEYS_Read_3
    187            {
    188              if (bPrevious_key == SEL) 
   \   00000046   0x7820             LDRB     R0,[R4, #+0]
   \   00000048   0x2801             CMP      R0,#+1
   \   0000004A   0xD055             BEQ.N    ??KEYS_Read_1
    189              {
    190                return KEY_HOLD;
    191              }
    192              else
    193              {
    194                if ( (TB_DebounceDelay_IsElapsed() == FALSE) && (bKey_Flag & SEL_FLAG == SEL_FLAG) )
   \   0000004C   0x.... 0x....      BL       TB_DebounceDelay_IsElapsed
   \   00000050   0xB910             CBNZ.N   R0,??KEYS_Read_4
   \   00000052   0x7860             LDRB     R0,[R4, #+1]
   \   00000054   0x07C0             LSLS     R0,R0,#+31
   \   00000056   0xD40A             BMI.N    ??KEYS_Read_5
    195                {
    196                  return NOKEY;
    197                }
    198                else
    199                {
    200                if ( (TB_DebounceDelay_IsElapsed() == TRUE) && ( (bKey_Flag & SEL_FLAG) == 0) ) 
   \                     ??KEYS_Read_4:
   \   00000058   0x.... 0x....      BL       TB_DebounceDelay_IsElapsed
   \   0000005C   0x2801             CMP      R0,#+1
   \   0000005E   0xD102             BNE.N    ??KEYS_Read_6
   \   00000060   0x7860             LDRB     R0,[R4, #+1]
   \   00000062   0x0780             LSLS     R0,R0,#+30
   \   00000064   0xD51C             BPL.N    ??KEYS_Read_7
    201                {
    202                  bKey_Flag |= SEL_FLAG;
    203                  TB_Set_DebounceDelay_500us(100); // 50 ms debounce
    204                }
    205                else if ( (TB_DebounceDelay_IsElapsed() == TRUE) && ((bKey_Flag & SEL_FLAG) == SEL_FLAG) )
   \                     ??KEYS_Read_6:
   \   00000066   0x.... 0x....      BL       TB_DebounceDelay_IsElapsed
   \   0000006A   0x2801             CMP      R0,#+1
   \   0000006C   0xD025             BEQ.N    ??KEYS_Read_8
    206                {
    207                  bKey_Flag &= (u8)(~SEL_FLAG);
    208                  bPrevious_key = SEL;
    209                  return SEL;
    210                }
    211                return NOKEY;
    212                }
    213              }
    214            }
    215            /* "SEL" key is pressed */
    216            else if(!GPIO_ReadInputDataBit(USER_BUTTON_PORT, USER_BUTTON_BIT))
    217            {
    218              if (bPrevious_key == SEL) 
    219              {
    220                return KEY_HOLD;
    221              }
    222              else
    223              {
    224                if ( (TB_DebounceDelay_IsElapsed() == FALSE) && (bKey_Flag & SEL_FLAG == SEL_FLAG) )
    225                {
    226                  return NOKEY;
    227                }
    228                else
    229                {
    230                if ( (TB_DebounceDelay_IsElapsed() == TRUE) && ( (bKey_Flag & SEL_FLAG) == 0) ) 
    231                {
    232                  bKey_Flag |= SEL_FLAG;
    233                  TB_Set_DebounceDelay_500us(100); // 50 ms debounce
    234                }
    235                else if ( (TB_DebounceDelay_IsElapsed() == TRUE) && ((bKey_Flag & SEL_FLAG) == SEL_FLAG) )
    236                {
    237                  bKey_Flag &= (u8)(~SEL_FLAG);
    238                  bPrevious_key = SEL;
    239                  return SEL;
    240                }
    241                return NOKEY;
   \                     ??KEYS_Read_5:
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0xBD32             POP      {R1,R4,R5,PC}
   \                     ??KEYS_Read_3:
   \   00000072   0xF44F 0x7100      MOV      R1,#+512
   \   00000076   0x.... 0x....      LDR.W    R0,??DataTable3_2  ;; 0x40010c00
   \   0000007A   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \   0000007E   0xBB30             CBNZ.N   R0,??KEYS_Read_9
   \   00000080   0x7820             LDRB     R0,[R4, #+0]
   \   00000082   0x2801             CMP      R0,#+1
   \   00000084   0xD038             BEQ.N    ??KEYS_Read_1
   \   00000086   0x.... 0x....      BL       TB_DebounceDelay_IsElapsed
   \   0000008A   0xB910             CBNZ.N   R0,??KEYS_Read_10
   \   0000008C   0x7860             LDRB     R0,[R4, #+1]
   \   0000008E   0x07C0             LSLS     R0,R0,#+31
   \   00000090   0xD4ED             BMI.N    ??KEYS_Read_5
   \                     ??KEYS_Read_10:
   \   00000092   0x.... 0x....      BL       TB_DebounceDelay_IsElapsed
   \   00000096   0x2801             CMP      R0,#+1
   \   00000098   0xD10B             BNE.N    ??KEYS_Read_11
   \   0000009A   0x7860             LDRB     R0,[R4, #+1]
   \   0000009C   0x0780             LSLS     R0,R0,#+30
   \   0000009E   0xD408             BMI.N    ??KEYS_Read_11
   \                     ??KEYS_Read_7:
   \   000000A0   0x7860             LDRB     R0,[R4, #+1]
   \   000000A2   0xF040 0x0002      ORR      R0,R0,#0x2
   \   000000A6   0x7060             STRB     R0,[R4, #+1]
   \   000000A8   0x2064             MOVS     R0,#+100
   \   000000AA   0x.... 0x....      BL       TB_Set_DebounceDelay_500us
   \   000000AE   0x2000             MOVS     R0,#+0
   \   000000B0   0xBD32             POP      {R1,R4,R5,PC}
   \                     ??KEYS_Read_11:
   \   000000B2   0x.... 0x....      BL       TB_DebounceDelay_IsElapsed
   \   000000B6   0x2801             CMP      R0,#+1
   \   000000B8   0xD1D9             BNE.N    ??KEYS_Read_5
   \                     ??KEYS_Read_8:
   \   000000BA   0x7860             LDRB     R0,[R4, #+1]
   \   000000BC   0x0780             LSLS     R0,R0,#+30
   \   000000BE   0xD5D6             BPL.N    ??KEYS_Read_5
   \   000000C0   0x7860             LDRB     R0,[R4, #+1]
   \   000000C2   0xF000 0x00FD      AND      R0,R0,#0xFD
   \   000000C6   0x7060             STRB     R0,[R4, #+1]
   \   000000C8   0x2001             MOVS     R0,#+1
   \   000000CA   0x7020             STRB     R0,[R4, #+0]
   \   000000CC   0xBD32             POP      {R1,R4,R5,PC}
    242                }
    243              }
    244            }
    245             /* "UP" key is pressed */
    246            else if(!GPIO_ReadInputDataBit(KEY_UP_PORT, KEY_UP_BIT))
   \                     ??KEYS_Read_9:
   \   000000CE   0xF44F 0x7180      MOV      R1,#+256
   \   000000D2   0x4628             MOV      R0,R5
   \   000000D4   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \   000000D8   0xB928             CBNZ.N   R0,??KEYS_Read_12
    247            {
    248              if (bPrevious_key == UP) 
   \   000000DA   0x7820             LDRB     R0,[R4, #+0]
   \   000000DC   0x2804             CMP      R0,#+4
   \   000000DE   0xD00B             BEQ.N    ??KEYS_Read_1
    249              {
    250                return KEY_HOLD;
    251              }
    252              else
    253              {
    254                bPrevious_key = UP;
   \   000000E0   0x2004             MOVS     R0,#+4
   \   000000E2   0x7020             STRB     R0,[R4, #+0]
   \   000000E4   0xBD32             POP      {R1,R4,R5,PC}
    255                return UP;
    256              }
    257            }
    258            /* "DOWN" key is pressed */
    259            else if(!GPIO_ReadInputDataBit(KEY_DOWN_PORT, KEY_DOWN_BIT))
   \                     ??KEYS_Read_12:
   \   000000E6   0xF44F 0x4180      MOV      R1,#+16384
   \   000000EA   0x4628             MOV      R0,R5
   \   000000EC   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \   000000F0   0xB938             CBNZ.N   R0,??KEYS_Read_13
    260            {
    261              if (bPrevious_key == DOWN) 
   \   000000F2   0x7820             LDRB     R0,[R4, #+0]
   \   000000F4   0x2805             CMP      R0,#+5
   \   000000F6   0xD101             BNE.N    ??KEYS_Read_14
    262              {
    263                return KEY_HOLD;
   \                     ??KEYS_Read_1:
   \   000000F8   0x2006             MOVS     R0,#+6
   \   000000FA   0xBD32             POP      {R1,R4,R5,PC}
    264              }
    265              else
    266              {
    267                bPrevious_key = DOWN;
   \                     ??KEYS_Read_14:
   \   000000FC   0x2005             MOVS     R0,#+5
   \   000000FE   0x7020             STRB     R0,[R4, #+0]
   \   00000100   0xBD32             POP      {R1,R4,R5,PC}
    268                return DOWN;
    269              }
    270            }
    271            
    272            /* No key is pressed */
    273            else
    274            {
    275              bPrevious_key = NOKEY;
   \                     ??KEYS_Read_13:
   \   00000102   0x2000             MOVS     R0,#+0
   \   00000104   0x7020             STRB     R0,[R4, #+0]
    276              return NOKEY;
   \   00000106   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    277            }
    278          }
    279          
    280          
    281          
    282          /*******************************************************************************
    283          * Function Name  : KEYS_process
    284          * Description    : Process key 
    285          * Input          : Key code
    286          * Output         : None
    287          * Return         : None
    288          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    289          void KEYS_process(void)
    290          {
   \                     KEYS_process:
   \   00000000   0xB580             PUSH     {R7,LR}
    291          bKey = KEYS_Read();    // read key pushed (if any...)
   \   00000002   0x.... 0x....      BL       KEYS_Read
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable3_4
   \   0000000A   0x7008             STRB     R0,[R1, #+0]
    292          
    293          switch (bMenu_index)
   \   0000000C   0x784A             LDRB     R2,[R1, #+1]
   \   0000000E   0x2A19             CMP      R2,#+25
   \   00000010   0xF200 0x8438      BHI.W    ??KEYS_process_1
   \   00000014   0xE8DF 0xF012      TBH      [PC, R2, LSL #+1]
   \                     ??KEYS_process_0:
   \   00000018   0x001A 0x0043      DC16     0x1A,0x43,0x79,0xA5
   \              0x0079 0x00A5
   \   00000020   0x00D1 0x00FB      DC16     0xD1,0xFB,0x12F,0x156
   \              0x012F 0x0156
   \   00000028   0x017F 0x01AD      DC16     0x17F,0x1AD,0x1DD,0x2A0
   \              0x01DD 0x02A0
   \   00000030   0x02BA 0x02E0      DC16     0x2BA,0x2E0,0x315,0x436
   \              0x0315 0x0436
   \   00000038   0x0436 0x0342      DC16     0x436,0x342,0x371,0x3A4
   \              0x0371 0x03A4
   \   00000040   0x03C8 0x03F0      DC16     0x3C8,0x3F0,0x408,0x20D
   \              0x0408 0x020D
   \   00000048   0x023F 0x026D      DC16     0x23F,0x26D
    294                {        
    295                  case(CONTROL_MODE_MENU_1):
    296                    switch(bKey)
   \                     ??KEYS_process_2:
   \   0000004C   0x2801             CMP      R0,#+1
   \   0000004E   0xD015             BEQ.N    ??KEYS_process_3
   \   00000050   0xF0C0 0x8418      BCC.W    ??KEYS_process_1
   \   00000054   0x2803             CMP      R0,#+3
   \   00000056   0xD00F             BEQ.N    ??KEYS_process_4
   \   00000058   0xD30C             BCC.N    ??KEYS_process_5
   \   0000005A   0x2805             CMP      R0,#+5
   \   0000005C   0xD001             BEQ.N    ??KEYS_process_6
   \   0000005E   0xF080 0x8411      BCS.W    ??KEYS_process_1
    297                    {
    298                      case UP:
    299                      case DOWN:
    300                        wGlobal_Flags ^= SPEED_CONTROL;
   \                     ??KEYS_process_6:
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable3_5
   \   00000066   0x6802             LDR      R2,[R0, #+0]
   \   00000068   0xF082 0x0201      EOR      R2,R2,#0x1
   \   0000006C   0x6002             STR      R2,[R0, #+0]
    301                        bMenu_index = CONTROL_MODE_MENU_6;
   \   0000006E   0x200C             MOVS     R0,#+12
   \   00000070   0x7048             STRB     R0,[R1, #+1]
   \   00000072   0xBD01             POP      {R0,PC}
    302                      break;
    303                      
    304                      case RIGHT:
    305                          bMenu_index = REF_SPEED_MENU;
   \                     ??KEYS_process_5:
   \   00000074   0x.... 0x....      B.W      ?Subroutine9
    306                      break;
    307                      
    308                      case LEFT:
    309          #ifdef DAC_FUNCTIONALITY              
    310                        bMenu_index = DAC_PB1_MENU;
   \                     ??KEYS_process_4:
   \   00000078   0x.... 0x....      B.W      ?Subroutine3
    311          #elif defined OBSERVER_GAIN_TUNING
    312                        bMenu_index = I_PLL_MENU;          
    313          #else              
    314                        bMenu_index = POWER_STAGE_MENU;
    315          #endif              
    316                      break;
    317                      
    318                      case SEL:
    319                        if (State == RUN)
   \                     ??KEYS_process_3:
   \   0000007C   0x.... 0x....      LDR.W    R0,??DataTable3_6
   \   00000080   0x7802             LDRB     R2,[R0, #+0]
   \   00000082   0x2A03             CMP      R2,#+3
   \   00000084   0xBF1C             ITT      NE 
   \   00000086   0x7802             LDRBNE   R2,[R0, #+0]
   \   00000088   0x2A02             CMPNE    R2,#+2
    320                        {
    321                          State = STOP;               
    322                        }
    323                        else if (State== START)
   \   0000008A   0xF000 0x83F7      BEQ.W    ??KEYS_process_7
    324                        {
    325                          State = STOP; 
    326                        }
    327                          else if(State == IDLE)
   \   0000008E   0x7802             LDRB     R2,[R0, #+0]
   \   00000090   0x2A00             CMP      R2,#+0
   \   00000092   0xF040 0x83F7      BNE.W    ??KEYS_process_1
    328                          {
    329                            State = INIT;
   \   00000096   0x2201             MOVS     R2,#+1
   \   00000098   0x7002             STRB     R2,[R0, #+0]
    330                            bMenu_index = REF_SPEED_MENU;
   \   0000009A   0x704A             STRB     R2,[R1, #+1]
   \   0000009C   0xBD01             POP      {R0,PC}
    331                          }  
    332                        
    333                      break;
    334                      default:
    335                      break;
    336                    }
    337                  break;
    338                  
    339                  case(REF_SPEED_MENU):
    340                    switch(bKey)
   \                     ??KEYS_process_8:
   \   0000009E   0x2801             CMP      R0,#+1
   \   000000A0   0xD025             BEQ.N    ??KEYS_process_9
   \   000000A2   0xF0C0 0x83EF      BCC.W    ??KEYS_process_1
   \   000000A6   0x2803             CMP      R0,#+3
   \   000000A8   0xD01A             BEQ.N    ??KEYS_process_10
   \   000000AA   0xD375             BCC.N    ??KEYS_process_11
   \   000000AC   0x2805             CMP      R0,#+5
   \   000000AE   0xD00C             BEQ.N    ??KEYS_process_12
   \   000000B0   0xF080 0x83E8      BCS.W    ??KEYS_process_1
    341                    {
    342                      case UP:
    343                        if (hSpeed_Reference <= MOTOR_MAX_SPEED_HZ)
   \   000000B4   0x.... 0x....      LDR.W    R0,??DataTable3_7
   \   000000B8   0xF9B0 0x1000      LDRSH    R1,[R0, #+0]
   \   000000BC   0xF240 0x2259      MOVW     R2,#+601
   \   000000C0   0x4291             CMP      R1,R2
   \   000000C2   0xF280 0x83DF      BGE.W    ??KEYS_process_1
    344                        {
    345                          hSpeed_Reference += SPEED_INC_DEC;
   \   000000C6   0x8801             LDRH     R1,[R0, #+0]
   \   000000C8   0x....             B.N      ?Subroutine6
    346                        }
    347                      break;
    348                        
    349                      case DOWN:
    350                        if (hSpeed_Reference >= -MOTOR_MAX_SPEED_HZ)
   \                     ??KEYS_process_12:
   \   000000CA   0x.... 0x....      LDR.W    R0,??DataTable3_7
   \   000000CE   0xF9B0 0x1000      LDRSH    R1,[R0, #+0]
   \   000000D2   0x.... 0x....      LDR.W    R2,??DataTable3_8  ;; 0xfffffda8
   \   000000D6   0x4291             CMP      R1,R2
   \   000000D8   0xF2C0 0x83D4      BLT.W    ??KEYS_process_1
    351                        {
    352                          hSpeed_Reference -= SPEED_INC_DEC;
   \   000000DC   0x8801             LDRH     R1,[R0, #+0]
   \   000000DE   0x....             B.N      ?Subroutine5
    353                        }
    354                      break;
    355                     
    356                      case RIGHT:
    357                          bMenu_index = P_SPEED_MENU;
    358                      break;
    359          
    360                      case LEFT:
    361                        if (State == IDLE)
   \                     ??KEYS_process_10:
   \   000000E0   0x.... 0x....      LDR.W    R0,??DataTable3_6
   \   000000E4   0x7800             LDRB     R0,[R0, #+0]
   \   000000E6   0x2800             CMP      R0,#+0
   \   000000E8   0xF000 0x83C0      BEQ.W    ??KEYS_process_13
    362                        {
    363                          bMenu_index = CONTROL_MODE_MENU_1;
    364                        }
    365                        else
    366                        {
    367          #ifdef DAC_FUNCTIONALITY              
    368                        bMenu_index = DAC_PB1_MENU;
   \   000000EC   0x....             B.N      ?Subroutine3
    369          #elif defined OBSERVER_GAIN_TUNING
    370                        bMenu_index = I_PLL_MENU;          
    371          #else              
    372                        bMenu_index = POWER_STAGE_MENU;
    373          #endif 
    374                        }              
    375                      break;
    376                      
    377                      case SEL:
    378                        if (State == RUN)
   \                     ??KEYS_process_9:
   \   000000EE   0x.... 0x....      LDR.W    R0,??DataTable3_6
   \   000000F2   0x7801             LDRB     R1,[R0, #+0]
   \   000000F4   0x2903             CMP      R1,#+3
   \   000000F6   0xBF1C             ITT      NE 
   \   000000F8   0x7801             LDRBNE   R1,[R0, #+0]
   \   000000FA   0x2902             CMPNE    R1,#+2
    379                        {
    380                          State = STOP;               
    381                        }
    382                        else if(State == START)
   \   000000FC   0xF000 0x83BE      BEQ.W    ??KEYS_process_7
    383                        {
    384                          State = STOP;
    385                        }              
    386                          else if(State == IDLE)
   \   00000100   0x7801             LDRB     R1,[R0, #+0]
   \   00000102   0x2900             CMP      R1,#+0
   \   00000104   0xF040 0x83BE      BNE.W    ??KEYS_process_1
    387                          {
    388                            State = INIT;
   \   00000108   0xE3BA             B.N      ??KEYS_process_14
    389                          }   
    390                      break;
    391                      default:
    392                      break;
    393                    }
    394                  break;          
    395                  
    396                  case(P_SPEED_MENU):    
    397                    switch(bKey)
   \                     ??KEYS_process_15:
   \   0000010A   0x2801             CMP      R0,#+1
   \   0000010C   0xD01B             BEQ.N    ??KEYS_process_16
   \   0000010E   0xF0C0 0x83B9      BCC.W    ??KEYS_process_1
   \   00000112   0x2803             CMP      R0,#+3
   \   00000114   0xD016             BEQ.N    ??KEYS_process_17
   \   00000116   0xD369             BCC.N    ??KEYS_process_18
   \   00000118   0x2805             CMP      R0,#+5
   \   0000011A   0xD00B             BEQ.N    ??KEYS_process_19
   \   0000011C   0xF080 0x83B2      BCS.W    ??KEYS_process_1
    398                    {
    399                      case UP:
    400                        if (PID_Speed_InitStructure.hKp_Gain <= S16_MAX-KP_GAIN_INC_DEC)
   \   00000120   0x.... 0x....      LDR.W    R0,??DataTable3_9
   \   00000124   0xF9B0 0x1000      LDRSH    R1,[R0, #+0]
   \   00000128   0xF647 0x7206      MOVW     R2,#+32518
   \   0000012C   0x4291             CMP      R1,R2
   \   0000012E   0xF280 0x83A9      BGE.W    ??KEYS_process_1
    401                        {
    402                          PID_Speed_InitStructure.hKp_Gain += KP_GAIN_INC_DEC;
   \   00000132   0x....             B.N      ??Subroutine2_0
    403                        }
    404                      break;
    405                        
    406                      case DOWN:
    407                        if (PID_Speed_InitStructure.hKp_Gain >= KP_GAIN_INC_DEC)
   \                     ??KEYS_process_19:
   \   00000134   0x.... 0x....      LDR.W    R0,??DataTable3_9
   \   00000138   0xF9B0 0x1000      LDRSH    R1,[R0, #+0]
   \   0000013C   0x29FA             CMP      R1,#+250
   \   0000013E   0xF2C0 0x83A1      BLT.W    ??KEYS_process_1
    408                        {
    409                        PID_Speed_InitStructure.hKp_Gain -= KP_GAIN_INC_DEC;
   \   00000142   0x....             B.N      ??Subroutine1_0
    410                        }
    411                      break;
    412                     
    413                      case RIGHT:
    414                          bMenu_index = I_SPEED_MENU;
    415                      break;
    416          
    417                      case LEFT:
    418                          bMenu_index = REF_SPEED_MENU;             
   \                     ??KEYS_process_17:
   \   00000144   0x....             B.N      ?Subroutine9
    419                      break;
    420                      
    421                      case SEL:
    422                        if (State == RUN)
   \                     ??KEYS_process_16:
   \   00000146   0x.... 0x....      LDR.W    R0,??DataTable3_6
   \   0000014A   0x7801             LDRB     R1,[R0, #+0]
   \   0000014C   0x2903             CMP      R1,#+3
   \   0000014E   0xBF1C             ITT      NE 
   \   00000150   0x7801             LDRBNE   R1,[R0, #+0]
   \   00000152   0x2902             CMPNE    R1,#+2
    423                        {
    424                          State = STOP;               
    425                        }
    426                        else if (State== START)
   \   00000154   0xF000 0x8392      BEQ.W    ??KEYS_process_7
    427                        {
    428                          State = STOP; 
    429                        }
    430                          else if(State == IDLE)
   \   00000158   0x7801             LDRB     R1,[R0, #+0]
   \   0000015A   0x2900             CMP      R1,#+0
   \   0000015C   0xF040 0x8392      BNE.W    ??KEYS_process_1
    431                          {
    432                            State = INIT;
   \   00000160   0xE38E             B.N      ??KEYS_process_14
    433                          }   
    434                      break;
    435                    default:
    436                      break;
    437                    }
    438                  break;
    439          
    440                  case(I_SPEED_MENU):    
    441                    switch(bKey)
   \                     ??KEYS_process_20:
   \   00000162   0x2801             CMP      R0,#+1
   \   00000164   0xD01B             BEQ.N    ??KEYS_process_21
   \   00000166   0xF0C0 0x838D      BCC.W    ??KEYS_process_1
   \   0000016A   0x2803             CMP      R0,#+3
   \   0000016C   0xD014             BEQ.N    ??KEYS_process_11
   \   0000016E   0xD310             BCC.N    ??KEYS_process_22
   \   00000170   0x2805             CMP      R0,#+5
   \   00000172   0xD00B             BEQ.N    ??KEYS_process_23
   \   00000174   0xF080 0x8386      BCS.W    ??KEYS_process_1
    442                    {
    443                      case UP:
    444                        if (PID_Speed_InitStructure.hKi_Gain <= S16_MAX-KI_GAIN_INC_DEC)
   \   00000178   0x.... 0x....      LDR.W    R0,??DataTable3_9
   \   0000017C   0xF9B0 0x1004      LDRSH    R1,[R0, #+4]
   \   00000180   0xF647 0x72E7      MOVW     R2,#+32743
   \   00000184   0x4291             CMP      R1,R2
   \   00000186   0xF280 0x837D      BGE.W    ??KEYS_process_1
    445                        {
    446                          PID_Speed_InitStructure.hKi_Gain += KI_GAIN_INC_DEC;
   \   0000018A   0x....             B.N      ?Subroutine8
    447                        }
    448                      break;
    449                        
    450                      case DOWN:
    451                        if (PID_Speed_InitStructure.hKi_Gain >= KI_GAIN_INC_DEC)
   \                     ??KEYS_process_23:
   \   0000018C   0x.... 0x....      LDR.W    R0,??DataTable3_9
   \   00000190   0xE106             B.N      ??KEYS_process_24
    452                        {
    453                        PID_Speed_InitStructure.hKi_Gain -= KI_GAIN_INC_DEC;
    454                        }
    455                      break;
    456                     
    457                      case RIGHT:
    458          #ifdef DIFFERENTIAL_TERM_ENABLED                 
    459                          bMenu_index = D_SPEED_MENU;
   \                     ??KEYS_process_22:
   \   00000192   0x2004             MOVS     R0,#+4
   \   00000194   0x7048             STRB     R0,[R1, #+1]
   \   00000196   0xBD01             POP      {R0,PC}
    460          #else
    461                          bMenu_index = P_TORQUE_MENU;
    462          #endif                
    463                      break;
    464          
    465                      case LEFT:
    466                        bMenu_index = P_SPEED_MENU;
   \                     ??KEYS_process_11:
   \   00000198   0x2002             MOVS     R0,#+2
   \   0000019A   0x7048             STRB     R0,[R1, #+1]
   \   0000019C   0xBD01             POP      {R0,PC}
    467                      break;
    468                      
    469                      case SEL:
    470                        if (State == RUN)
   \                     ??KEYS_process_21:
   \   0000019E   0x.... 0x....      LDR.W    R0,??DataTable3_6
   \   000001A2   0x7801             LDRB     R1,[R0, #+0]
   \   000001A4   0x2903             CMP      R1,#+3
   \   000001A6   0xBF1C             ITT      NE 
   \   000001A8   0x7801             LDRBNE   R1,[R0, #+0]
   \   000001AA   0x2902             CMPNE    R1,#+2
    471                        {
    472                          State = STOP;               
    473                        }
    474                        else if (State== START)
   \   000001AC   0xF000 0x8366      BEQ.W    ??KEYS_process_7
    475                        {
    476                          State = STOP; 
    477                        }
    478                          else if(State == IDLE)
   \   000001B0   0x7801             LDRB     R1,[R0, #+0]
   \   000001B2   0x2900             CMP      R1,#+0
   \   000001B4   0xF040 0x8366      BNE.W    ??KEYS_process_1
    479                          {
    480                            State = INIT;
   \   000001B8   0xE362             B.N      ??KEYS_process_14
    481                          }   
    482                      break;
    483                    default:
    484                      break;
    485                    }
    486                  break;        
    487                  
    488          #ifdef DIFFERENTIAL_TERM_ENABLED       
    489                  case(D_SPEED_MENU):    
    490                    switch(bKey)
   \                     ??KEYS_process_25:
   \   000001BA   0x2801             CMP      R0,#+1
   \   000001BC   0xD019             BEQ.N    ??KEYS_process_26
   \   000001BE   0xF0C0 0x8361      BCC.W    ??KEYS_process_1
   \   000001C2   0x2803             CMP      R0,#+3
   \   000001C4   0xD012             BEQ.N    ??KEYS_process_18
   \   000001C6   0xF0C0 0x8258      BCC.W    ??KEYS_process_27
   \   000001CA   0x2805             CMP      R0,#+5
   \   000001CC   0xD00B             BEQ.N    ??KEYS_process_28
   \   000001CE   0xF080 0x8359      BCS.W    ??KEYS_process_1
    491                    {
    492                      case UP:
    493                        if (PID_Speed_InitStructure.hKd_Gain <= S16_MAX-KD_GAIN_INC_DEC)
   \   000001D2   0x.... 0x....      LDR.W    R0,??DataTable3_9
   \   000001D6   0xF9B0 0x1018      LDRSH    R1,[R0, #+24]
   \   000001DA   0xF647 0x729C      MOVW     R2,#+32668
   \   000001DE   0x4291             CMP      R1,R2
   \   000001E0   0xF280 0x8350      BGE.W    ??KEYS_process_1
    494                        {
    495                          PID_Speed_InitStructure.hKd_Gain += KD_GAIN_INC_DEC;
   \   000001E4   0x....             B.N      ?Subroutine7
    496                        }
    497                      break;
    498                        
    499                      case DOWN:
    500                        if (PID_Speed_InitStructure.hKd_Gain >= KD_GAIN_INC_DEC)
   \                     ??KEYS_process_28:
   \   000001E6   0x.... 0x....      LDR.W    R0,??DataTable3_9
   \   000001EA   0xE109             B.N      ??KEYS_process_29
    501                        {
    502                        PID_Speed_InitStructure.hKd_Gain -= KD_GAIN_INC_DEC;
    503                        }
    504                      break;
    505                     
    506                      case RIGHT:                
    507                          bMenu_index = P_TORQUE_MENU;               
    508                      break;
    509                      
    510                      case LEFT:
    511                        bMenu_index = I_SPEED_MENU;
   \                     ??KEYS_process_18:
   \   000001EC   0x2003             MOVS     R0,#+3
   \   000001EE   0x7048             STRB     R0,[R1, #+1]
   \   000001F0   0xBD01             POP      {R0,PC}
    512                      break;
    513                      
    514                      case SEL:
    515                        if (State == RUN || State == START)
   \                     ??KEYS_process_26:
   \   000001F2   0x.... 0x....      LDR.W    R0,??DataTable3_6
   \   000001F6   0x7801             LDRB     R1,[R0, #+0]
   \   000001F8   0x2903             CMP      R1,#+3
   \   000001FA   0xBF1C             ITT      NE 
   \   000001FC   0x7801             LDRBNE   R1,[R0, #+0]
   \   000001FE   0x2902             CMPNE    R1,#+2
   \   00000200   0xF000 0x833C      BEQ.W    ??KEYS_process_7
    516                        {
    517                          State = STOP;               
    518                        }
    519                        else if(State == IDLE)
   \   00000204   0x7801             LDRB     R1,[R0, #+0]
   \   00000206   0x2900             CMP      R1,#+0
   \   00000208   0xF040 0x833C      BNE.W    ??KEYS_process_1
    520                        {
    521                          State = INIT;
   \   0000020C   0xE338             B.N      ??KEYS_process_14
    522                        }   
    523                      break;
    524                    default:
    525                      break;
    526                    }
    527                  break;   
    528          #endif
    529                  case(P_TORQUE_MENU):    
    530                    switch(bKey)
   \                     ??KEYS_process_30:
   \   0000020E   0x2801             CMP      R0,#+1
   \   00000210   0xD023             BEQ.N    ??KEYS_process_31
   \   00000212   0xF0C0 0x8337      BCC.W    ??KEYS_process_1
   \   00000216   0x2803             CMP      R0,#+3
   \   00000218   0xD016             BEQ.N    ??KEYS_process_32
   \   0000021A   0xD36B             BCC.N    ??KEYS_process_33
   \   0000021C   0x2805             CMP      R0,#+5
   \   0000021E   0xD00B             BEQ.N    ??KEYS_process_34
   \   00000220   0xF080 0x8330      BCS.W    ??KEYS_process_1
    531                    {
    532                      case UP:
    533                        if (PID_Torque_InitStructure.hKp_Gain <= S16_MAX - KP_GAIN_INC_DEC)
   \   00000224   0x.... 0x....      LDR.W    R0,??DataTable3_10
   \   00000228   0xF9B0 0x1000      LDRSH    R1,[R0, #+0]
   \   0000022C   0xF647 0x7206      MOVW     R2,#+32518
   \   00000230   0x4291             CMP      R1,R2
   \   00000232   0xF280 0x8327      BGE.W    ??KEYS_process_1
    534                        {
    535                          PID_Torque_InitStructure.hKp_Gain += KP_GAIN_INC_DEC;
   \   00000236   0x....             B.N      ??Subroutine2_0
    536                        }
    537                      break;
    538                        
    539                      case DOWN:
    540                        if (PID_Torque_InitStructure.hKp_Gain >= KP_GAIN_INC_DEC)
   \                     ??KEYS_process_34:
   \   00000238   0x.... 0x....      LDR.W    R0,??DataTable3_10
   \   0000023C   0xF9B0 0x1000      LDRSH    R1,[R0, #+0]
   \   00000240   0x29FA             CMP      R1,#+250
   \   00000242   0xF2C0 0x831F      BLT.W    ??KEYS_process_1
    541                        {
    542                        PID_Torque_InitStructure.hKp_Gain -= KP_GAIN_INC_DEC;
   \   00000246   0x....             B.N      ??Subroutine1_0
    543                        }
    544                      break;
    545                     
    546                      case RIGHT:
    547                          bMenu_index = I_TORQUE_MENU;
    548                      break;
    549                       
    550                      case LEFT:         
    551                        if ((wGlobal_Flags & SPEED_CONTROL) == SPEED_CONTROL)
   \                     ??KEYS_process_32:
   \   00000248   0x.... 0x....      LDR.W    R0,??DataTable3_5
   \   0000024C   0x6800             LDR      R0,[R0, #+0]
   \   0000024E   0x07C0             LSLS     R0,R0,#+31
   \   00000250   0xBF54             ITE      PL 
   \   00000252   0x200E             MOVPL    R0,#+14
   \   00000254   0x2004             MOVMI    R0,#+4
    552                        {
    553          #ifdef DIFFERENTIAL_TERM_ENABLED              
    554                          bMenu_index = D_SPEED_MENU;
   \   00000256   0x7048             STRB     R0,[R1, #+1]
   \   00000258   0xBD01             POP      {R0,PC}
    555          #else
    556                          bMenu_index = I_SPEED_MENU; 
    557          #endif                
    558                        }
    559                        else
    560                        {
    561                          bMenu_index = ID_REF_MENU;
    562                        }              
    563                      break;
    564                      
    565                      case SEL:
    566                        if (State == RUN)
   \                     ??KEYS_process_31:
   \   0000025A   0x.... 0x....      LDR.W    R0,??DataTable3_6
   \   0000025E   0x7801             LDRB     R1,[R0, #+0]
   \   00000260   0x2903             CMP      R1,#+3
   \   00000262   0xBF1C             ITT      NE 
   \   00000264   0x7801             LDRBNE   R1,[R0, #+0]
   \   00000266   0x2902             CMPNE    R1,#+2
    567                        {
    568                          State = STOP;               
    569                        }
    570                        else if (State== START)
   \   00000268   0xF000 0x8308      BEQ.W    ??KEYS_process_7
    571                          {
    572                            State = STOP; 
    573                          }
    574                            else if(State == IDLE)
   \   0000026C   0x7801             LDRB     R1,[R0, #+0]
   \   0000026E   0x2900             CMP      R1,#+0
   \   00000270   0xF040 0x8308      BNE.W    ??KEYS_process_1
    575                            {
    576                              State = INIT;
   \   00000274   0xE304             B.N      ??KEYS_process_14
    577                            }   
    578                      break;
    579                    default:
    580                      break;
    581                    }
    582                  break;
    583                  
    584                  case(I_TORQUE_MENU):    
    585                    switch(bKey)
   \                     ??KEYS_process_35:
   \   00000276   0x2801             CMP      R0,#+1
   \   00000278   0xD016             BEQ.N    ??KEYS_process_36
   \   0000027A   0xF0C0 0x8303      BCC.W    ??KEYS_process_1
   \   0000027E   0x2803             CMP      R0,#+3
   \   00000280   0xF000 0x81FB      BEQ.W    ??KEYS_process_27
   \   00000284   0xD364             BCC.N    ??KEYS_process_37
   \   00000286   0x2805             CMP      R0,#+5
   \   00000288   0xD00B             BEQ.N    ??KEYS_process_38
   \   0000028A   0xF080 0x82FB      BCS.W    ??KEYS_process_1
    586                    {
    587                      case UP:
    588                        if (PID_Torque_InitStructure.hKi_Gain <= S16_MAX - KI_GAIN_INC_DEC)
   \   0000028E   0x.... 0x....      LDR.W    R0,??DataTable3_10
   \   00000292   0xF9B0 0x1004      LDRSH    R1,[R0, #+4]
   \   00000296   0xF647 0x72E7      MOVW     R2,#+32743
   \   0000029A   0x4291             CMP      R1,R2
   \   0000029C   0xF280 0x82F2      BGE.W    ??KEYS_process_1
    589                        {
    590                          PID_Torque_InitStructure.hKi_Gain += KI_GAIN_INC_DEC;
   \   000002A0   0x....             B.N      ?Subroutine8
    591                        }
    592                      break;
    593                        
    594                      case DOWN:
    595                        if (PID_Torque_InitStructure.hKi_Gain >= KI_GAIN_INC_DEC)
   \                     ??KEYS_process_38:
   \   000002A2   0x.... 0x....      LDR.W    R0,??DataTable3_10
   \   000002A6   0xE07B             B.N      ??KEYS_process_24
    596                        {
    597                        PID_Torque_InitStructure.hKi_Gain -= KI_GAIN_INC_DEC;
    598                        }
    599                      break;
    600                     
    601                      case RIGHT:
    602          #ifdef DIFFERENTIAL_TERM_ENABLED                 
    603                          bMenu_index = D_TORQUE_MENU;
    604          #else
    605                          bMenu_index = P_FLUX_MENU;
    606          #endif                
    607                      break;
    608          
    609                      case LEFT:
    610                        bMenu_index = P_TORQUE_MENU;
    611                      break;
    612                      
    613                      case SEL:
    614                        if (State == RUN)
   \                     ??KEYS_process_36:
   \   000002A8   0x.... 0x....      LDR.W    R0,??DataTable3_6
   \   000002AC   0x7801             LDRB     R1,[R0, #+0]
   \   000002AE   0x2903             CMP      R1,#+3
   \   000002B0   0xBF1C             ITT      NE 
   \   000002B2   0x7801             LDRBNE   R1,[R0, #+0]
   \   000002B4   0x2902             CMPNE    R1,#+2
    615                        {
    616                          State = STOP;               
    617                        }
    618                          else if (State== START)
   \   000002B6   0xF000 0x82E1      BEQ.W    ??KEYS_process_7
    619                          {
    620                            State = STOP; 
    621                          }
    622                            else if(State == IDLE)
   \   000002BA   0x7801             LDRB     R1,[R0, #+0]
   \   000002BC   0x2900             CMP      R1,#+0
   \   000002BE   0xF040 0x82E1      BNE.W    ??KEYS_process_1
    623                            {
    624                              State = INIT;
   \   000002C2   0xE2DD             B.N      ??KEYS_process_14
    625                            }   
    626                      break;
    627                    default:
    628                      break;
    629                    }
    630                  break;
    631                  
    632          #ifdef DIFFERENTIAL_TERM_ENABLED       
    633                  case(D_TORQUE_MENU):    
    634                    switch(bKey)
   \                     ??KEYS_process_39:
   \   000002C4   0x2801             CMP      R0,#+1
   \   000002C6   0xD018             BEQ.N    ??KEYS_process_40
   \   000002C8   0xF0C0 0x82DC      BCC.W    ??KEYS_process_1
   \   000002CC   0x2803             CMP      R0,#+3
   \   000002CE   0xD011             BEQ.N    ??KEYS_process_33
   \   000002D0   0xD36E             BCC.N    ??KEYS_process_41
   \   000002D2   0x2805             CMP      R0,#+5
   \   000002D4   0xD00B             BEQ.N    ??KEYS_process_42
   \   000002D6   0xF080 0x82D5      BCS.W    ??KEYS_process_1
    635                    {
    636                      case UP:
    637                        if (PID_Torque_InitStructure.hKd_Gain <= S16_MAX - KD_GAIN_INC_DEC)
   \   000002DA   0x.... 0x....      LDR.W    R0,??DataTable3_10
   \   000002DE   0xF9B0 0x1018      LDRSH    R1,[R0, #+24]
   \   000002E2   0xF647 0x729C      MOVW     R2,#+32668
   \   000002E6   0x4291             CMP      R1,R2
   \   000002E8   0xF280 0x82CC      BGE.W    ??KEYS_process_1
    638                        {
    639                          PID_Torque_InitStructure.hKd_Gain += KD_GAIN_INC_DEC;
   \   000002EC   0x....             B.N      ?Subroutine7
    640                        }
    641                      break;
    642                        
    643                      case DOWN:
    644                        if (PID_Torque_InitStructure.hKd_Gain >= KD_GAIN_INC_DEC)
   \                     ??KEYS_process_42:
   \   000002EE   0x.... 0x....      LDR.W    R0,??DataTable3_10
   \   000002F2   0xE085             B.N      ??KEYS_process_29
    645                        {
    646                        PID_Torque_InitStructure.hKd_Gain -= KD_GAIN_INC_DEC;
    647                        }
    648                      break;
    649                     
    650                      case RIGHT:                
    651                          bMenu_index = P_FLUX_MENU;               
    652                      break;
    653                      
    654                      case LEFT:
    655                        bMenu_index = I_TORQUE_MENU;
   \                     ??KEYS_process_33:
   \   000002F4   0x2006             MOVS     R0,#+6
   \   000002F6   0x7048             STRB     R0,[R1, #+1]
   \   000002F8   0xBD01             POP      {R0,PC}
    656                      break;
    657                      
    658                      case SEL:
    659                        if (State == RUN || State == START)
   \                     ??KEYS_process_40:
   \   000002FA   0x.... 0x....      LDR.W    R0,??DataTable3_6
   \   000002FE   0x7801             LDRB     R1,[R0, #+0]
   \   00000300   0x2903             CMP      R1,#+3
   \   00000302   0xBF1C             ITT      NE 
   \   00000304   0x7801             LDRBNE   R1,[R0, #+0]
   \   00000306   0x2902             CMPNE    R1,#+2
   \   00000308   0xF000 0x82B8      BEQ.W    ??KEYS_process_7
    660                        {
    661                          State = STOP;               
    662                        }
    663                        else if(State == IDLE)
   \   0000030C   0x7801             LDRB     R1,[R0, #+0]
   \   0000030E   0x2900             CMP      R1,#+0
   \   00000310   0xF040 0x82B8      BNE.W    ??KEYS_process_1
    664                        {
    665                          State = INIT;
   \   00000314   0xE2B4             B.N      ??KEYS_process_14
    666                        }   
    667                      break;
    668                    default:
    669                      break;
    670                    }
    671                  break;   
    672          #endif 
    673                   case(P_FLUX_MENU):    
    674                    switch(bKey)
   \                     ??KEYS_process_43:
   \   00000316   0x2801             CMP      R0,#+1
   \   00000318   0xD01D             BEQ.N    ??KEYS_process_44
   \   0000031A   0xF0C0 0x82B3      BCC.W    ??KEYS_process_1
   \   0000031E   0x2803             CMP      R0,#+3
   \   00000320   0xD016             BEQ.N    ??KEYS_process_37
   \   00000322   0xD375             BCC.N    ??KEYS_process_45
   \   00000324   0x2805             CMP      R0,#+5
   \   00000326   0xD00B             BEQ.N    ??KEYS_process_46
   \   00000328   0xF080 0x82AC      BCS.W    ??KEYS_process_1
    675                    {
    676                      case UP:
    677                        if (PID_Flux_InitStructure.hKp_Gain <= S16_MAX-KP_GAIN_INC_DEC)
   \   0000032C   0x.... 0x....      LDR.W    R0,??DataTable3_11
   \   00000330   0xF9B0 0x1000      LDRSH    R1,[R0, #+0]
   \   00000334   0xF647 0x7206      MOVW     R2,#+32518
   \   00000338   0x4291             CMP      R1,R2
   \   0000033A   0xF280 0x82A3      BGE.W    ??KEYS_process_1
    678                        {
    679                          PID_Flux_InitStructure.hKp_Gain += KP_GAIN_INC_DEC;
   \   0000033E   0x....             B.N      ??Subroutine2_0
    680                        }
    681                      break;
    682                        
    683                      case DOWN:
    684                        if (PID_Flux_InitStructure.hKp_Gain >= KP_GAIN_INC_DEC)
   \                     ??KEYS_process_46:
   \   00000340   0x.... 0x....      LDR.W    R0,??DataTable3_11
   \   00000344   0xF9B0 0x1000      LDRSH    R1,[R0, #+0]
   \   00000348   0x29FA             CMP      R1,#+250
   \   0000034A   0xF2C0 0x829B      BLT.W    ??KEYS_process_1
    685                        {
    686                          PID_Flux_InitStructure.hKp_Gain -= KP_GAIN_INC_DEC;
   \   0000034E   0x....             B.N      ??Subroutine1_0
    687                        }
    688                      break;
    689                     
    690                      case RIGHT:
    691                          bMenu_index = I_FLUX_MENU;
    692                      break;
    693                       
    694                      case LEFT:         
    695          #ifdef  DIFFERENTIAL_TERM_ENABLED
    696                        bMenu_index = D_TORQUE_MENU;
   \                     ??KEYS_process_37:
   \   00000350   0x2007             MOVS     R0,#+7
   \   00000352   0x7048             STRB     R0,[R1, #+1]
   \   00000354   0xBD01             POP      {R0,PC}
    697          #else
    698                        bMenu_index = I_TORQUE_MENU;
    699          #endif              
    700                      break;
    701                      
    702                      case SEL:
    703                        if (State == RUN)
   \                     ??KEYS_process_44:
   \   00000356   0x.... 0x....      LDR.W    R0,??DataTable3_6
   \   0000035A   0x7801             LDRB     R1,[R0, #+0]
   \   0000035C   0x2903             CMP      R1,#+3
   \   0000035E   0xBF1C             ITT      NE 
   \   00000360   0x7801             LDRBNE   R1,[R0, #+0]
   \   00000362   0x2902             CMPNE    R1,#+2
    704                        {
    705                          State = STOP;               
    706                        }
    707                          else if (State== START)
   \   00000364   0xF000 0x828A      BEQ.W    ??KEYS_process_7
    708                          {
    709                            State = STOP; 
    710                          }
    711                            else if(State == IDLE)
   \   00000368   0x7801             LDRB     R1,[R0, #+0]
   \   0000036A   0x2900             CMP      R1,#+0
   \   0000036C   0xF040 0x828A      BNE.W    ??KEYS_process_1
    712                            {
    713                              State = INIT;
   \   00000370   0xE286             B.N      ??KEYS_process_14
    714                            }   
    715                      break;
    716                    default:
    717                      break;
    718                    }
    719                  break;
    720                  
    721                  case(I_FLUX_MENU):    
    722                    switch(bKey)
   \                     ??KEYS_process_47:
   \   00000372   0x2801             CMP      R0,#+1
   \   00000374   0xD01F             BEQ.N    ??KEYS_process_48
   \   00000376   0xF0C0 0x8285      BCC.W    ??KEYS_process_1
   \   0000037A   0x2803             CMP      R0,#+3
   \   0000037C   0xD018             BEQ.N    ??KEYS_process_41
   \   0000037E   0xD379             BCC.N    ??KEYS_process_49
   \   00000380   0x2805             CMP      R0,#+5
   \   00000382   0xD00B             BEQ.N    ??KEYS_process_50
   \   00000384   0xF080 0x827E      BCS.W    ??KEYS_process_1
    723                    {
    724                      case UP:
    725                        if (PID_Flux_InitStructure.hKi_Gain <= S16_MAX-KI_GAIN_INC_DEC)
   \   00000388   0x.... 0x....      LDR.W    R0,??DataTable3_11
   \   0000038C   0xF9B0 0x1004      LDRSH    R1,[R0, #+4]
   \   00000390   0xF647 0x72E7      MOVW     R2,#+32743
   \   00000394   0x4291             CMP      R1,R2
   \   00000396   0xF280 0x8275      BGE.W    ??KEYS_process_1
    726                        {
    727                          PID_Flux_InitStructure.hKi_Gain += KI_GAIN_INC_DEC;
   \   0000039A   0x....             B.N      ?Subroutine8
    728                        }
    729                      break;
    730                        
    731                      case DOWN:
    732                        if (PID_Flux_InitStructure.hKi_Gain >= KI_GAIN_INC_DEC)
   \                     ??KEYS_process_50:
   \   0000039C   0x.... 0x....      LDR.W    R0,??DataTable3_11
   \                     ??KEYS_process_24:
   \   000003A0   0xF9B0 0x1004      LDRSH    R1,[R0, #+4]
   \   000003A4   0x2919             CMP      R1,#+25
   \   000003A6   0xF2C0 0x826D      BLT.W    ??KEYS_process_1
    733                        {
    734                        PID_Flux_InitStructure.hKi_Gain -= KI_GAIN_INC_DEC;
   \   000003AA   0x3919             SUBS     R1,R1,#+25
   \   000003AC   0x8081             STRH     R1,[R0, #+4]
   \   000003AE   0xBD01             POP      {R0,PC}
    735                        }
    736                      break;
    737                     
    738                      case RIGHT:
    739          #ifdef DIFFERENTIAL_TERM_ENABLED                 
    740                          bMenu_index = D_FLUX_MENU;
    741          #elif defined FLUX_WEAKENING
    742                          bMenu_index = P_VOLT_MENU;
    743          #else                
    744                          bMenu_index = POWER_STAGE_MENU;
    745          #endif                
    746                      break;
    747          
    748                      case LEFT:
    749                        bMenu_index = P_FLUX_MENU;
   \                     ??KEYS_process_41:
   \   000003B0   0x2008             MOVS     R0,#+8
   \   000003B2   0x7048             STRB     R0,[R1, #+1]
   \   000003B4   0xBD01             POP      {R0,PC}
    750                      break;
    751                      
    752                      case SEL:
    753                        if (State == RUN)
   \                     ??KEYS_process_48:
   \   000003B6   0x.... 0x....      LDR.W    R0,??DataTable3_6
   \   000003BA   0x7801             LDRB     R1,[R0, #+0]
   \   000003BC   0x2903             CMP      R1,#+3
   \   000003BE   0xBF1C             ITT      NE 
   \   000003C0   0x7801             LDRBNE   R1,[R0, #+0]
   \   000003C2   0x2902             CMPNE    R1,#+2
    754                        {
    755                          State = STOP;               
    756                        }
    757                          else if (State== START)
   \   000003C4   0xF000 0x825A      BEQ.W    ??KEYS_process_7
    758                          {
    759                            State = STOP; 
    760                          }
    761                            else if(State == IDLE)
   \   000003C8   0x7801             LDRB     R1,[R0, #+0]
   \   000003CA   0x2900             CMP      R1,#+0
   \   000003CC   0xF040 0x825A      BNE.W    ??KEYS_process_1
    762                            {
    763                              State = INIT;
   \   000003D0   0xE256             B.N      ??KEYS_process_14
    764                            }   
    765                      break;
    766                    default:
    767                      break;
    768                    }
    769                  break;
    770                  
    771          #ifdef DIFFERENTIAL_TERM_ENABLED       
    772                  case(D_FLUX_MENU):    
    773                    switch(bKey)
   \                     ??KEYS_process_51:
   \   000003D2   0x2801             CMP      R0,#+1
   \   000003D4   0xD01F             BEQ.N    ??KEYS_process_52
   \   000003D6   0xF0C0 0x8255      BCC.W    ??KEYS_process_1
   \   000003DA   0x2803             CMP      R0,#+3
   \   000003DC   0xD018             BEQ.N    ??KEYS_process_45
   \   000003DE   0xD377             BCC.N    ??KEYS_process_53
   \   000003E0   0x2805             CMP      R0,#+5
   \   000003E2   0xD00B             BEQ.N    ??KEYS_process_54
   \   000003E4   0xF080 0x824E      BCS.W    ??KEYS_process_1
    774                    {
    775                      case UP:
    776                        if (PID_Flux_InitStructure.hKd_Gain <= S16_MAX - KD_GAIN_INC_DEC)
   \   000003E8   0x.... 0x....      LDR.W    R0,??DataTable3_11
   \   000003EC   0xF9B0 0x1018      LDRSH    R1,[R0, #+24]
   \   000003F0   0xF647 0x729C      MOVW     R2,#+32668
   \   000003F4   0x4291             CMP      R1,R2
   \   000003F6   0xF280 0x8245      BGE.W    ??KEYS_process_1
    777                        {
    778                          PID_Flux_InitStructure.hKd_Gain += KD_GAIN_INC_DEC;
   \   000003FA   0x....             B.N      ?Subroutine7
    779                        }
    780                      break;
    781                        
    782                      case DOWN:
    783                        if (PID_Flux_InitStructure.hKd_Gain >= KD_GAIN_INC_DEC)
   \                     ??KEYS_process_54:
   \   000003FC   0x.... 0x....      LDR.W    R0,??DataTable3_11
   \                     ??KEYS_process_29:
   \   00000400   0xF9B0 0x1018      LDRSH    R1,[R0, #+24]
   \   00000404   0x2964             CMP      R1,#+100
   \   00000406   0xF2C0 0x823D      BLT.W    ??KEYS_process_1
    784                        {
    785                        PID_Flux_InitStructure.hKd_Gain -= KD_GAIN_INC_DEC;
   \   0000040A   0x3964             SUBS     R1,R1,#+100
   \   0000040C   0x8301             STRH     R1,[R0, #+24]
   \   0000040E   0xBD01             POP      {R0,PC}
    786                        }
    787                      break;
    788                     
    789                      case RIGHT:
    790          #ifdef FLUX_WEAKENING
    791                          bMenu_index = P_VOLT_MENU;
    792          #else
    793                          bMenu_index = POWER_STAGE_MENU;
    794          #endif                
    795                      break;
    796                      
    797                      case LEFT:              
    798                        bMenu_index = I_FLUX_MENU;
   \                     ??KEYS_process_45:
   \   00000410   0x2009             MOVS     R0,#+9
   \   00000412   0x7048             STRB     R0,[R1, #+1]
   \   00000414   0xBD01             POP      {R0,PC}
    799                      break;
    800                      
    801                      case SEL:
    802                        if (State == RUN || State == START)
   \                     ??KEYS_process_52:
   \   00000416   0x.... 0x....      LDR.W    R0,??DataTable3_6
   \   0000041A   0x7801             LDRB     R1,[R0, #+0]
   \   0000041C   0x2903             CMP      R1,#+3
   \   0000041E   0xBF1C             ITT      NE 
   \   00000420   0x7801             LDRBNE   R1,[R0, #+0]
   \   00000422   0x2902             CMPNE    R1,#+2
   \   00000424   0xF000 0x822A      BEQ.W    ??KEYS_process_7
    803                        {
    804                          State = STOP;               
    805                        }
    806                        else if(State == IDLE)
   \   00000428   0x7801             LDRB     R1,[R0, #+0]
   \   0000042A   0x2900             CMP      R1,#+0
   \   0000042C   0xF040 0x822A      BNE.W    ??KEYS_process_1
    807                        {
    808                          State = INIT;
   \   00000430   0xE226             B.N      ??KEYS_process_14
    809                        }   
    810                      break;
    811                    default:
    812                      break;
    813                    }
    814                  break;   
    815          #endif
    816          
    817          #ifdef FLUX_WEAKENING        
    818                   case(P_VOLT_MENU):    
    819                    switch(bKey)
   \                     ??KEYS_process_55:
   \   00000432   0x2801             CMP      R0,#+1
   \   00000434   0xD021             BEQ.N    ??KEYS_process_56
   \   00000436   0xF0C0 0x8225      BCC.W    ??KEYS_process_1
   \   0000043A   0x2803             CMP      R0,#+3
   \   0000043C   0xD01A             BEQ.N    ??KEYS_process_49
   \   0000043E   0xD37A             BCC.N    ??KEYS_process_57
   \   00000440   0x2805             CMP      R0,#+5
   \   00000442   0xD00D             BEQ.N    ??KEYS_process_58
   \   00000444   0xF080 0x821E      BCS.W    ??KEYS_process_1
    820                    {
    821                      case UP:
    822                        if (hFW_P_Gain <= 32500)
   \   00000448   0x.... 0x....      LDR.W    R0,??DataTable3_12
   \   0000044C   0xF9B0 0x1000      LDRSH    R1,[R0, #+0]
   \   00000450   0xF647 0x62F5      MOVW     R2,#+32501
   \   00000454   0x4291             CMP      R1,R2
   \   00000456   0xF280 0x8215      BGE.W    ??KEYS_process_1
    823                        {
    824                          hFW_P_Gain += KP_VOLT_INC_DEC;
   \   0000045A   0x3132             ADDS     R1,R1,#+50
   \   0000045C   0x8001             STRH     R1,[R0, #+0]
   \   0000045E   0xBD01             POP      {R0,PC}
    825                        }
    826                      break;
    827                        
    828                      case DOWN:
    829                        if (hFW_P_Gain >= KP_VOLT_INC_DEC)
   \                     ??KEYS_process_58:
   \   00000460   0x.... 0x....      LDR.W    R0,??DataTable3_12
   \   00000464   0xF9B0 0x1000      LDRSH    R1,[R0, #+0]
   \   00000468   0x2932             CMP      R1,#+50
   \   0000046A   0xF2C0 0x820B      BLT.W    ??KEYS_process_1
    830                        {
    831                          hFW_P_Gain -= KP_VOLT_INC_DEC;
   \   0000046E   0x3932             SUBS     R1,R1,#+50
   \   00000470   0x8001             STRH     R1,[R0, #+0]
   \   00000472   0xBD01             POP      {R0,PC}
    832                        }
    833                      break;
    834                     
    835                      case RIGHT:
    836                          bMenu_index = I_VOLT_MENU;
    837                      break;
    838                       
    839                      case LEFT:
    840          #ifdef DIFFERENTIAL_TERM_ENABLED            
    841                        bMenu_index = D_FLUX_MENU;
   \                     ??KEYS_process_49:
   \   00000474   0x200A             MOVS     R0,#+10
   \   00000476   0x7048             STRB     R0,[R1, #+1]
   \   00000478   0xBD01             POP      {R0,PC}
    842          #else              
    843                        bMenu_index = I_FLUX_MENU;
    844          #endif              
    845                      break;
    846                      
    847                      case SEL:
    848                        if (State == RUN)
   \                     ??KEYS_process_56:
   \   0000047A   0x.... 0x....      LDR.W    R0,??DataTable3_6
   \   0000047E   0x7801             LDRB     R1,[R0, #+0]
   \   00000480   0x2903             CMP      R1,#+3
   \   00000482   0xBF1C             ITT      NE 
   \   00000484   0x7801             LDRBNE   R1,[R0, #+0]
   \   00000486   0x2902             CMPNE    R1,#+2
    849                        {
    850                          State = STOP;               
    851                        }
    852                          else if (State== START)
   \   00000488   0xF000 0x81F8      BEQ.W    ??KEYS_process_7
    853                          {
    854                            State = STOP; 
    855                          }
    856                            else if(State == IDLE)
   \   0000048C   0x7801             LDRB     R1,[R0, #+0]
   \   0000048E   0x2900             CMP      R1,#+0
   \   00000490   0xF040 0x81F8      BNE.W    ??KEYS_process_1
    857                            {
    858                              State = INIT;
   \   00000494   0xE1F4             B.N      ??KEYS_process_14
    859                            }   
    860                      break;
    861                    default:
    862                      break;
    863                    }
    864                  break;
    865                  
    866                  case(I_VOLT_MENU):    
    867                    switch(bKey)
   \                     ??KEYS_process_59:
   \   00000496   0x2801             CMP      R0,#+1
   \   00000498   0xD01D             BEQ.N    ??KEYS_process_60
   \   0000049A   0xF0C0 0x81F3      BCC.W    ??KEYS_process_1
   \   0000049E   0x2803             CMP      R0,#+3
   \   000004A0   0xD016             BEQ.N    ??KEYS_process_53
   \   000004A2   0xD362             BCC.N    ??KEYS_process_61
   \   000004A4   0x2805             CMP      R0,#+5
   \   000004A6   0xD00B             BEQ.N    ??KEYS_process_62
   \   000004A8   0xF080 0x81EC      BCS.W    ??KEYS_process_1
    868                    {
    869                      case UP:
    870                        if (hFW_I_Gain <= 32500)
   \   000004AC   0x.... 0x....      LDR.W    R0,??DataTable3_13
   \   000004B0   0xF9B0 0x1000      LDRSH    R1,[R0, #+0]
   \   000004B4   0xF647 0x62F5      MOVW     R2,#+32501
   \   000004B8   0x4291             CMP      R1,R2
   \   000004BA   0xF280 0x81E3      BGE.W    ??KEYS_process_1
    871                        {
    872                          hFW_I_Gain += KI_VOLT_INC_DEC;
   \   000004BE   0x....             B.N      ?Subroutine6
    873                        }
    874                      break;
    875                        
    876                      case DOWN:
    877                        if (hFW_I_Gain >= KI_VOLT_INC_DEC)
   \                     ??KEYS_process_62:
   \   000004C0   0x.... 0x....      LDR.W    R0,??DataTable3_13
   \   000004C4   0xF9B0 0x1000      LDRSH    R1,[R0, #+0]
   \   000004C8   0x290A             CMP      R1,#+10
   \   000004CA   0xF2C0 0x81DB      BLT.W    ??KEYS_process_1
    878                        {
    879                          hFW_I_Gain -= KI_VOLT_INC_DEC;
   \   000004CE   0x....             B.N      ?Subroutine5
    880                        }
    881                      break;
    882                     
    883                      case RIGHT:
    884                          bMenu_index = TARGET_VOLT_MENU;
    885                      break;
    886          
    887                      case LEFT:
    888                        bMenu_index = P_VOLT_MENU;
   \                     ??KEYS_process_53:
   \   000004D0   0x2017             MOVS     R0,#+23
   \   000004D2   0x7048             STRB     R0,[R1, #+1]
   \   000004D4   0xBD01             POP      {R0,PC}
    889                      break;
    890                      
    891                      case SEL:
    892                        if (State == RUN)
   \                     ??KEYS_process_60:
   \   000004D6   0x.... 0x....      LDR.W    R0,??DataTable3_6
   \   000004DA   0x7801             LDRB     R1,[R0, #+0]
   \   000004DC   0x2903             CMP      R1,#+3
   \   000004DE   0xBF1C             ITT      NE 
   \   000004E0   0x7801             LDRBNE   R1,[R0, #+0]
   \   000004E2   0x2902             CMPNE    R1,#+2
    893                        {
    894                          State = STOP;               
    895                        }
    896                          else if (State== START)
   \   000004E4   0xF000 0x81CA      BEQ.W    ??KEYS_process_7
    897                          {
    898                            State = STOP; 
    899                          }
    900                            else if(State == IDLE)
   \   000004E8   0x7801             LDRB     R1,[R0, #+0]
   \   000004EA   0x2900             CMP      R1,#+0
   \   000004EC   0xF040 0x81CA      BNE.W    ??KEYS_process_1
    901                            {
    902                              State = INIT;
   \   000004F0   0xE1C6             B.N      ??KEYS_process_14
    903                            }   
    904                      break;
    905                    default:
    906                      break;
    907                    }
    908                  break;
    909                  
    910                  case(TARGET_VOLT_MENU):    
    911                    switch(bKey)
   \                     ??KEYS_process_63:
   \   000004F2   0x2801             CMP      R0,#+1
   \   000004F4   0xD022             BEQ.N    ??KEYS_process_64
   \   000004F6   0xF0C0 0x81C5      BCC.W    ??KEYS_process_1
   \   000004FA   0x2803             CMP      R0,#+3
   \   000004FC   0xD01B             BEQ.N    ??KEYS_process_57
   \   000004FE   0xF0C0 0x80EC      BCC.W    ??KEYS_process_65
   \   00000502   0x2805             CMP      R0,#+5
   \   00000504   0xD00D             BEQ.N    ??KEYS_process_66
   \   00000506   0xF080 0x81BD      BCS.W    ??KEYS_process_1
    912                    {
    913                      case UP:
    914                        if (hFW_V_Ref <= (1000-VOLT_LIM_INC_DEC))
   \   0000050A   0x.... 0x....      LDR.W    R0,??DataTable3_14
   \   0000050E   0xF9B0 0x1000      LDRSH    R1,[R0, #+0]
   \   00000512   0xF44F 0x7279      MOV      R2,#+996
   \   00000516   0x4291             CMP      R1,R2
   \   00000518   0xF280 0x81B4      BGE.W    ??KEYS_process_1
    915                        {
    916                          hFW_V_Ref += VOLT_LIM_INC_DEC;
   \   0000051C   0x1D49             ADDS     R1,R1,#+5
   \   0000051E   0x8001             STRH     R1,[R0, #+0]
   \   00000520   0xBD01             POP      {R0,PC}
    917                        }
    918                      break;
    919                        
    920                      case DOWN:
    921                        if (hFW_V_Ref >= VOLT_LIM_INC_DEC)
   \                     ??KEYS_process_66:
   \   00000522   0x.... 0x....      LDR.W    R0,??DataTable3_14
   \   00000526   0xF9B0 0x1000      LDRSH    R1,[R0, #+0]
   \   0000052A   0x2905             CMP      R1,#+5
   \   0000052C   0xF2C0 0x81AA      BLT.W    ??KEYS_process_1
    922                        {
    923                          hFW_V_Ref -= VOLT_LIM_INC_DEC;
   \   00000530   0x1F49             SUBS     R1,R1,#+5
   \   00000532   0x8001             STRH     R1,[R0, #+0]
   \   00000534   0xBD01             POP      {R0,PC}
    924                        }
    925                      break;
    926                     
    927                      case RIGHT:
    928                          bMenu_index = POWER_STAGE_MENU;
    929                      break;
    930          
    931                      case LEFT:
    932                        bMenu_index = I_VOLT_MENU;
   \                     ??KEYS_process_57:
   \   00000536   0x2018             MOVS     R0,#+24
   \   00000538   0x7048             STRB     R0,[R1, #+1]
   \   0000053A   0xBD01             POP      {R0,PC}
    933                      break;
    934                      
    935                      case SEL:
    936                        if (State == RUN)
   \                     ??KEYS_process_64:
   \   0000053C   0x.... 0x....      LDR.W    R0,??DataTable3_6
   \   00000540   0x7801             LDRB     R1,[R0, #+0]
   \   00000542   0x2903             CMP      R1,#+3
   \   00000544   0xBF1C             ITT      NE 
   \   00000546   0x7801             LDRBNE   R1,[R0, #+0]
   \   00000548   0x2902             CMPNE    R1,#+2
    937                        {
    938                          State = STOP;               
    939                        }
    940                          else if (State== START)
   \   0000054A   0xF000 0x8197      BEQ.W    ??KEYS_process_7
    941                          {
    942                            State = STOP; 
    943                          }
    944                            else if(State == IDLE)
   \   0000054E   0x7801             LDRB     R1,[R0, #+0]
   \   00000550   0x2900             CMP      R1,#+0
   \   00000552   0xF040 0x8197      BNE.W    ??KEYS_process_1
    945                            {
    946                              State = INIT;
   \   00000556   0xE193             B.N      ??KEYS_process_14
    947                            }   
    948                      break;
    949                    default:
    950                      break;
    951                    }
    952                  break;        
    953                  
    954          #endif        
    955                  
    956                  case(POWER_STAGE_MENU):
    957                    switch(bKey)
   \                     ??KEYS_process_67:
   \   00000558   0x2801             CMP      R0,#+1
   \   0000055A   0xD009             BEQ.N    ??KEYS_process_68
   \   0000055C   0xF0C0 0x8192      BCC.W    ??KEYS_process_1
   \   00000560   0x2803             CMP      R0,#+3
   \   00000562   0xD002             BEQ.N    ??KEYS_process_61
   \   00000564   0xF0C0 0x80EC      BCC.W    ??KEYS_process_69
   \   00000568   0xBD01             POP      {R0,PC}
    958                    {
    959                      case RIGHT:  
    960          #ifdef OBSERVER_GAIN_TUNING
    961                        bMenu_index = K1_MENU;
    962          #elif defined DAC_FUNCTIONALITY
    963                        bMenu_index = DAC_PB0_MENU;
    964          #else              
    965                        if ((wGlobal_Flags & SPEED_CONTROL == SPEED_CONTROL))
    966                        {
    967                          if (State == IDLE)
    968                          {
    969                            bMenu_index = CONTROL_MODE_MENU_1;
    970                          }
    971                          else
    972                          {
    973                            bMenu_index = REF_SPEED_MENU;
    974                          }
    975                        }
    976                        else //Torque control
    977                        {
    978                          if (State == IDLE)
    979                          {
    980                            bMenu_index = CONTROL_MODE_MENU_6;
    981                          }
    982                          else
    983                          {
    984                            bMenu_index = IQ_REF_MENU;
    985                          }
    986                        }
    987          #endif              
    988                      break;
    989                      
    990                      case LEFT:
    991          #ifdef FLUX_WEAKENING
    992                        bMenu_index = TARGET_VOLT_MENU;              
   \                     ??KEYS_process_61:
   \   0000056A   0x2019             MOVS     R0,#+25
   \   0000056C   0x7048             STRB     R0,[R1, #+1]
   \   0000056E   0xBD01             POP      {R0,PC}
    993          #elif defined DIFFERENTIAL_TERM_ENABLED            
    994                        bMenu_index = D_FLUX_MENU;
    995          #else
    996                        bMenu_index = I_FLUX_MENU;                          
    997          #endif              
    998                      break;
    999                      
   1000                      case SEL:
   1001                        if (State == RUN)
   \                     ??KEYS_process_68:
   \   00000570   0x.... 0x....      LDR.W    R0,??DataTable3_6
   \   00000574   0x7801             LDRB     R1,[R0, #+0]
   \   00000576   0x2903             CMP      R1,#+3
   \   00000578   0xBF1C             ITT      NE 
   \   0000057A   0x7801             LDRBNE   R1,[R0, #+0]
   \   0000057C   0x2902             CMPNE    R1,#+2
   1002                        {
   1003                          State = STOP;               
   1004                        }
   1005                          else if (State== START)
   \   0000057E   0xF000 0x817D      BEQ.W    ??KEYS_process_7
   1006                          {
   1007                            State = STOP; 
   1008                          }
   1009                            else if(State == IDLE)
   \   00000582   0x7801             LDRB     R1,[R0, #+0]
   \   00000584   0x2900             CMP      R1,#+0
   \   00000586   0xF040 0x817D      BNE.W    ??KEYS_process_1
   1010                            {
   1011                              State = INIT;
   \   0000058A   0xE179             B.N      ??KEYS_process_14
   1012                            }   
   1013                      break;
   1014                    default:
   1015                      break;
   1016                    }
   1017                  break; 
   1018                  
   1019                  case(CONTROL_MODE_MENU_6):
   1020                    switch(bKey)
   \                     ??KEYS_process_70:
   \   0000058C   0x2801             CMP      R0,#+1
   \   0000058E   0xD013             BEQ.N    ??KEYS_process_71
   \   00000590   0xF0C0 0x8178      BCC.W    ??KEYS_process_1
   \   00000594   0x2803             CMP      R0,#+3
   \   00000596   0xD00E             BEQ.N    ??KEYS_process_72
   \   00000598   0xD30C             BCC.N    ??KEYS_process_73
   \   0000059A   0x2805             CMP      R0,#+5
   \   0000059C   0xD001             BEQ.N    ??KEYS_process_74
   \   0000059E   0xF080 0x8171      BCS.W    ??KEYS_process_1
   1021                    {
   1022                      case UP:
   1023                      case DOWN:
   1024                        wGlobal_Flags ^= SPEED_CONTROL;
   \                     ??KEYS_process_74:
   \   000005A2   0x.... 0x....      LDR.W    R0,??DataTable3_5
   \   000005A6   0x6802             LDR      R2,[R0, #+0]
   \   000005A8   0xF082 0x0201      EOR      R2,R2,#0x1
   \   000005AC   0x6002             STR      R2,[R0, #+0]
   1025                        bMenu_index = CONTROL_MODE_MENU_1;
   \   000005AE   0x2000             MOVS     R0,#+0
   \   000005B0   0x7048             STRB     R0,[R1, #+1]
   \   000005B2   0xBD01             POP      {R0,PC}
   1026                      break;
   1027                      
   1028                      case RIGHT:
   1029                          bMenu_index = IQ_REF_MENU;
   \                     ??KEYS_process_73:
   \   000005B4   0x....             B.N      ?Subroutine4
   1030                      break;
   1031                      
   1032                      case LEFT:
   1033          #ifdef DAC_FUNCTIONALITY              
   1034                        bMenu_index = DAC_PB1_MENU;
   \                     ??KEYS_process_72:
   \   000005B6   0x....             B.N      ?Subroutine3
   1035          #elif defined OBSERVER_GAIN_TUNING
   1036                        bMenu_index = I_PLL_MENU;          
   1037          #else              
   1038                        bMenu_index = POWER_STAGE_MENU;
   1039          #endif 
   1040                      break;
   1041                      
   1042                      case SEL:
   1043                        if (State == RUN)
   \                     ??KEYS_process_71:
   \   000005B8   0x.... 0x....      LDR.W    R0,??DataTable3_6
   \   000005BC   0x7802             LDRB     R2,[R0, #+0]
   \   000005BE   0x2A03             CMP      R2,#+3
   \   000005C0   0xBF1C             ITT      NE 
   \   000005C2   0x7802             LDRBNE   R2,[R0, #+0]
   \   000005C4   0x2A02             CMPNE    R2,#+2
   1044                        {
   1045                          State = STOP;               
   1046                        }
   1047                          else if (State== START)
   \   000005C6   0xF000 0x8159      BEQ.W    ??KEYS_process_7
   1048                          {
   1049                            State = STOP; 
   1050                          }
   1051                            else if(State == IDLE)
   \   000005CA   0x7802             LDRB     R2,[R0, #+0]
   \   000005CC   0x2A00             CMP      R2,#+0
   \   000005CE   0xF040 0x8159      BNE.W    ??KEYS_process_1
   1052                            {
   1053                              State = INIT;
   \   000005D2   0x2201             MOVS     R2,#+1
   \   000005D4   0x7002             STRB     R2,[R0, #+0]
   1054                              bMenu_index = IQ_REF_MENU;
   \   000005D6   0x....             B.N      ?Subroutine4
   1055                            }   
   1056                      break;
   1057                      default:
   1058                      break;
   1059                    }
   1060                  break;  
   1061                  
   1062                  case(IQ_REF_MENU):
   1063                    switch(bKey)
   \                     ??KEYS_process_75:
   \   000005D8   0x2801             CMP      R0,#+1
   \   000005DA   0xD025             BEQ.N    ??KEYS_process_76
   \   000005DC   0xF0C0 0x8152      BCC.W    ??KEYS_process_1
   \   000005E0   0x2803             CMP      R0,#+3
   \   000005E2   0xD019             BEQ.N    ??KEYS_process_77
   \   000005E4   0xD315             BCC.N    ??KEYS_process_78
   \   000005E6   0x2805             CMP      R0,#+5
   \   000005E8   0xD00B             BEQ.N    ??KEYS_process_79
   \   000005EA   0xF080 0x814B      BCS.W    ??KEYS_process_1
   1064                    {
   1065                      case UP:
   1066                        if (hTorque_Reference <= NOMINAL_CURRENT - TORQUE_INC_DEC)
   \   000005EE   0x.... 0x....      LDR.W    R0,??DataTable3_15
   \   000005F2   0xF9B0 0x1000      LDRSH    R1,[R0, #+0]
   \   000005F6   0xF645 0x32B6      MOVW     R2,#+23478
   \   000005FA   0x4291             CMP      R1,R2
   \   000005FC   0xF280 0x8142      BGE.W    ??KEYS_process_1
   1067                        {
   1068                          hTorque_Reference += TORQUE_INC_DEC;
   \   00000600   0x....             B.N      ?Subroutine2
   1069                        }
   1070                      break;
   1071                      
   1072                      case DOWN:
   1073                      if (hTorque_Reference >= -NOMINAL_CURRENT + TORQUE_INC_DEC)
   \                     ??KEYS_process_79:
   \   00000602   0x....             LDR.N    R0,??DataTable3_15
   \   00000604   0xF9B0 0x1000      LDRSH    R1,[R0, #+0]
   \   00000608   0x....             LDR.N    R2,??DataTable3_16  ;; 0xffffa44b
   \   0000060A   0x4291             CMP      R1,R2
   \   0000060C   0xF2C0 0x813A      BLT.W    ??KEYS_process_1
   1074                      {
   1075                        hTorque_Reference -= TORQUE_INC_DEC;
   \   00000610   0x....             B.N      ?Subroutine1
   1076                      }
   1077                      break;
   1078                      
   1079                      case RIGHT:
   1080                          bMenu_index = ID_REF_MENU;
   \                     ??KEYS_process_78:
   \   00000612   0x200E             MOVS     R0,#+14
   \   00000614   0x7048             STRB     R0,[R1, #+1]
   \   00000616   0xBD01             POP      {R0,PC}
   1081                      break;
   1082                      
   1083                      case LEFT:
   1084                        if(State == IDLE)
   \                     ??KEYS_process_77:
   \   00000618   0x....             LDR.N    R0,??DataTable3_6
   \   0000061A   0x7800             LDRB     R0,[R0, #+0]
   \   0000061C   0x2800             CMP      R0,#+0
   \   0000061E   0xBF14             ITE      NE 
   \   00000620   0x2016             MOVNE    R0,#+22
   \   00000622   0x200C             MOVEQ    R0,#+12
   1085                        {
   1086                          bMenu_index = CONTROL_MODE_MENU_6;
   \   00000624   0x7048             STRB     R0,[R1, #+1]
   \   00000626   0xBD01             POP      {R0,PC}
   1087                        }
   1088                        else
   1089                        {
   1090          #ifdef DAC_FUNCTIONALITY              
   1091                        bMenu_index = DAC_PB1_MENU;
   1092          #elif defined OBSERVER_GAIN_TUNING
   1093                        bMenu_index = I_PLL_MENU;          
   1094          #else              
   1095                        bMenu_index = POWER_STAGE_MENU;
   1096          #endif 
   1097                        }
   1098                      break;
   1099                      
   1100                      case SEL:
   1101                        if (State == RUN)
   \                     ??KEYS_process_76:
   \   00000628   0x....             LDR.N    R0,??DataTable3_6
   \   0000062A   0x7801             LDRB     R1,[R0, #+0]
   \   0000062C   0x2903             CMP      R1,#+3
   \   0000062E   0xBF1C             ITT      NE 
   \   00000630   0x7801             LDRBNE   R1,[R0, #+0]
   \   00000632   0x2902             CMPNE    R1,#+2
   1102                        {
   1103                          State = STOP;               
   1104                        }
   1105                          else if (State== START)
   \   00000634   0xF000 0x8122      BEQ.W    ??KEYS_process_7
   1106                          {
   1107                            State = STOP; 
   1108                          }
   1109                            else if(State == IDLE)
   \   00000638   0x7801             LDRB     R1,[R0, #+0]
   \   0000063A   0x2900             CMP      R1,#+0
   \   0000063C   0xF040 0x8122      BNE.W    ??KEYS_process_1
   1110                            {
   1111                              State = INIT;
   \   00000640   0xE11E             B.N      ??KEYS_process_14
   1112                            }   
   1113                      break;
   1114                      default:
   1115                      break;
   1116                    }
   1117                  break;    
   1118                  
   1119                  case(ID_REF_MENU):
   1120                    switch(bKey)
   \                     ??KEYS_process_80:
   \   00000642   0x2801             CMP      R0,#+1
   \   00000644   0xD01D             BEQ.N    ??KEYS_process_81
   \   00000646   0xF0C0 0x811D      BCC.W    ??KEYS_process_1
   \   0000064A   0x2803             CMP      R0,#+3
   \   0000064C   0xD018             BEQ.N    ??KEYS_process_82
   \   0000064E   0xD314             BCC.N    ??KEYS_process_27
   \   00000650   0x2805             CMP      R0,#+5
   \   00000652   0xD00A             BEQ.N    ??KEYS_process_83
   \   00000654   0xF080 0x8116      BCS.W    ??KEYS_process_1
   1121                    {
   1122                      case UP:
   1123                        if (hFlux_Reference <= NOMINAL_CURRENT - FLUX_INC_DEC)
   \   00000658   0x....             LDR.N    R0,??DataTable3_17
   \   0000065A   0xF9B0 0x1000      LDRSH    R1,[R0, #+0]
   \   0000065E   0xF645 0x32B6      MOVW     R2,#+23478
   \   00000662   0x4291             CMP      R1,R2
   \   00000664   0xF280 0x810E      BGE.W    ??KEYS_process_1
   1124                        {
   1125                          hFlux_Reference += FLUX_INC_DEC;
   \   00000668   0x....             B.N      ?Subroutine2
   1126                        }
   1127                      break;
   1128                      
   1129                      case DOWN:
   1130                        if (hFlux_Reference >= FLUX_INC_DEC - NOMINAL_CURRENT)
   \                     ??KEYS_process_83:
   \   0000066A   0x....             LDR.N    R0,??DataTable3_17
   \   0000066C   0xF9B0 0x1000      LDRSH    R1,[R0, #+0]
   \   00000670   0x....             LDR.N    R2,??DataTable3_16  ;; 0xffffa44b
   \   00000672   0x4291             CMP      R1,R2
   \   00000674   0xF2C0 0x8106      BLT.W    ??KEYS_process_1
   1131                        {
   1132                          hFlux_Reference -= FLUX_INC_DEC;
   \   00000678   0x....             B.N      ?Subroutine1
   1133                        }
   1134                      break;
   1135                      
   1136                      case RIGHT:
   1137                        bMenu_index = P_TORQUE_MENU;
   \                     ??KEYS_process_27:
   \   0000067A   0x2005             MOVS     R0,#+5
   \   0000067C   0x7048             STRB     R0,[R1, #+1]
   \   0000067E   0xBD01             POP      {R0,PC}
   1138                      break;
   1139                      
   1140                      case LEFT:
   1141                        bMenu_index = IQ_REF_MENU;
   \                     ??KEYS_process_82:
   \   00000680   0x....             B.N      ?Subroutine4
   1142                      break;
   1143                      
   1144                      case SEL:
   1145                        if (State == RUN)
   \                     ??KEYS_process_81:
   \   00000682   0x....             LDR.N    R0,??DataTable3_6
   \   00000684   0x7801             LDRB     R1,[R0, #+0]
   \   00000686   0x2903             CMP      R1,#+3
   \   00000688   0xBF1C             ITT      NE 
   \   0000068A   0x7801             LDRBNE   R1,[R0, #+0]
   \   0000068C   0x2902             CMPNE    R1,#+2
   1146                        {
   1147                          State = STOP;               
   1148                        }
   1149                          else if (State== START)
   \   0000068E   0xF000 0x80F5      BEQ.W    ??KEYS_process_7
   1150                          {
   1151                            State = STOP; 
   1152                          }
   1153                            else if(State == IDLE)
   \   00000692   0x7801             LDRB     R1,[R0, #+0]
   \   00000694   0x2900             CMP      R1,#+0
   \   00000696   0xF040 0x80F5      BNE.W    ??KEYS_process_1
   1154                            {
   1155                              State = INIT;
   \   0000069A   0xE0F1             B.N      ??KEYS_process_14
   1156                            }   
   1157                      break;
   1158                      default:
   1159                      break;
   1160                    }
   1161                  break;
   1162          
   1163          #ifdef OBSERVER_GAIN_TUNING
   1164                  case(K1_MENU):    
   1165                    switch(bKey)
   \                     ??KEYS_process_84:
   \   0000069C   0x2801             CMP      R0,#+1
   \   0000069E   0xD01F             BEQ.N    ??KEYS_process_85
   \   000006A0   0xF0C0 0x80F0      BCC.W    ??KEYS_process_1
   \   000006A4   0x2803             CMP      R0,#+3
   \   000006A6   0xD018             BEQ.N    ??KEYS_process_65
   \   000006A8   0xD370             BCC.N    ??KEYS_process_86
   \   000006AA   0x2805             CMP      R0,#+5
   \   000006AC   0xD00B             BEQ.N    ??KEYS_process_87
   \   000006AE   0xF080 0x80E9      BCS.W    ??KEYS_process_1
   1166                    {
   1167                      case UP:
   1168                        if (wK1_LO <= -K1_INC_DEC)
   \   000006B2   0x....             LDR.N    R0,??DataTable3_18
   \   000006B4   0x6801             LDR      R1,[R0, #+0]
   \   000006B6   0xF111 0x0FF9      CMN      R1,#+249
   \   000006BA   0xF280 0x80E3      BGE.W    ??KEYS_process_1
   1169                        {
   1170                          wK1_LO += K1_INC_DEC;
   \   000006BE   0x6801             LDR      R1,[R0, #+0]
   \   000006C0   0x31FA             ADDS     R1,R1,#+250
   \   000006C2   0x6001             STR      R1,[R0, #+0]
   \   000006C4   0xBD01             POP      {R0,PC}
   1171                        }
   1172                      break;  
   1173                       
   1174                      case DOWN:
   1175                        if (wK1_LO >= -600000)
   \                     ??KEYS_process_87:
   \   000006C6   0x....             LDR.N    R0,??DataTable3_18
   \   000006C8   0x6801             LDR      R1,[R0, #+0]
   \   000006CA   0x....             LDR.N    R2,??DataTable3_19  ;; 0xfff6d840
   \   000006CC   0x4291             CMP      R1,R2
   \   000006CE   0xF2C0 0x80D9      BLT.W    ??KEYS_process_1
   1176                        {
   1177                          wK1_LO -= K1_INC_DEC;
   \   000006D2   0x6801             LDR      R1,[R0, #+0]
   \   000006D4   0x39FA             SUBS     R1,R1,#+250
   \   000006D6   0x6001             STR      R1,[R0, #+0]
   \   000006D8   0xBD01             POP      {R0,PC}
   1178                        }
   1179                      break;
   1180                     
   1181                      case RIGHT:
   1182                        bMenu_index = K2_MENU;
   1183                      break;
   1184                       
   1185                      case LEFT:         
   1186                       bMenu_index = POWER_STAGE_MENU;
   \                     ??KEYS_process_65:
   \   000006DA   0x200B             MOVS     R0,#+11
   \   000006DC   0x7048             STRB     R0,[R1, #+1]
   \   000006DE   0xBD01             POP      {R0,PC}
   1187                      break;
   1188                      
   1189                      case SEL:
   1190                        if (State == RUN)
   \                     ??KEYS_process_85:
   \   000006E0   0x....             LDR.N    R0,??DataTable3_6
   \   000006E2   0x7801             LDRB     R1,[R0, #+0]
   \   000006E4   0x2903             CMP      R1,#+3
   \   000006E6   0xBF1C             ITT      NE 
   \   000006E8   0x7801             LDRBNE   R1,[R0, #+0]
   \   000006EA   0x2902             CMPNE    R1,#+2
   1191                        {
   1192                          State = STOP;               
   1193                        }
   1194                          else if (State== START)
   \   000006EC   0xF000 0x80C6      BEQ.W    ??KEYS_process_7
   1195                          {
   1196                            State = STOP; 
   1197                          }
   1198                            else if(State == IDLE)
   \   000006F0   0x7801             LDRB     R1,[R0, #+0]
   \   000006F2   0x2900             CMP      R1,#+0
   \   000006F4   0xF040 0x80C6      BNE.W    ??KEYS_process_1
   1199                            {
   1200                              State = INIT;
   \   000006F8   0xE0C2             B.N      ??KEYS_process_14
   1201                            }   
   1202                      break;
   1203                    default:
   1204                      break;
   1205                    }
   1206                    break;
   1207                  
   1208                  case(K2_MENU):    
   1209                    switch(bKey)
   \                     ??KEYS_process_88:
   \   000006FA   0x2801             CMP      R0,#+1
   \   000006FC   0xD023             BEQ.N    ??KEYS_process_89
   \   000006FE   0xF0C0 0x80C1      BCC.W    ??KEYS_process_1
   \   00000702   0x2803             CMP      R0,#+3
   \   00000704   0xD01C             BEQ.N    ??KEYS_process_69
   \   00000706   0xD369             BCC.N    ??KEYS_process_90
   \   00000708   0x2805             CMP      R0,#+5
   \   0000070A   0xD00D             BEQ.N    ??KEYS_process_91
   \   0000070C   0xF080 0x80BA      BCS.W    ??KEYS_process_1
   1210                    {
   1211                      case UP:
   1212                        if (wK2_LO <= S16_MAX * 100 - K2_INC_DEC)
   \   00000710   0x....             LDR.N    R0,??DataTable3_20
   \   00000712   0x6801             LDR      R1,[R0, #+0]
   \   00000714   0x....             LDR.N    R2,??DataTable3_21  ;; 0x31ec15
   \   00000716   0x4291             CMP      R1,R2
   \   00000718   0xF280 0x80B4      BGE.W    ??KEYS_process_1
   1213                        {
   1214                          wK2_LO += K2_INC_DEC;
   \   0000071C   0x6801             LDR      R1,[R0, #+0]
   \   0000071E   0xF501 0x5198      ADD      R1,R1,#+4864
   \   00000722   0x3188             ADDS     R1,R1,#+136
   \   00000724   0x6001             STR      R1,[R0, #+0]
   \   00000726   0xBD01             POP      {R0,PC}
   1215                        }
   1216                      break;  
   1217                       
   1218                      case DOWN:
   1219                       if (wK2_LO >= K2_INC_DEC)
   \                     ??KEYS_process_91:
   \   00000728   0x....             LDR.N    R0,??DataTable3_20
   \   0000072A   0x6801             LDR      R1,[R0, #+0]
   \   0000072C   0xF241 0x3288      MOVW     R2,#+5000
   \   00000730   0x4291             CMP      R1,R2
   \   00000732   0xF2C0 0x80A7      BLT.W    ??KEYS_process_1
   1220                        {
   1221                          wK2_LO -= K2_INC_DEC;
   \   00000736   0x6801             LDR      R1,[R0, #+0]
   \   00000738   0x....             LDR.N    R2,??DataTable3_22  ;; 0xffffec78
   \   0000073A   0x1851             ADDS     R1,R2,R1
   \   0000073C   0x6001             STR      R1,[R0, #+0]
   \   0000073E   0xBD01             POP      {R0,PC}
   1222                        }
   1223                      break;
   1224                     
   1225                      case RIGHT:
   1226                        bMenu_index = P_PLL_MENU;
   1227                      break;
   1228                       
   1229                      case LEFT:         
   1230                       bMenu_index = K1_MENU;
   \                     ??KEYS_process_69:
   \   00000740   0x2011             MOVS     R0,#+17
   \   00000742   0x7048             STRB     R0,[R1, #+1]
   \   00000744   0xBD01             POP      {R0,PC}
   1231                      break;
   1232                      
   1233                      case SEL:
   1234                        if (State == RUN)
   \                     ??KEYS_process_89:
   \   00000746   0x....             LDR.N    R0,??DataTable3_6
   \   00000748   0x7801             LDRB     R1,[R0, #+0]
   \   0000074A   0x2903             CMP      R1,#+3
   \   0000074C   0xBF1C             ITT      NE 
   \   0000074E   0x7801             LDRBNE   R1,[R0, #+0]
   \   00000750   0x2902             CMPNE    R1,#+2
   1235                        {
   1236                          State = STOP;               
   1237                        }
   1238                          else if (State== START)
   \   00000752   0xF000 0x8093      BEQ.W    ??KEYS_process_7
   1239                          {
   1240                            State = STOP; 
   1241                          }
   1242                            else if(State == IDLE)
   \   00000756   0x7801             LDRB     R1,[R0, #+0]
   \   00000758   0x2900             CMP      R1,#+0
   \   0000075A   0xF040 0x8093      BNE.W    ??KEYS_process_1
   1243                            {
   1244                              State = INIT;
   \   0000075E   0xE08F             B.N      ??KEYS_process_14
   1245                            }   
   1246                      break;
   1247                    default:
   1248                      break;
   1249                    }
   1250                    break;
   1251                    
   1252                   case(P_PLL_MENU):    
   1253                    switch(bKey)
   \                     ??KEYS_process_92:
   \   00000760   0x2801             CMP      R0,#+1
   \   00000762   0xD016             BEQ.N    ??KEYS_process_93
   \   00000764   0xF0C0 0x808E      BCC.W    ??KEYS_process_1
   \   00000768   0x2803             CMP      R0,#+3
   \   0000076A   0xD00F             BEQ.N    ??KEYS_process_86
   \   0000076C   0xD352             BCC.N    ??KEYS_process_94
   \   0000076E   0x2805             CMP      R0,#+5
   \   00000770   0xD00A             BEQ.N    ??KEYS_process_95
   \   00000772   0xF080 0x8087      BCS.W    ??KEYS_process_1
   1254                    {
   1255                      case UP:
   1256                       if (hPLL_P_Gain <= 32000)
   \   00000776   0x....             LDR.N    R0,??DataTable3_23
   \   00000778   0xF9B0 0x1000      LDRSH    R1,[R0, #+0]
   \   0000077C   0xF647 0x5201      MOVW     R2,#+32001
   \   00000780   0x4291             CMP      R1,R2
   \   00000782   0xF280 0x807F      BGE.W    ??KEYS_process_1
   1257                        {
   1258                          hPLL_P_Gain += PLL_IN_DEC;
   \   00000786   0x....             B.N      ?Subroutine0
   1259                        } 
   1260                      break;  
   1261                       
   1262                      case DOWN:
   1263                       if (hPLL_P_Gain > 0)
   \                     ??KEYS_process_95:
   \   00000788   0x....             LDR.N    R0,??DataTable3_23
   \   0000078A   0xE01F             B.N      ??KEYS_process_96
   1264                        {
   1265                          hPLL_P_Gain -= PLL_IN_DEC;
   1266                        } 
   1267                      break;
   1268                     
   1269                      case RIGHT:
   1270                        bMenu_index = I_PLL_MENU;
   1271                      break;
   1272                       
   1273                      case LEFT:         
   1274                       bMenu_index = K2_MENU;
   \                     ??KEYS_process_86:
   \   0000078C   0x2012             MOVS     R0,#+18
   \   0000078E   0x7048             STRB     R0,[R1, #+1]
   \   00000790   0xBD01             POP      {R0,PC}
   1275                      break;
   1276                      
   1277                      case SEL:
   1278                        if (State == RUN)
   \                     ??KEYS_process_93:
   \   00000792   0x....             LDR.N    R0,??DataTable3_6
   \   00000794   0x7801             LDRB     R1,[R0, #+0]
   \   00000796   0x2903             CMP      R1,#+3
   \   00000798   0xBF1C             ITT      NE 
   \   0000079A   0x7801             LDRBNE   R1,[R0, #+0]
   \   0000079C   0x2902             CMPNE    R1,#+2
   1279                        {
   1280                          State = STOP;               
   1281                        }
   1282                          else if (State== START)
   \   0000079E   0xD06D             BEQ.N    ??KEYS_process_7
   1283                          {
   1284                            State = STOP; 
   1285                          }
   1286                            else if(State == IDLE)
   \   000007A0   0x7801             LDRB     R1,[R0, #+0]
   \   000007A2   0x2900             CMP      R1,#+0
   \   000007A4   0xD16E             BNE.N    ??KEYS_process_1
   1287                            {
   1288                              State = INIT;
   \   000007A6   0xE06B             B.N      ??KEYS_process_14
   1289                            }   
   1290                      break;
   1291                    default:
   1292                      break;
   1293                    }
   1294                    break;
   1295                    
   1296                  case(I_PLL_MENU):    
   1297                    switch(bKey)
   \                     ??KEYS_process_97:
   \   000007A8   0x2801             CMP      R0,#+1
   \   000007AA   0xD01A             BEQ.N    ??KEYS_process_98
   \   000007AC   0xD36A             BCC.N    ??KEYS_process_1
   \   000007AE   0x2803             CMP      R0,#+3
   \   000007B0   0xD014             BEQ.N    ??KEYS_process_90
   \   000007B2   0xD35A             BCC.N    ??KEYS_process_99
   \   000007B4   0x2805             CMP      R0,#+5
   \   000007B6   0xD008             BEQ.N    ??KEYS_process_100
   \   000007B8   0xD264             BCS.N    ??KEYS_process_1
   1298                    {
   1299                      case UP:
   1300                       if (hPLL_I_Gain <= 32000)
   \   000007BA   0x....             LDR.N    R0,??DataTable3_24
   \   000007BC   0xF9B0 0x1000      LDRSH    R1,[R0, #+0]
   \   000007C0   0xF647 0x5201      MOVW     R2,#+32001
   \   000007C4   0x4291             CMP      R1,R2
   \   000007C6   0xDA5D             BGE.N    ??KEYS_process_1
   1301                        {
   1302                          hPLL_I_Gain += PLL_IN_DEC;
   \   000007C8   0x....             B.N      ?Subroutine0
   1303                        } 
   1304                      break;  
   1305                       
   1306                      case DOWN:
   1307                       if (hPLL_I_Gain > 0)
   \                     ??KEYS_process_100:
   \   000007CA   0x....             LDR.N    R0,??DataTable3_24
   \                     ??KEYS_process_96:
   \   000007CC   0xF9B0 0x1000      LDRSH    R1,[R0, #+0]
   \   000007D0   0x2901             CMP      R1,#+1
   \   000007D2   0xDB57             BLT.N    ??KEYS_process_1
   1308                        {
   1309                          hPLL_I_Gain -= PLL_IN_DEC;
   \   000007D4   0x8801             LDRH     R1,[R0, #+0]
   \   000007D6   0x3919             SUBS     R1,R1,#+25
   \   000007D8   0x8001             STRH     R1,[R0, #+0]
   \   000007DA   0xBD01             POP      {R0,PC}
   1310                        } 
   1311                      break;
   1312                     
   1313                      case RIGHT:
   1314          #ifdef DAC_FUNCTIONALITY
   1315                        bMenu_index = DAC_PB0_MENU;  
   1316          #else
   1317                        if ((wGlobal_Flags & SPEED_CONTROL == SPEED_CONTROL))
   1318                        {
   1319                          if (State == IDLE)
   1320                          {
   1321                            bMenu_index = CONTROL_MODE_MENU_1;
   1322                          }
   1323                          else
   1324                          {
   1325                            bMenu_index = REF_SPEED_MENU;
   1326                          }
   1327                        }
   1328                        else //Torque control
   1329                        {
   1330                          if (State == IDLE)
   1331                          {
   1332                            bMenu_index = CONTROL_MODE_MENU_6;
   1333                          }
   1334                          else
   1335                          {
   1336                            bMenu_index = IQ_REF_MENU;
   1337                          }
   1338                        }
   1339          #endif              
   1340                      break;
   1341                       
   1342                      case LEFT:         
   1343                        bMenu_index = P_PLL_MENU;
   \                     ??KEYS_process_90:
   \   000007DC   0x2013             MOVS     R0,#+19
   \   000007DE   0x7048             STRB     R0,[R1, #+1]
   \   000007E0   0xBD01             POP      {R0,PC}
   1344                      break;
   1345                      
   1346                      case SEL:
   1347                        if (State == RUN)
   \                     ??KEYS_process_98:
   \   000007E2   0x....             LDR.N    R0,??DataTable3_6
   \   000007E4   0x7801             LDRB     R1,[R0, #+0]
   \   000007E6   0x2903             CMP      R1,#+3
   \   000007E8   0xBF1C             ITT      NE 
   \   000007EA   0x7801             LDRBNE   R1,[R0, #+0]
   \   000007EC   0x2902             CMPNE    R1,#+2
   1348                        {
   1349                          State = STOP;               
   1350                        }
   1351                          else if (State== START)
   \   000007EE   0xD045             BEQ.N    ??KEYS_process_7
   1352                          {
   1353                            State = STOP; 
   1354                          }
   1355                            else if(State == IDLE)
   \   000007F0   0x7801             LDRB     R1,[R0, #+0]
   \   000007F2   0x2900             CMP      R1,#+0
   \   000007F4   0xD146             BNE.N    ??KEYS_process_1
   1356                            {
   1357                              State = INIT;
   \   000007F6   0xE043             B.N      ??KEYS_process_14
   1358                            }   
   1359                      break;
   1360                    default:
   1361                      break;
   1362                    }
   1363                    break;          
   1364          #endif
   1365            
   1366          #ifdef DAC_FUNCTIONALITY  
   1367                  case(DAC_PB0_MENU):    
   1368                    switch(bKey)
   \                     ??KEYS_process_101:
   \   000007F8   0x2801             CMP      R0,#+1
   \   000007FA   0xD00E             BEQ.N    ??KEYS_process_102
   \   000007FC   0xD342             BCC.N    ??KEYS_process_1
   \   000007FE   0x2803             CMP      R0,#+3
   \   00000800   0xD008             BEQ.N    ??KEYS_process_94
   \   00000802   0xD306             BCC.N    ??KEYS_process_103
   \   00000804   0x2805             CMP      R0,#+5
   \   00000806   0xD002             BEQ.N    ??KEYS_process_104
   \   00000808   0xD23C             BCS.N    ??KEYS_process_1
   1369                    {
   1370                      case UP:
   1371                        MCDAC_Output_Choice(1,DAC_CH1);
   \   0000080A   0x2101             MOVS     R1,#+1
   \   0000080C   0x....             B.N      ?Subroutine10
   1372                      break;
   1373                      
   1374                      case DOWN:
   1375                        MCDAC_Output_Choice(-1,DAC_CH1);
   \                     ??KEYS_process_104:
   \   0000080E   0x2101             MOVS     R1,#+1
   \   00000810   0xE016             B.N      ??KEYS_process_105
   1376                      break;  
   1377                     
   1378                      case RIGHT:                
   1379                          bMenu_index = DAC_PB1_MENU;               
   \                     ??KEYS_process_103:
   \   00000812   0x....             B.N      ?Subroutine3
   1380                      break;
   1381                      
   1382                      case LEFT:
   1383          #ifdef OBSERVER_GAIN_TUNING              
   1384                        bMenu_index = I_PLL_MENU;
   \                     ??KEYS_process_94:
   \   00000814   0x2014             MOVS     R0,#+20
   \   00000816   0x7048             STRB     R0,[R1, #+1]
   \   00000818   0xBD01             POP      {R0,PC}
   1385          #else
   1386                        bMenu_index = POWER_STAGE_MENU;
   1387          #endif              
   1388                      break;
   1389                      
   1390                      case SEL:
   1391                        switch(State)
   \                     ??KEYS_process_102:
   \   0000081A   0x....             LDR.N    R0,??DataTable3_6
   \   0000081C   0x7801             LDRB     R1,[R0, #+0]
   \   0000081E   0xB379             CBZ.N    R1,??KEYS_process_14
   \   00000820   0x1E89             SUBS     R1,R1,#+2
   \   00000822   0x2901             CMP      R1,#+1
   \   00000824   0xD92A             BLS.N    ??KEYS_process_7
   \   00000826   0xBD01             POP      {R0,PC}
   1392                        {
   1393                        case RUN:
   1394                          State = STOP;
   1395                          break;
   1396                        case START:
   1397                          State = STOP;
   1398                          break;
   1399                        case IDLE:
   1400                          State = INIT;
   1401                          break;
   1402                        default:
   1403                          break;                
   1404                        }   
   1405                      break;
   1406                    default:
   1407                      break;
   1408                    }
   1409                  break;   
   1410          
   1411                  case(DAC_PB1_MENU):    
   1412                    switch(bKey)
   \                     ??KEYS_process_106:
   \   00000828   0x2801             CMP      R0,#+1
   \   0000082A   0xD021             BEQ.N    ??KEYS_process_107
   \   0000082C   0xD32A             BCC.N    ??KEYS_process_1
   \   0000082E   0x2803             CMP      R0,#+3
   \   00000830   0xD01B             BEQ.N    ??KEYS_process_99
   \   00000832   0xD308             BCC.N    ??KEYS_process_108
   \   00000834   0x2805             CMP      R0,#+5
   \   00000836   0xD002             BEQ.N    ??KEYS_process_109
   \   00000838   0xD224             BCS.N    ??KEYS_process_1
   1413                    {
   1414                      case UP:
   1415                        MCDAC_Output_Choice(1,DAC_CH2);
   \   0000083A   0x2102             MOVS     R1,#+2
   \   0000083C   0x....             B.N      ?Subroutine10
   1416                      break;
   1417                      
   1418                      case DOWN:
   1419                        MCDAC_Output_Choice(-1,DAC_CH2);
   \                     ??KEYS_process_109:
   \   0000083E   0x2102             MOVS     R1,#+2
   \                     ??KEYS_process_105:
   \   00000840   0xF04F 0x30FF      MOV      R0,#-1
   \   00000844   0x....             B.N      ??Subroutine10_0
   1420                      break;  
   1421                     
   1422                      case RIGHT:                
   1423                      if ((wGlobal_Flags & SPEED_CONTROL == SPEED_CONTROL))
   \                     ??KEYS_process_108:
   \   00000846   0x....             LDR.N    R0,??DataTable3_6
   \   00000848   0x....             LDR.N    R2,??DataTable3_5
   \   0000084A   0x6812             LDR      R2,[R2, #+0]
   \   0000084C   0x07D2             LSLS     R2,R2,#+31
   \   0000084E   0x7800             LDRB     R0,[R0, #+0]
   \   00000850   0xD505             BPL.N    ??KEYS_process_110
   1424                        {
   1425                          if (State == IDLE)
   \   00000852   0x1E42             SUBS     R2,R0,#+1
   \   00000854   0x4192             SBCS     R2,R2,R2
   \   00000856   0x43D2             MVNS     R2,R2
   \   00000858   0x0FD2             LSRS     R2,R2,#+31
   \   0000085A   0x704A             STRB     R2,[R1, #+1]
   \   0000085C   0xBD01             POP      {R0,PC}
   1426                          {
   1427                            bMenu_index = CONTROL_MODE_MENU_1;
   1428                          }
   1429                          else
   1430                          {
   1431                            bMenu_index = REF_SPEED_MENU;
   1432                          }
   1433                        }
   1434                        else //Torque control
   1435                        {
   1436                          if (State == IDLE)
   \                     ??KEYS_process_110:
   \   0000085E   0x2800             CMP      R0,#+0
   \   00000860   0xBF14             ITE      NE 
   \   00000862   0x200D             MOVNE    R0,#+13
   \   00000864   0x200C             MOVEQ    R0,#+12
   1437                          {
   1438                            bMenu_index = CONTROL_MODE_MENU_6;
   \   00000866   0x7048             STRB     R0,[R1, #+1]
   \   00000868   0xBD01             POP      {R0,PC}
   1439                          }
   1440                          else
   1441                          {
   1442                            bMenu_index = IQ_REF_MENU;
   1443                          }
   1444                        }               
   1445                      break;
   1446                      
   1447                      case LEFT:             
   1448                        bMenu_index = DAC_PB0_MENU;
   \                     ??KEYS_process_99:
   \   0000086A   0x2015             MOVS     R0,#+21
   \                     ??KEYS_process_13:
   \   0000086C   0x7048             STRB     R0,[R1, #+1]
   1449                      break;
   \   0000086E   0xBD01             POP      {R0,PC}
   1450                      
   1451                      case SEL:
   1452                        switch(State)
   \                     ??KEYS_process_107:
   \   00000870   0x....             LDR.N    R0,??DataTable3_6
   \   00000872   0x7801             LDRB     R1,[R0, #+0]
   \   00000874   0xB121             CBZ.N    R1,??KEYS_process_14
   \   00000876   0x1E89             SUBS     R1,R1,#+2
   \   00000878   0x2901             CMP      R1,#+1
   \   0000087A   0xD803             BHI.N    ??KEYS_process_1
   1453                        {
   1454                        case RUN:
   1455                          State = STOP;
   1456                          break;
   1457                        case START:
   1458                          State = STOP;
   \                     ??KEYS_process_7:
   \   0000087C   0x2104             MOVS     R1,#+4
   \   0000087E   0xE000             B.N      ??KEYS_process_111
   1459                          break;
   1460                        case IDLE:
   1461                          State = INIT;
   \                     ??KEYS_process_14:
   \   00000880   0x2101             MOVS     R1,#+1
   \                     ??KEYS_process_111:
   \   00000882   0x7001             STRB     R1,[R0, #+0]
   1462                          break;
   1463                        default:
   1464                          break;                
   1465                        }      
   1466                      break;
   1467                    default:
   1468                      break;
   1469                    }
   1470                  break; 
   1471          #endif 
   1472              
   1473                default:
   1474                  break; 
   1475                }
   1476          }
   \                     ??KEYS_process_1:
   \   00000884   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine10:
   \   00000000   0x2001             MOVS     R0,#+1
   \                     ??Subroutine10_0:
   \   00000002   0xE8BD 0x4004      POP      {R2,LR}
   \   00000006   0x.... 0x....      B.W      MCDAC_Output_Choice

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine9:
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x7048             STRB     R0,[R1, #+1]
   \   00000004   0xBD01             POP      {R0,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine8:
   \   00000000   0x3119             ADDS     R1,R1,#+25
   \   00000002   0x8081             STRH     R1,[R0, #+4]
   \   00000004   0xBD01             POP      {R0,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine7:
   \   00000000   0x3164             ADDS     R1,R1,#+100
   \   00000002   0x8301             STRH     R1,[R0, #+24]
   \   00000004   0xBD01             POP      {R0,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6:
   \   00000000   0x310A             ADDS     R1,R1,#+10
   \   00000002   0x8001             STRH     R1,[R0, #+0]
   \   00000004   0xBD01             POP      {R0,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5:
   \   00000000   0x390A             SUBS     R1,R1,#+10
   \   00000002   0x8001             STRH     R1,[R0, #+0]
   \   00000004   0xBD01             POP      {R0,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4:
   \   00000000   0x200D             MOVS     R0,#+13
   \   00000002   0x7048             STRB     R0,[R1, #+1]
   \   00000004   0xBD01             POP      {R0,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3:
   \   00000000   0x2016             MOVS     R0,#+22
   \   00000002   0x7048             STRB     R0,[R1, #+1]
   \   00000004   0xBD01             POP      {R0,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2:
   \   00000000   0x8801             LDRH     R1,[R0, #+0]
   \                     ??Subroutine2_0:
   \   00000002   0x31FA             ADDS     R1,R1,#+250
   \   00000004   0x8001             STRH     R1,[R0, #+0]
   \   00000006   0xBD01             POP      {R0,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1:
   \   00000000   0x8801             LDRH     R1,[R0, #+0]
   \                     ??Subroutine1_0:
   \   00000002   0x39FA             SUBS     R1,R1,#+250
   \   00000004   0x8001             STRH     R1,[R0, #+0]
   \   00000006   0xBD01             POP      {R0,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0:
   \   00000000   0x8801             LDRH     R1,[R0, #+0]
   \   00000002   0x3119             ADDS     R1,R1,#+25
   \   00000004   0x8001             STRH     R1,[R0, #+0]
   \   00000006   0xBD01             POP      {R0,PC}
   1477          
   1478          /*******************************************************************************
   1479          * Function Name  : KEYS_ExportbKey
   1480          * Description    : Export bKey variable
   1481          * Input          : None
   1482          * Output         : None
   1483          * Return         : None
   1484          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1485          u8 KEYS_ExportbKey(void)
   1486          {
   1487            return(bKey);
   \                     KEYS_ExportbKey:
   \   00000000   0x....             LDR.N    R0,??DataTable3_4
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
   1488          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x40011400         DC32     0x40011400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x40011800         DC32     0x40011800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x40010C00         DC32     0x40010c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   0x........         DC32     bPrevious_key

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \   00000000   0x........         DC32     bKey

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_5:
   \   00000000   0x........         DC32     wGlobal_Flags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_6:
   \   00000000   0x........         DC32     State

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_7:
   \   00000000   0x........         DC32     hSpeed_Reference

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_8:
   \   00000000   0xFFFFFDA8         DC32     0xfffffda8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_9:
   \   00000000   0x........         DC32     PID_Speed_InitStructure

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_10:
   \   00000000   0x........         DC32     PID_Torque_InitStructure

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_11:
   \   00000000   0x........         DC32     PID_Flux_InitStructure

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_12:
   \   00000000   0x........         DC32     hFW_P_Gain

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_13:
   \   00000000   0x........         DC32     hFW_I_Gain

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_14:
   \   00000000   0x........         DC32     hFW_V_Ref

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_15:
   \   00000000   0x........         DC32     hTorque_Reference

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_16:
   \   00000000   0xFFFFA44B         DC32     0xffffa44b

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_17:
   \   00000000   0x........         DC32     hFlux_Reference

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_18:
   \   00000000   0x........         DC32     wK1_LO

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_19:
   \   00000000   0xFFF6D840         DC32     0xfff6d840

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_20:
   \   00000000   0x........         DC32     wK2_LO

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_21:
   \   00000000   0x0031EC15         DC32     0x31ec15

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_22:
   \   00000000   0xFFFFEC78         DC32     0xffffec78

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_23:
   \   00000000   0x........         DC32     hPLL_P_Gain

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_24:
   \   00000000   0x........         DC32     hPLL_I_Gain
   1489                             
   1490          /******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
   1491          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        0  KEYS_ExportbKey
       16  KEYS_Init
             16 -> GPIO_Init
             16 -> GPIO_StructInit
             16 -> RCC_APB2PeriphClockCmd
       16  KEYS_Read
             16 -> GPIO_ReadInputDataBit
             16 -> TB_DebounceDelay_IsElapsed
             16 -> TB_Set_DebounceDelay_500us
        8  KEYS_process
              8 -> KEYS_Read
              0 -> MCDAC_Output_Choice


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_10
       4  ??DataTable3_11
       4  ??DataTable3_12
       4  ??DataTable3_13
       4  ??DataTable3_14
       4  ??DataTable3_15
       4  ??DataTable3_16
       4  ??DataTable3_17
       4  ??DataTable3_18
       4  ??DataTable3_19
       4  ??DataTable3_2
       4  ??DataTable3_20
       4  ??DataTable3_21
       4  ??DataTable3_22
       4  ??DataTable3_23
       4  ??DataTable3_24
       4  ??DataTable3_3
       4  ??DataTable3_4
       4  ??DataTable3_5
       4  ??DataTable3_6
       4  ??DataTable3_7
       4  ??DataTable3_8
       4  ??DataTable3_9
       8  ?Subroutine0
       8  ?Subroutine1
      10  ?Subroutine10
       8  ?Subroutine2
       6  ?Subroutine3
       6  ?Subroutine4
       6  ?Subroutine5
       6  ?Subroutine6
       6  ?Subroutine7
       6  ?Subroutine8
       6  ?Subroutine9
       6  KEYS_ExportbKey
     156  KEYS_Init
     264  KEYS_Read
    2182  KEYS_process
       2  bKey
          bMenu_index
       2  bPrevious_key
          bKey_Flag

 
     4 bytes in section .bss
 2 784 bytes in section .text
 
 2 784 bytes of CODE memory
     4 bytes of DATA memory

Errors: none
Warnings: 4
