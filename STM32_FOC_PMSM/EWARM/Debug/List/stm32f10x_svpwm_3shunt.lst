###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     04/Nov/2013  13:20:04 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\st\stm32 foc firwmare libraries                       #
#                    v2.0\STM32_FOC_PMSM\src\stm32f10x_svpwm_3shunt.c         #
#    Command line =  "D:\st\stm32 foc firwmare libraries                      #
#                    v2.0\STM32_FOC_PMSM\src\stm32f10x_svpwm_3shunt.c" -D     #
#                    VECT_TAB_FLASH -lCN "D:\st\stm32 foc firwmare libraries  #
#                    v2.0\STM32_FOC_PMSM\EWARM\Debug\List\" --diag_error      #
#                    Pe068,Pe069 -o "D:\st\stm32 foc firwmare libraries       #
#                    v2.0\STM32_FOC_PMSM\EWARM\Debug\Obj\" --debug            #
#                    --endian=little --cpu=Cortex-M3 --fpu=None               #
#                    --dlib_config D:\IAR\arm\INC\c\DLib_Config_Normal.h -I   #
#                    "D:\st\stm32 foc firwmare libraries                      #
#                    v2.0\STM32_FOC_PMSM\EWARM\..\" -I "D:\st\stm32 foc       #
#                    firwmare libraries v2.0\STM32_FOC_PMSM\EWARM\..\..\STM32 #
#                    F10XFWLIB\inc\" -I "D:\st\stm32 foc firwmare libraries   #
#                    v2.0\STM32_FOC_PMSM\EWARM\..\inc\" -Ohs                  #
#                    --use_c++_inline --require_prototypes                    #
#    List file    =  D:\st\stm32 foc firwmare libraries                       #
#                    v2.0\STM32_FOC_PMSM\EWARM\Debug\List\stm32f10x_svpwm_3sh #
#                    unt.lst                                                  #
#    Object file  =  D:\st\stm32 foc firwmare libraries                       #
#                    v2.0\STM32_FOC_PMSM\EWARM\Debug\Obj\stm32f10x_svpwm_3shu #
#                    nt.o                                                     #
#                                                                             #
#                                                                             #
###############################################################################

D:\st\stm32 foc firwmare libraries v2.0\STM32_FOC_PMSM\src\stm32f10x_svpwm_3shunt.c
      1          /******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
      2          * File Name          : STM32x_svpwm_3shunt.c
      3          * Author             : IMS Systems Lab
      4          * Date First Issued  : 28/11/07
      5          * Description        : 3 shunt resistors current reading module
      6          ********************************************************************************
      7          * History:
      8          * 28/11/07 v1.0
      9          * 29/05/08 v2.0
     10          * 03/07/08 v2.0.1
     11          * 09/07/08 v2.0.2
     12          * 11/07/08 v2.0.3
     13          ********************************************************************************
     14          * THE PRESENT SOFTWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     15          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
     16          * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
     17          * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
     18          * CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
     19          * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     20          *
     21          * THIS SOURCE CODE IS PROTECTED BY A LICENSE.
     22          * FOR MORE INFORMATION PLEASE CAREFULLY READ THE LICENSE AGREEMENT FILE LOCATED
     23          * IN THE ROOT DIRECTORY OF THIS FIRMWARE PACKAGE.
     24          *******************************************************************************/
     25          
     26          #include "STM32F10x_MCconf.h"
     27          
     28          #ifdef THREE_SHUNT
     29          
     30          /* Includes-------------------------------------------------------------------*/
     31          #include "stm32f10x_lib.h"
     32          #include "stm32f10x_svpwm_3shunt.h"
     33          #include "MC_Globals.h"
     34          
     35          /* Private typedef -----------------------------------------------------------*/
     36          /* Private define ------------------------------------------------------------*/
     37          
     38          #define NB_CONVERSIONS 16
     39          
     40          #define SQRT_3		1.732051
     41          #define T		    (PWM_PERIOD * 4)
     42          #define T_SQRT3     (u16)(T * SQRT_3)
     43          
     44          #define SECTOR_1	(u32)1
     45          #define SECTOR_2	(u32)2
     46          #define SECTOR_3	(u32)3
     47          #define SECTOR_4	(u32)4
     48          #define SECTOR_5	(u32)5
     49          #define SECTOR_6	(u32)6
     50          
     51          #define PHASE_A_ADC_CHANNEL     ADC_Channel_11
     52          #define PHASE_B_ADC_CHANNEL     ADC_Channel_12
     53          #define PHASE_C_ADC_CHANNEL     ADC_Channel_13
     54          
     55          // Setting for sampling of VBUS and Temp after currents sampling
     56          #define PHASE_A_MSK       (u32)((u32)(PHASE_A_ADC_CHANNEL) << 10)
     57          #define PHASE_B_MSK       (u32)((u32)(PHASE_B_ADC_CHANNEL) << 10)
     58          #define PHASE_C_MSK       (u32)((u32)(PHASE_C_ADC_CHANNEL) << 10)
     59          
     60          // Settings for current sampling only
     61          /*#define PHASE_A_MSK       (u32)((u32)(PHASE_A_ADC_CHANNEL) << 15)
     62          #define PHASE_B_MSK       (u32)((u32)(PHASE_B_ADC_CHANNEL) << 15)
     63          #define PHASE_C_MSK       (u32)((u32)(PHASE_C_ADC_CHANNEL) << 15)*/
     64          
     65          // Setting for sampling of VBUS and Temp after currents sampling
     66          #define TEMP_FDBK_MSK     (u32)((u32)(TEMP_FDBK_CHANNEL) <<15)
     67          #define BUS_VOLT_FDBK_MSK (u32)((u32)(BUS_VOLT_FDBK_CHANNEL) <<15)
     68          
     69          // Settings for current sampling only
     70          //#define TEMP_FDBK_MSK     (u32)(0)
     71          //#define BUS_VOLT_FDBK_MSK (u32)(0)
     72          
     73          // Setting for sampling of VBUS and Temp after currents sampling
     74          #define SEQUENCE_LENGHT    0x00100000
     75          
     76          // Settings for current sampling only
     77          //#define SEQUENCE_LENGHT    0x00000000
     78          
     79          #define ADC_PRE_EMPTION_PRIORITY 1
     80          #define ADC_SUB_PRIORITY 0
     81          
     82          #define BRK_PRE_EMPTION_PRIORITY 0
     83          #define BRK_SUB_PRIORITY 0
     84          
     85          #define TIM1_UP_PRE_EMPTION_PRIORITY 1
     86          #define TIM1_UP_SUB_PRIORITY 0
     87          
     88          #define LOW_SIDE_POLARITY  TIM_OCIdleState_Reset
     89          
     90          #define PWM2_MODE 0
     91          #define PWM1_MODE 1
     92          
     93          /* Private macro -------------------------------------------------------------*/
     94          /* Private variables ---------------------------------------------------------*/
     95          u8  bSector;  
     96          
     97          u16 hPhaseAOffset;
     98          u16 hPhaseBOffset;
     99          u16 hPhaseCOffset;
    100          
    101          u8 PWM4Direction=PWM2_MODE;
    102          
    103          /* Private function prototypes -----------------------------------------------*/
    104          
    105          void SVPWM_InjectedConvConfig(void);
    106          
    107          /*******************************************************************************
    108          * Function Name  : SVPWM_3ShuntInit
    109          * Description    : It initializes PWM and ADC peripherals
    110          * Input          : None
    111          * Output         : None
    112          * Return         : None
    113          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    114          void SVPWM_3ShuntInit(void)
    115          { 
   \                     SVPWM_3ShuntInit:
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB093             SUB      SP,SP,#+76
    116            ADC_InitTypeDef ADC_InitStructure;
    117            TIM_TimeBaseInitTypeDef TIM1_TimeBaseStructure;
    118            TIM_OCInitTypeDef TIM1_OCInitStructure;
    119            TIM_BDTRInitTypeDef TIM1_BDTRInitStructure;
    120            NVIC_InitTypeDef NVIC_InitStructure;
    121            GPIO_InitTypeDef GPIO_InitStructure;
    122          
    123            /* ADC1, ADC2, DMA, GPIO, TIM1 clocks enabling -----------------------------*/
    124            
    125            /* ADCCLK = PCLK2/6 */
    126            RCC_ADCCLKConfig(RCC_PCLK2_Div6);
   \   00000004   0xF44F 0x4000      MOV      R0,#+32768
   \   00000008   0x.... 0x....      BL       RCC_ADCCLKConfig
    127          
    128            /* Enable DMA clock */
    129            RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x.... 0x....      BL       RCC_AHBPeriphClockCmd
    130            
    131            /* Enable GPIOA, GPIOC, GPIOE, AFIO clocks */
    132            RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO | RCC_APB2Periph_GPIOA |
    133                                   RCC_APB2Periph_GPIOC | RCC_APB2Periph_GPIOE, ENABLE);
   \   00000014   0x2101             MOVS     R1,#+1
   \   00000016   0x2055             MOVS     R0,#+85
   \   00000018   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    134            /* Enable ADC1 clock */
    135            RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);
   \   0000001C   0x2101             MOVS     R1,#+1
   \   0000001E   0xF44F 0x7000      MOV      R0,#+512
   \   00000022   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    136          
    137            /* Enable ADC2 clock */
    138            RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC2, ENABLE); 
   \   00000026   0x2101             MOVS     R1,#+1
   \   00000028   0xF44F 0x6080      MOV      R0,#+1024
   \   0000002C   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    139             
    140            /* Enable TIM1 clock */
    141            RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1, ENABLE);
   \   00000030   0x2101             MOVS     R1,#+1
   \   00000032   0xF44F 0x6000      MOV      R0,#+2048
   \   00000036   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    142               
    143            /* ADC1, ADC2, PWM pins configurations -------------------------------------*/
    144            GPIO_StructInit(&GPIO_InitStructure);
   \   0000003A   0xA800             ADD      R0,SP,#+0
   \   0000003C   0x.... 0x....      BL       GPIO_StructInit
    145            /****** Configure PC.00,01,2,3,4 (ADC Channels [10..14]) as analog input ****/
    146            GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 |GPIO_Pin_4;
   \   00000040   0x201F             MOVS     R0,#+31
   \   00000042   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    147            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0xF88D 0x0003      STRB     R0,[SP, #+3]
    148            GPIO_Init(GPIOC, &GPIO_InitStructure);
   \   0000004C   0xA900             ADD      R1,SP,#+0
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable6  ;; 0x40011000
   \   00000052   0x.... 0x....      BL       GPIO_Init
    149               
    150            GPIO_StructInit(&GPIO_InitStructure);
   \   00000056   0xA800             ADD      R0,SP,#+0
   \   00000058   0x.... 0x....      BL       GPIO_StructInit
    151            /****** Configure PA.03 (ADC Channels [3]) as analog input ******/
    152            GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;
   \   0000005C   0x2008             MOVS     R0,#+8
   \   0000005E   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    153            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0xF88D 0x0003      STRB     R0,[SP, #+3]
    154            GPIO_Init(GPIOA, &GPIO_InitStructure);
   \   00000068   0xA900             ADD      R1,SP,#+0
   \   0000006A   0x.... 0x....      LDR.W    R0,??DataTable6_1  ;; 0x40010800
   \   0000006E   0x.... 0x....      BL       GPIO_Init
    155          
    156            /* TIM1 Peripheral Configuration -------------------------------------------*/
    157            /* TIM1 Registers reset */
    158            TIM_DeInit(TIM1);
   \   00000072   0x.... 0x....      LDR.W    R5,??DataTable6_2  ;; 0x40012c00
   \   00000076   0x4628             MOV      R0,R5
   \   00000078   0x.... 0x....      BL       TIM_DeInit
    159            TIM_TimeBaseStructInit(&TIM1_TimeBaseStructure);
   \   0000007C   0xA80B             ADD      R0,SP,#+44
   \   0000007E   0x.... 0x....      BL       TIM_TimeBaseStructInit
    160            /* Time Base configuration */
    161            TIM1_TimeBaseStructure.TIM_Prescaler = 0x0;
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0xF8AD 0x002C      STRH     R0,[SP, #+44]
    162            TIM1_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_CenterAligned1;
   \   00000088   0x2020             MOVS     R0,#+32
   \   0000008A   0xF8AD 0x002E      STRH     R0,[SP, #+46]
    163            TIM1_TimeBaseStructure.TIM_Period = PWM_PERIOD;
   \   0000008E   0xF640 0x10C4      MOVW     R0,#+2500
   \   00000092   0xF8AD 0x0030      STRH     R0,[SP, #+48]
    164            TIM1_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV2;
   \   00000096   0xF44F 0x7680      MOV      R6,#+256
   \   0000009A   0xF8AD 0x6032      STRH     R6,[SP, #+50]
    165            
    166            // Initial condition is REP=0 to set the UPDATE only on the underflow
    167            TIM1_TimeBaseStructure.TIM_RepetitionCounter = REP_RATE;
   \   0000009E   0x2001             MOVS     R0,#+1
   \   000000A0   0xF88D 0x0034      STRB     R0,[SP, #+52]
    168            TIM_TimeBaseInit(TIM1, &TIM1_TimeBaseStructure);
   \   000000A4   0xA90B             ADD      R1,SP,#+44
   \   000000A6   0x4628             MOV      R0,R5
   \   000000A8   0x.... 0x....      BL       TIM_TimeBaseInit
    169            
    170            TIM_OCStructInit(&TIM1_OCInitStructure);
   \   000000AC   0xA802             ADD      R0,SP,#+8
   \   000000AE   0x.... 0x....      BL       TIM_OCStructInit
    171            /* Channel 1, 2,3 in PWM mode */
    172            TIM1_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1; 
   \   000000B2   0x2060             MOVS     R0,#+96
   \   000000B4   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    173            TIM1_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable; 
   \   000000B8   0x2001             MOVS     R0,#+1
   \   000000BA   0xF8AD 0x000A      STRH     R0,[SP, #+10]
    174            TIM1_OCInitStructure.TIM_OutputNState = TIM_OutputNState_Enable;                  
   \   000000BE   0x2004             MOVS     R0,#+4
   \   000000C0   0xF8AD 0x000C      STRH     R0,[SP, #+12]
    175            TIM1_OCInitStructure.TIM_Pulse = 0x505; //dummy value
   \   000000C4   0xF240 0x5005      MOVW     R0,#+1285
   \   000000C8   0xF8AD 0x000E      STRH     R0,[SP, #+14]
    176            TIM1_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High; 
   \   000000CC   0x2000             MOVS     R0,#+0
   \   000000CE   0x9004             STR      R0,[SP, #+16]
    177            TIM1_OCInitStructure.TIM_OCNPolarity = TIM_OCNPolarity_High;         
    178            TIM1_OCInitStructure.TIM_OCIdleState = TIM_OCIdleState_Reset;
   \   000000D0   0x9005             STR      R0,[SP, #+20]
    179            TIM1_OCInitStructure.TIM_OCNIdleState = LOW_SIDE_POLARITY;          
    180            
    181            TIM_OC1Init(TIM1, &TIM1_OCInitStructure); 
   \   000000D2   0xA902             ADD      R1,SP,#+8
   \   000000D4   0x4628             MOV      R0,R5
   \   000000D6   0x.... 0x....      BL       TIM_OC1Init
    182            TIM_OC2Init(TIM1, &TIM1_OCInitStructure);
   \   000000DA   0xA902             ADD      R1,SP,#+8
   \   000000DC   0x4628             MOV      R0,R5
   \   000000DE   0x.... 0x....      BL       TIM_OC2Init
    183            TIM_OC3Init(TIM1, &TIM1_OCInitStructure);
   \   000000E2   0xA902             ADD      R1,SP,#+8
   \   000000E4   0x4628             MOV      R0,R5
   \   000000E6   0x.... 0x....      BL       TIM_OC3Init
    184            
    185            /*Timer1 alternate function full remapping*/  
    186            GPIO_PinRemapConfig(GPIO_FullRemap_TIM1,ENABLE);  
   \   000000EA   0x2101             MOVS     R1,#+1
   \   000000EC   0x.... 0x....      LDR.W    R0,??DataTable6_3  ;; 0x1600c0
   \   000000F0   0x.... 0x....      BL       GPIO_PinRemapConfig
    187            
    188            GPIO_StructInit(&GPIO_InitStructure);
   \   000000F4   0xA800             ADD      R0,SP,#+0
   \   000000F6   0x.... 0x....      BL       GPIO_StructInit
    189            /* GPIOE Configuration: Channel 1, 1N, 2, 2N, 3, 3N and 4 Output */
    190            GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_10 | 
    191                                          GPIO_Pin_11 | GPIO_Pin_12 | GPIO_Pin_13 | GPIO_Pin_14;
   \   000000FA   0xF44F 0x40FE      MOV      R0,#+32512
   \   000000FE   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    192            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
   \   00000102   0x2018             MOVS     R0,#+24
   \   00000104   0xF88D 0x0003      STRB     R0,[SP, #+3]
    193            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000108   0x2003             MOVS     R0,#+3
   \   0000010A   0xF88D 0x0002      STRB     R0,[SP, #+2]
    194            GPIO_Init(GPIOE, &GPIO_InitStructure); 
   \   0000010E   0x.... 0x....      LDR.W    R4,??DataTable6_4  ;; 0x40011800
   \   00000112   0xA900             ADD      R1,SP,#+0
   \   00000114   0x4620             MOV      R0,R4
   \   00000116   0x.... 0x....      BL       GPIO_Init
    195            
    196            /* Lock GPIOE Pin9 and Pin11 Pin 13 (High sides) */
    197            GPIO_PinLockConfig(GPIOE, GPIO_Pin_9 | GPIO_Pin_11 | GPIO_Pin_13);
   \   0000011A   0xF44F 0x5128      MOV      R1,#+10752
   \   0000011E   0x4620             MOV      R0,R4
   \   00000120   0x.... 0x....      BL       GPIO_PinLockConfig
    198          
    199            GPIO_StructInit(&GPIO_InitStructure);
   \   00000124   0xA800             ADD      R0,SP,#+0
   \   00000126   0x.... 0x....      BL       GPIO_StructInit
    200            /* GPIOE Configuration: BKIN pin */   
    201            GPIO_InitStructure.GPIO_Pin = GPIO_Pin_15;
   \   0000012A   0xF44F 0x4000      MOV      R0,#+32768
   \   0000012E   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    202            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
   \   00000132   0x2004             MOVS     R0,#+4
   \   00000134   0xF88D 0x0003      STRB     R0,[SP, #+3]
    203            GPIO_Init(GPIOE, &GPIO_InitStructure);  
   \   00000138   0xA900             ADD      R1,SP,#+0
   \   0000013A   0x4620             MOV      R0,R4
   \   0000013C   0x.... 0x....      BL       GPIO_Init
    204            
    205            TIM_OCStructInit(&TIM1_OCInitStructure);
   \   00000140   0xA802             ADD      R0,SP,#+8
   \   00000142   0x.... 0x....      BL       TIM_OCStructInit
    206            /* Channel 4 Configuration in OC */
    207            TIM1_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM2;  
   \   00000146   0x2070             MOVS     R0,#+112
   \   00000148   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    208            TIM1_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable; 
   \   0000014C   0x2001             MOVS     R0,#+1
   \   0000014E   0xF8AD 0x000A      STRH     R0,[SP, #+10]
    209            TIM1_OCInitStructure.TIM_OutputNState = TIM_OutputNState_Disable;                  
   \   00000152   0x2000             MOVS     R0,#+0
   \   00000154   0xF8AD 0x000C      STRH     R0,[SP, #+12]
    210            TIM1_OCInitStructure.TIM_Pulse = PWM_PERIOD - 1; 
   \   00000158   0xF640 0x10C3      MOVW     R0,#+2499
   \   0000015C   0xF8AD 0x000E      STRH     R0,[SP, #+14]
    211            
    212            TIM1_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High; 
   \   00000160   0x2000             MOVS     R0,#+0
   \   00000162   0xF8AD 0x0010      STRH     R0,[SP, #+16]
    213            TIM1_OCInitStructure.TIM_OCNPolarity = TIM_OCNPolarity_Low;         
   \   00000166   0x2008             MOVS     R0,#+8
   \   00000168   0xF8AD 0x0012      STRH     R0,[SP, #+18]
    214            TIM1_OCInitStructure.TIM_OCIdleState = TIM_OCIdleState_Reset;
   \   0000016C   0x2000             MOVS     R0,#+0
   \   0000016E   0x9005             STR      R0,[SP, #+20]
    215            TIM1_OCInitStructure.TIM_OCNIdleState = LOW_SIDE_POLARITY;            
    216            
    217            TIM_OC4Init(TIM1, &TIM1_OCInitStructure);
   \   00000170   0xA902             ADD      R1,SP,#+8
   \   00000172   0x4628             MOV      R0,R5
   \   00000174   0x.... 0x....      BL       TIM_OC4Init
    218            
    219            /* Enables the TIM1 Preload on CC1 Register */
    220            TIM_OC1PreloadConfig(TIM1, TIM_OCPreload_Enable);
   \   00000178   0x2108             MOVS     R1,#+8
   \   0000017A   0x4628             MOV      R0,R5
   \   0000017C   0x.... 0x....      BL       TIM_OC1PreloadConfig
    221            /* Enables the TIM1 Preload on CC2 Register */
    222            TIM_OC2PreloadConfig(TIM1, TIM_OCPreload_Enable);
   \   00000180   0x2108             MOVS     R1,#+8
   \   00000182   0x4628             MOV      R0,R5
   \   00000184   0x.... 0x....      BL       TIM_OC2PreloadConfig
    223            /* Enables the TIM1 Preload on CC3 Register */
    224            TIM_OC3PreloadConfig(TIM1, TIM_OCPreload_Enable);
   \   00000188   0x2108             MOVS     R1,#+8
   \   0000018A   0x4628             MOV      R0,R5
   \   0000018C   0x.... 0x....      BL       TIM_OC3PreloadConfig
    225            /* Enables the TIM1 Preload on CC4 Register */
    226            TIM_OC4PreloadConfig(TIM1, TIM_OCPreload_Enable);
   \   00000190   0x2108             MOVS     R1,#+8
   \   00000192   0x4628             MOV      R0,R5
   \   00000194   0x.... 0x....      BL       TIM_OC4PreloadConfig
    227          
    228            /* Automatic Output enable, Break, dead time and lock configuration*/
    229            TIM1_BDTRInitStructure.TIM_OSSRState = TIM_OSSRState_Enable;
   \   00000198   0xF44F 0x6400      MOV      R4,#+2048
   \   0000019C   0xF8AD 0x4038      STRH     R4,[SP, #+56]
    230            TIM1_BDTRInitStructure.TIM_OSSIState = TIM_OSSIState_Enable;
   \   000001A0   0xF44F 0x6080      MOV      R0,#+1024
   \   000001A4   0xF8AD 0x003A      STRH     R0,[SP, #+58]
    231            TIM1_BDTRInitStructure.TIM_LOCKLevel = TIM_LOCKLevel_1; 
   \   000001A8   0xF8AD 0x603C      STRH     R6,[SP, #+60]
    232            TIM1_BDTRInitStructure.TIM_DeadTime = DEADTIME;
   \   000001AC   0x201C             MOVS     R0,#+28
   \   000001AE   0xF8AD 0x003E      STRH     R0,[SP, #+62]
    233            TIM1_BDTRInitStructure.TIM_Break = TIM_Break_Enable;
   \   000001B2   0xF44F 0x5080      MOV      R0,#+4096
   \   000001B6   0xF8AD 0x0040      STRH     R0,[SP, #+64]
    234            TIM1_BDTRInitStructure.TIM_BreakPolarity = TIM_BreakPolarity_Low;
   \   000001BA   0x2000             MOVS     R0,#+0
   \   000001BC   0xF8AD 0x0042      STRH     R0,[SP, #+66]
    235            TIM1_BDTRInitStructure.TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;
   \   000001C0   0xF8AD 0x0044      STRH     R0,[SP, #+68]
    236          
    237            TIM_BDTRConfig(TIM1, &TIM1_BDTRInitStructure);
   \   000001C4   0xA90E             ADD      R1,SP,#+56
   \   000001C6   0x4628             MOV      R0,R5
   \   000001C8   0x.... 0x....      BL       TIM_BDTRConfig
    238          
    239            TIM_SelectOutputTrigger(TIM1, TIM_TRGOSource_Update);
   \   000001CC   0x2120             MOVS     R1,#+32
   \   000001CE   0x4628             MOV      R0,R5
   \   000001D0   0x.... 0x....      BL       TIM_SelectOutputTrigger
    240            
    241            TIM_ClearITPendingBit(TIM1, TIM_IT_Break);
   \   000001D4   0x2180             MOVS     R1,#+128
   \   000001D6   0x4628             MOV      R0,R5
   \   000001D8   0x.... 0x....      BL       TIM_ClearITPendingBit
    242            TIM_ITConfig(TIM1, TIM_IT_Break,ENABLE);
   \   000001DC   0x2201             MOVS     R2,#+1
   \   000001DE   0x2180             MOVS     R1,#+128
   \   000001E0   0x4628             MOV      R0,R5
   \   000001E2   0x.... 0x....      BL       TIM_ITConfig
    243            
    244            /* TIM1 counter enable */
    245            TIM_Cmd(TIM1, ENABLE);
   \   000001E6   0x2101             MOVS     R1,#+1
   \   000001E8   0x4628             MOV      R0,R5
   \   000001EA   0x.... 0x....      BL       TIM_Cmd
    246            
    247            // Resynch to have the Update evend during Undeflow
    248            TIM_GenerateEvent(TIM1, TIM_EventSource_Update);
   \   000001EE   0x2101             MOVS     R1,#+1
   \   000001F0   0x4628             MOV      R0,R5
   \   000001F2   0x.... 0x....      BL       TIM_GenerateEvent
    249            
    250            // Clear Update Flag
    251            TIM_ClearFlag(TIM1, TIM_FLAG_Update);
   \   000001F6   0x2101             MOVS     R1,#+1
   \   000001F8   0x4628             MOV      R0,R5
   \   000001FA   0x.... 0x....      BL       TIM_ClearFlag
    252            
    253            TIM_ITConfig(TIM1, TIM_IT_Update, DISABLE);
   \   000001FE   0x2200             MOVS     R2,#+0
   \   00000200   0x2101             MOVS     R1,#+1
   \   00000202   0x4628             MOV      R0,R5
   \   00000204   0x.... 0x....      BL       TIM_ITConfig
    254            
    255            TIM_ITConfig(TIM1, TIM_IT_CC4,DISABLE);
   \   00000208   0x2200             MOVS     R2,#+0
   \   0000020A   0x2110             MOVS     R1,#+16
   \   0000020C   0x4628             MOV      R0,R5
   \   0000020E   0x.... 0x....      BL       TIM_ITConfig
    256               
    257            /* ADC1 registers reset ----------------------------------------------------*/
    258            ADC_DeInit(ADC1);
   \   00000212   0x.... 0x....      LDR.W    R5,??DataTable6_5  ;; 0x40012400
   \   00000216   0x4628             MOV      R0,R5
   \   00000218   0x.... 0x....      BL       ADC_DeInit
    259            /* ADC2 registers reset ----------------------------------------------------*/
    260            ADC_DeInit(ADC2);
   \   0000021C   0x.... 0x....      LDR.W    R6,??DataTable6_6  ;; 0x40012800
   \   00000220   0x4630             MOV      R0,R6
   \   00000222   0x.... 0x....      BL       ADC_DeInit
    261            
    262            /* Enable ADC1 */
    263            ADC_Cmd(ADC1, ENABLE);
   \   00000226   0x2101             MOVS     R1,#+1
   \   00000228   0x4628             MOV      R0,R5
   \   0000022A   0x.... 0x....      BL       ADC_Cmd
    264            /* Enable ADC2 */
    265            ADC_Cmd(ADC2, ENABLE);
   \   0000022E   0x2101             MOVS     R1,#+1
   \   00000230   0x4630             MOV      R0,R6
   \   00000232   0x.... 0x....      BL       ADC_Cmd
    266            
    267            /* ADC1 configuration ------------------------------------------------------*/
    268            ADC_StructInit(&ADC_InitStructure);
   \   00000236   0xA806             ADD      R0,SP,#+24
   \   00000238   0x.... 0x....      BL       ADC_StructInit
    269            ADC_InitStructure.ADC_Mode = ADC_Mode_InjecSimult;
   \   0000023C   0xF44F 0x20A0      MOV      R0,#+327680
   \   00000240   0x9006             STR      R0,[SP, #+24]
    270            ADC_InitStructure.ADC_ScanConvMode = ENABLE;
   \   00000242   0x2001             MOVS     R0,#+1
   \   00000244   0xF88D 0x001C      STRB     R0,[SP, #+28]
    271            ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;
   \   00000248   0x2000             MOVS     R0,#+0
   \   0000024A   0xF88D 0x001D      STRB     R0,[SP, #+29]
    272            ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
   \   0000024E   0xF44F 0x2760      MOV      R7,#+917504
   \   00000252   0x9708             STR      R7,[SP, #+32]
    273            ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Left;
   \   00000254   0x9409             STR      R4,[SP, #+36]
    274            ADC_InitStructure.ADC_NbrOfChannel = 1;
   \   00000256   0x2001             MOVS     R0,#+1
   \   00000258   0xF88D 0x0028      STRB     R0,[SP, #+40]
    275            ADC_Init(ADC1, &ADC_InitStructure);
   \   0000025C   0xA906             ADD      R1,SP,#+24
   \   0000025E   0x4628             MOV      R0,R5
   \   00000260   0x.... 0x....      BL       ADC_Init
    276             
    277            /* ADC2 Configuration ------------------------------------------------------*/
    278            ADC_StructInit(&ADC_InitStructure);  
   \   00000264   0xA806             ADD      R0,SP,#+24
   \   00000266   0x.... 0x....      BL       ADC_StructInit
    279            ADC_InitStructure.ADC_ScanConvMode = ENABLE;
   \   0000026A   0x2001             MOVS     R0,#+1
   \   0000026C   0xF88D 0x001C      STRB     R0,[SP, #+28]
    280            ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;
   \   00000270   0x2000             MOVS     R0,#+0
   \   00000272   0xF88D 0x001D      STRB     R0,[SP, #+29]
    281            ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
   \   00000276   0x9708             STR      R7,[SP, #+32]
    282            ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Left;
   \   00000278   0x9409             STR      R4,[SP, #+36]
    283            ADC_InitStructure.ADC_NbrOfChannel = 1;
   \   0000027A   0x2001             MOVS     R0,#+1
   \   0000027C   0xF88D 0x0028      STRB     R0,[SP, #+40]
    284            ADC_Init(ADC2, &ADC_InitStructure);
   \   00000280   0xA906             ADD      R1,SP,#+24
   \   00000282   0x4630             MOV      R0,R6
   \   00000284   0x.... 0x....      BL       ADC_Init
    285            
    286            // Start calibration of ADC1
    287            ADC_StartCalibration(ADC1);
   \   00000288   0x4628             MOV      R0,R5
   \   0000028A   0x.... 0x....      BL       ADC_StartCalibration
    288            // Start calibration of ADC2
    289            ADC_StartCalibration(ADC2);
   \   0000028E   0x4630             MOV      R0,R6
   \   00000290   0x.... 0x....      BL       ADC_StartCalibration
    290            
    291            // Wait for the end of ADCs calibration 
    292            while (ADC_GetCalibrationStatus(ADC1) & ADC_GetCalibrationStatus(ADC2))
   \                     ??SVPWM_3ShuntInit_0:
   \   00000294   0x4628             MOV      R0,R5
   \   00000296   0x.... 0x....      BL       ADC_GetCalibrationStatus
   \   0000029A   0x4604             MOV      R4,R0
   \   0000029C   0x4630             MOV      R0,R6
   \   0000029E   0x.... 0x....      BL       ADC_GetCalibrationStatus
   \   000002A2   0x4204             TST      R4,R0
   \   000002A4   0xD1F6             BNE.N    ??SVPWM_3ShuntInit_0
    293            {
    294            }
    295            
    296            SVPWM_3ShuntCurrentReadingCalibration();
   \   000002A6   0x.... 0x....      BL       SVPWM_3ShuntCurrentReadingCalibration
    297              
    298            /* ADC2 Injected conversions configuration */ 
    299            ADC_InjectedSequencerLengthConfig(ADC2,2);
   \   000002AA   0x2102             MOVS     R1,#+2
   \   000002AC   0x4630             MOV      R0,R6
   \   000002AE   0x.... 0x....      BL       ADC_InjectedSequencerLengthConfig
    300            
    301            ADC_InjectedChannelConfig(ADC2, PHASE_A_ADC_CHANNEL, 1, 
    302                                                                SAMPLING_TIME_CK);
   \   000002B2   0x2301             MOVS     R3,#+1
   \   000002B4   0x2201             MOVS     R2,#+1
   \   000002B6   0x210B             MOVS     R1,#+11
   \   000002B8   0x4630             MOV      R0,R6
   \   000002BA   0x.... 0x....      BL       ADC_InjectedChannelConfig
    303            ADC_InjectedChannelConfig(ADC2, TEMP_FDBK_CHANNEL, 2,
    304                                                                SAMPLING_TIME_CK);
   \   000002BE   0x2301             MOVS     R3,#+1
   \   000002C0   0x2202             MOVS     R2,#+2
   \   000002C2   0x210A             MOVS     R1,#+10
   \   000002C4   0x4630             MOV      R0,R6
   \   000002C6   0x.... 0x....      BL       ADC_InjectedChannelConfig
    305            
    306            /* Configure one bit for preemption priority */
    307            NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
   \   000002CA   0xF44F 0x60A0      MOV      R0,#+1280
   \   000002CE   0x.... 0x....      BL       NVIC_PriorityGroupConfig
    308            
    309            NVIC_StructInit(&NVIC_InitStructure);
   \   000002D2   0xA801             ADD      R0,SP,#+4
   \   000002D4   0x.... 0x....      BL       NVIC_StructInit
    310            /* Enable the ADC Interrupt */
    311            NVIC_InitStructure.NVIC_IRQChannel = ADC1_2_IRQChannel;
   \   000002D8   0x2012             MOVS     R0,#+18
   \   000002DA   0xF88D 0x0004      STRB     R0,[SP, #+4]
    312            NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = ADC_PRE_EMPTION_PRIORITY;
   \   000002DE   0x2001             MOVS     R0,#+1
   \   000002E0   0xF88D 0x0005      STRB     R0,[SP, #+5]
    313            NVIC_InitStructure.NVIC_IRQChannelSubPriority = ADC_SUB_PRIORITY;
   \   000002E4   0x2000             MOVS     R0,#+0
   \   000002E6   0xF88D 0x0006      STRB     R0,[SP, #+6]
    314            NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \   000002EA   0x2001             MOVS     R0,#+1
   \   000002EC   0xF88D 0x0007      STRB     R0,[SP, #+7]
    315            NVIC_Init(&NVIC_InitStructure);
   \   000002F0   0xA801             ADD      R0,SP,#+4
   \   000002F2   0x.... 0x....      BL       NVIC_Init
    316            
    317            /* Enable the Update Interrupt */
    318            NVIC_InitStructure.NVIC_IRQChannel = TIM1_UP_IRQChannel;
   \   000002F6   0x2019             MOVS     R0,#+25
   \   000002F8   0xF88D 0x0004      STRB     R0,[SP, #+4]
    319            NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = TIM1_UP_PRE_EMPTION_PRIORITY;
   \   000002FC   0x2001             MOVS     R0,#+1
   \   000002FE   0xF88D 0x0005      STRB     R0,[SP, #+5]
    320            NVIC_InitStructure.NVIC_IRQChannelSubPriority = TIM1_UP_SUB_PRIORITY;
   \   00000302   0x2000             MOVS     R0,#+0
   \   00000304   0xF88D 0x0006      STRB     R0,[SP, #+6]
    321            NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \   00000308   0x2001             MOVS     R0,#+1
   \   0000030A   0xF88D 0x0007      STRB     R0,[SP, #+7]
    322            NVIC_Init(&NVIC_InitStructure);
   \   0000030E   0xA801             ADD      R0,SP,#+4
   \   00000310   0x.... 0x....      BL       NVIC_Init
    323              
    324            /* Enable the TIM1 BRK Interrupt */
    325            NVIC_InitStructure.NVIC_IRQChannel = TIM1_BRK_IRQChannel;
   \   00000314   0x2018             MOVS     R0,#+24
   \   00000316   0xF88D 0x0004      STRB     R0,[SP, #+4]
    326            NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = BRK_PRE_EMPTION_PRIORITY;
   \   0000031A   0x2000             MOVS     R0,#+0
   \   0000031C   0xF88D 0x0005      STRB     R0,[SP, #+5]
    327            NVIC_InitStructure.NVIC_IRQChannelSubPriority = BRK_SUB_PRIORITY;
   \   00000320   0xF88D 0x0006      STRB     R0,[SP, #+6]
    328            NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \   00000324   0x2001             MOVS     R0,#+1
   \   00000326   0xF88D 0x0007      STRB     R0,[SP, #+7]
    329            NVIC_Init(&NVIC_InitStructure); 
   \   0000032A   0xA801             ADD      R0,SP,#+4
   \   0000032C   0x.... 0x....      BL       NVIC_Init
    330          } 
   \   00000330   0xB013             ADD      SP,SP,#+76
   \   00000332   0xBDF0             POP      {R4-R7,PC}       ;; return
    331          
    332          
    333          /*******************************************************************************
    334          * Function Name  : SVPWM_3ShuntCurrentReadingCalibration
    335          * Description    : Store zero current converted values for current reading 
    336                             network offset compensation in case of 3 shunt resistors 
    337          * Input          : None
    338          * Output         : None
    339          * Return         : None
    340          *******************************************************************************/
    341          

   \                                 In section .text, align 2, keep-with-next
    342          void SVPWM_3ShuntCurrentReadingCalibration(void)
    343          {
   \                     SVPWM_3ShuntCurrentReadingCalibration:
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
    344            static u16 bIndex;
    345            
    346            /* ADC1 Injected group of conversions end interrupt disabling */
    347            ADC_ITConfig(ADC1, ADC_IT_JEOC, DISABLE);
   \   00000004   0x.... 0x....      LDR.W    R4,??DataTable6_5  ;; 0x40012400
   \   00000008   0x2200             MOVS     R2,#+0
   \   0000000A   0xF44F 0x6190      MOV      R1,#+1152
   \   0000000E   0x4620             MOV      R0,R4
   \   00000010   0x.... 0x....      BL       ADC_ITConfig
    348            
    349            hPhaseAOffset=0;
   \   00000014   0x.... 0x....      LDR.W    R5,??DataTable6_7
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x8068             STRH     R0,[R5, #+2]
    350            hPhaseBOffset=0;
   \   0000001C   0x80A8             STRH     R0,[R5, #+4]
    351            hPhaseCOffset=0;
   \   0000001E   0x80E8             STRH     R0,[R5, #+6]
    352            
    353            /* ADC1 Injected conversions trigger is given by software and enabled */ 
    354            ADC_ExternalTrigInjectedConvConfig(ADC1, ADC_ExternalTrigInjecConv_None);  
   \   00000020   0xF44F 0x41E0      MOV      R1,#+28672
   \   00000024   0x4620             MOV      R0,R4
   \   00000026   0x.... 0x....      BL       ADC_ExternalTrigInjectedConvConfig
    355            ADC_ExternalTrigInjectedConvCmd(ADC1,ENABLE); 
   \   0000002A   0x2101             MOVS     R1,#+1
   \   0000002C   0x4620             MOV      R0,R4
   \   0000002E   0x.... 0x....      BL       ADC_ExternalTrigInjectedConvCmd
    356            
    357            /* ADC1 Injected conversions configuration */ 
    358            ADC_InjectedSequencerLengthConfig(ADC1,3);
   \   00000032   0x2103             MOVS     R1,#+3
   \   00000034   0x4620             MOV      R0,R4
   \   00000036   0x.... 0x....      BL       ADC_InjectedSequencerLengthConfig
    359            ADC_InjectedChannelConfig(ADC1, PHASE_A_ADC_CHANNEL,1,SAMPLING_TIME_CK);
   \   0000003A   0x2301             MOVS     R3,#+1
   \   0000003C   0x2201             MOVS     R2,#+1
   \   0000003E   0x210B             MOVS     R1,#+11
   \   00000040   0x4620             MOV      R0,R4
   \   00000042   0x.... 0x....      BL       ADC_InjectedChannelConfig
    360            ADC_InjectedChannelConfig(ADC1, PHASE_B_ADC_CHANNEL,2,SAMPLING_TIME_CK);
   \   00000046   0x2301             MOVS     R3,#+1
   \   00000048   0x2202             MOVS     R2,#+2
   \   0000004A   0x210C             MOVS     R1,#+12
   \   0000004C   0x4620             MOV      R0,R4
   \   0000004E   0x.... 0x....      BL       ADC_InjectedChannelConfig
    361            ADC_InjectedChannelConfig(ADC1, PHASE_C_ADC_CHANNEL,3,SAMPLING_TIME_CK);
   \   00000052   0x2301             MOVS     R3,#+1
   \   00000054   0x2203             MOVS     R2,#+3
   \   00000056   0x210D             MOVS     R1,#+13
   \   00000058   0x4620             MOV      R0,R4
   \   0000005A   0x.... 0x....      BL       ADC_InjectedChannelConfig
    362            
    363            /* Clear the ADC1 JEOC pending flag */
    364            ADC_ClearFlag(ADC1, ADC_FLAG_JEOC);  
   \   0000005E   0x2104             MOVS     R1,#+4
   \   00000060   0x4620             MOV      R0,R4
   \   00000062   0x.... 0x....      BL       ADC_ClearFlag
    365            ADC_SoftwareStartInjectedConvCmd(ADC1,ENABLE);
   \   00000066   0x2101             MOVS     R1,#+1
   \   00000068   0x4620             MOV      R0,R4
   \   0000006A   0x.... 0x....      BL       ADC_SoftwareStartInjectedConvCmd
    366             
    367            /* ADC Channel used for current reading are read 
    368               in order to get zero currents ADC values*/ 
    369            for(bIndex=0; bIndex <NB_CONVERSIONS; bIndex++)
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0x8128             STRH     R0,[R5, #+8]
    370            {
    371              while(!ADC_GetFlagStatus(ADC1,ADC_FLAG_JEOC)) { }
   \                     ??SVPWM_3ShuntCurrentReadingCalibration_0:
   \   00000072   0x2104             MOVS     R1,#+4
   \   00000074   0x4620             MOV      R0,R4
   \   00000076   0x.... 0x....      BL       ADC_GetFlagStatus
   \   0000007A   0x2800             CMP      R0,#+0
   \   0000007C   0xD0F9             BEQ.N    ??SVPWM_3ShuntCurrentReadingCalibration_0
    372              
    373              hPhaseAOffset += (ADC_GetInjectedConversionValue(ADC1,ADC_InjectedChannel_1)>>3);
   \   0000007E   0x2114             MOVS     R1,#+20
   \   00000080   0x4620             MOV      R0,R4
   \   00000082   0x.... 0x....      BL       ADC_GetInjectedConversionValue
   \   00000086   0x8869             LDRH     R1,[R5, #+2]
   \   00000088   0xEB01 0x00D0      ADD      R0,R1,R0, LSR #+3
   \   0000008C   0x8068             STRH     R0,[R5, #+2]
    374              hPhaseBOffset += (ADC_GetInjectedConversionValue(ADC1,ADC_InjectedChannel_2)>>3);
   \   0000008E   0x2118             MOVS     R1,#+24
   \   00000090   0x4620             MOV      R0,R4
   \   00000092   0x.... 0x....      BL       ADC_GetInjectedConversionValue
   \   00000096   0x88A9             LDRH     R1,[R5, #+4]
   \   00000098   0xEB01 0x00D0      ADD      R0,R1,R0, LSR #+3
   \   0000009C   0x80A8             STRH     R0,[R5, #+4]
    375              hPhaseCOffset += (ADC_GetInjectedConversionValue(ADC1,ADC_InjectedChannel_3)>>3);    
   \   0000009E   0x211C             MOVS     R1,#+28
   \   000000A0   0x4620             MOV      R0,R4
   \   000000A2   0x.... 0x....      BL       ADC_GetInjectedConversionValue
   \   000000A6   0x88E9             LDRH     R1,[R5, #+6]
   \   000000A8   0xEB01 0x00D0      ADD      R0,R1,R0, LSR #+3
   \   000000AC   0x80E8             STRH     R0,[R5, #+6]
    376                  
    377              /* Clear the ADC1 JEOC pending flag */
    378              ADC_ClearFlag(ADC1, ADC_FLAG_JEOC);    
   \   000000AE   0x2104             MOVS     R1,#+4
   \   000000B0   0x4620             MOV      R0,R4
   \   000000B2   0x.... 0x....      BL       ADC_ClearFlag
    379              ADC_SoftwareStartInjectedConvCmd(ADC1,ENABLE);
   \   000000B6   0x2101             MOVS     R1,#+1
   \   000000B8   0x4620             MOV      R0,R4
   \   000000BA   0x.... 0x....      BL       ADC_SoftwareStartInjectedConvCmd
    380            }
   \   000000BE   0x8928             LDRH     R0,[R5, #+8]
   \   000000C0   0x1C40             ADDS     R0,R0,#+1
   \   000000C2   0x8128             STRH     R0,[R5, #+8]
   \   000000C4   0xB280             UXTH     R0,R0
   \   000000C6   0x2810             CMP      R0,#+16
   \   000000C8   0xD3D3             BCC.N    ??SVPWM_3ShuntCurrentReadingCalibration_0
    381            
    382            SVPWM_InjectedConvConfig();  
   \   000000CA   0xB001             ADD      SP,SP,#+4
   \   000000CC   0xE8BD 0x4030      POP      {R4,R5,LR}
   \   000000D0                      REQUIRE SVPWM_InjectedConvConfig
   \   000000D0                      ;; // Fall through to label SVPWM_InjectedConvConfig
    383          }

   \                                 In section .bss, align 2
   \                     bSector:
   \   00000000                      DS8 1
   \                     PWM4Direction:
   \   00000001                      DS8 1
   \                     hPhaseAOffset:
   \   00000002                      DS8 2
   \                     hPhaseBOffset:
   \   00000004                      DS8 2
   \                     hPhaseCOffset:
   \   00000006                      DS8 2
   \   00000008                      DS8 2
    384          
    385          
    386          
    387          /*******************************************************************************
    388          * Function Name  : SVPWM_InjectedConvConfig
    389          * Description    : This function configure ADC1 for 3 shunt current 
    390          *                  reading and temperature and voltage feedbcak after a 
    391          *                  calibration of the three utilized ADC Channels
    392          * Input          : None
    393          * Output         : None
    394          * Return         : None
    395          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    396          void SVPWM_InjectedConvConfig(void)
    397          {
   \                     SVPWM_InjectedConvConfig:
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
    398            /* ADC1 Injected conversions configuration */ 
    399            ADC_InjectedSequencerLengthConfig(ADC1,2);
   \   00000004   0x.... 0x....      LDR.W    R4,??DataTable6_5  ;; 0x40012400
   \   00000008   0x2102             MOVS     R1,#+2
   \   0000000A   0x4620             MOV      R0,R4
   \   0000000C   0x.... 0x....      BL       ADC_InjectedSequencerLengthConfig
    400            ADC_InjectedSequencerLengthConfig(ADC2,2);
   \   00000010   0x.... 0x....      LDR.W    R5,??DataTable6_6  ;; 0x40012800
   \   00000014   0x2102             MOVS     R1,#+2
   \   00000016   0x4628             MOV      R0,R5
   \   00000018   0x.... 0x....      BL       ADC_InjectedSequencerLengthConfig
    401            
    402            ADC_InjectedChannelConfig(ADC1, PHASE_B_ADC_CHANNEL, 1, 
    403                                                                SAMPLING_TIME_CK);
   \   0000001C   0x2301             MOVS     R3,#+1
   \   0000001E   0x2201             MOVS     R2,#+1
   \   00000020   0x210C             MOVS     R1,#+12
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0x.... 0x....      BL       ADC_InjectedChannelConfig
    404            ADC_InjectedChannelConfig(ADC1, BUS_VOLT_FDBK_CHANNEL, 
    405                                                             2, SAMPLING_TIME_CK);
   \   00000028   0x2301             MOVS     R3,#+1
   \   0000002A   0x2202             MOVS     R2,#+2
   \   0000002C   0x2103             MOVS     R1,#+3
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0x.... 0x....      BL       ADC_InjectedChannelConfig
    406              
    407            /* ADC1 Injected conversions trigger is TIM1 TRGO */ 
    408            ADC_ExternalTrigInjectedConvConfig(ADC1, ADC_ExternalTrigInjecConv_T1_TRGO); 
   \   00000034   0x2100             MOVS     R1,#+0
   \   00000036   0x4620             MOV      R0,R4
   \   00000038   0x.... 0x....      BL       ADC_ExternalTrigInjectedConvConfig
    409            
    410            ADC_ExternalTrigInjectedConvCmd(ADC2,ENABLE);
   \   0000003C   0x2101             MOVS     R1,#+1
   \   0000003E   0x4628             MOV      R0,R5
   \   00000040   0x.... 0x....      BL       ADC_ExternalTrigInjectedConvCmd
    411            
    412            /* Bus voltage protection initialization*/                            
    413            ADC_AnalogWatchdogCmd(ADC1,ADC_AnalogWatchdog_SingleInjecEnable);
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable6_8  ;; 0x400200
   \   00000048   0x4620             MOV      R0,R4
   \   0000004A   0x.... 0x....      BL       ADC_AnalogWatchdogCmd
    414            ADC_AnalogWatchdogSingleChannelConfig(ADC1,BUS_VOLT_FDBK_CHANNEL);
   \   0000004E   0x2103             MOVS     R1,#+3
   \   00000050   0x4620             MOV      R0,R4
   \   00000052   0x.... 0x....      BL       ADC_AnalogWatchdogSingleChannelConfig
    415            ADC_AnalogWatchdogThresholdsConfig(ADC1, OVERVOLTAGE_THRESHOLD>>3,0x00);
   \   00000056   0x2200             MOVS     R2,#+0
   \   00000058   0xF640 0x5193      MOVW     R1,#+3475
   \   0000005C   0x4620             MOV      R0,R4
   \   0000005E   0x.... 0x....      BL       ADC_AnalogWatchdogThresholdsConfig
    416            
    417            
    418            /* ADC1 Injected group of conversions end and Analog Watchdog interrupts
    419                                                                               enabling */
    420            ADC_ITConfig(ADC1, ADC_IT_JEOC | ADC_IT_AWD, ENABLE);
   \   00000062   0x2201             MOVS     R2,#+1
   \   00000064   0xF44F 0x61B8      MOV      R1,#+1472
   \   00000068   0x4620             MOV      R0,R4
   \   0000006A   0xB001             ADD      SP,SP,#+4
   \   0000006C   0xE8BD 0x4030      POP      {R4,R5,LR}
   \   00000070   0x.... 0x....      B.W      ADC_ITConfig
    421          }
    422          
    423          /*******************************************************************************
    424          * Function Name  : SVPWM_3ShuntGetPhaseCurrentValues
    425          * Description    : This function computes current values of Phase A and Phase B 
    426          *                 in q1.15 format starting from values acquired from the A/D 
    427          *                 Converter peripheral.
    428          * Input          : None
    429          * Output         : Stat_Curr_a_b
    430          * Return         : None
    431          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    432          Curr_Components SVPWM_3ShuntGetPhaseCurrentValues(void)
    433          {
   \                     SVPWM_3ShuntGetPhaseCurrentValues:
   \   00000000   0xB081             SUB      SP,SP,#+4
    434            Curr_Components Local_Stator_Currents;
    435            s32 wAux;
    436          
    437            switch (bSector)
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable6_7
   \   00000006   0x7801             LDRB     R1,[R0, #+0]
   \   00000008   0x1E49             SUBS     R1,R1,#+1
   \   0000000A   0x2905             CMP      R1,#+5
   \   0000000C   0xD83D             BHI.N    ??SVPWM_3ShuntGetPhaseCurrentValues_1
   \   0000000E   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??SVPWM_3ShuntGetPhaseCurrentValues_0:
   \   00000012   0x13 0x28          DC8      0x13,0x28,0x28,0x3
   \              0x28 0x03    
   \   00000016   0x03 0x13          DC8      0x3,0x13
    438             {
    439             case 4:
    440             case 5: //Current on Phase C not accessible     
    441                     // Ia = (hPhaseAOffset)-(ADC Channel 11 value)    
    442                      wAux = (s32)(hPhaseAOffset)- ((ADC1->JDR1)<<1);          
   \                     ??SVPWM_3ShuntGetPhaseCurrentValues_2:
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable6_9  ;; 0x4001243c
   \   0000001C   0x8842             LDRH     R2,[R0, #+2]
   \   0000001E   0x680B             LDR      R3,[R1, #+0]
   \   00000020   0xEBA2 0x0243      SUB      R2,R2,R3, LSL #+1
    443                     //Saturation of Ia 
    444                      if (wAux < S16_MIN)
   \   00000024   0xF302 0x020F      SSAT     R2,#+16,R2
   \   00000028   0xF8AD 0x2000      STRH     R2,[SP, #+0]
    445                      {
    446                        Local_Stator_Currents.qI_Component1= S16_MIN;
    447                      }  
    448                      else  if (wAux > S16_MAX)
    449                            { 
    450                              Local_Stator_Currents.qI_Component1= S16_MAX;
    451                            }
    452                            else
    453                            {
    454                              Local_Stator_Currents.qI_Component1= wAux;
    455                            }
    456                               
    457                     // Ib = (hPhaseBOffset)-(ADC Channel 12 value)
    458                      wAux = (s32)(hPhaseBOffset)-((ADC2->JDR1)<<1);
   \   0000002C   0x8880             LDRH     R0,[R0, #+4]
   \   0000002E   0xF8D1 0x1400      LDR      R1,[R1, #+1024]
   \   00000032   0xEBA0 0x0041      SUB      R0,R0,R1, LSL #+1
    459                     // Saturation of Ib
    460                      if (wAux < S16_MIN)
   \   00000036   0xE024             B.N      ??SVPWM_3ShuntGetPhaseCurrentValues_3
    461                      {
    462                        Local_Stator_Currents.qI_Component2= S16_MIN;
    463                      }  
    464                      else  if (wAux > S16_MAX)
    465                            { 
    466                              Local_Stator_Currents.qI_Component2= S16_MAX;
    467                            }
    468                            else
    469                            {
    470                              Local_Stator_Currents.qI_Component2= wAux;
    471                            }
    472                     break;
    473                     
    474             case 6:
    475             case 1:  //Current on Phase A not accessible     
    476                      // Ib = (hPhaseBOffset)-(ADC Channel 12 value)
    477                      wAux = (s32)(hPhaseBOffset)-((ADC1->JDR1)<<1);
   \                     ??SVPWM_3ShuntGetPhaseCurrentValues_4:
   \   00000038   0x.... 0x....      LDR.W    R1,??DataTable6_9  ;; 0x4001243c
   \   0000003C   0x8882             LDRH     R2,[R0, #+4]
   \   0000003E   0x680B             LDR      R3,[R1, #+0]
   \   00000040   0xEBA2 0x0243      SUB      R2,R2,R3, LSL #+1
    478                      //Saturation of Ib 
    479                      if (wAux < S16_MIN)
   \   00000044   0xF302 0x020F      SSAT     R2,#+16,R2
   \   00000048   0xF8AD 0x2002      STRH     R2,[SP, #+2]
    480                      {
    481                        Local_Stator_Currents.qI_Component2= S16_MIN;
    482                      }  
    483                      else  if (wAux > S16_MAX)
    484                            { 
    485                              Local_Stator_Currents.qI_Component2= S16_MAX;
    486                            }
    487                            else
    488                            {
    489                              Local_Stator_Currents.qI_Component2= wAux;
    490                            }
    491                      // Ia = -Ic -Ib 
    492                      wAux = ((ADC2->JDR1)<<1)-hPhaseCOffset-
    493                                                      Local_Stator_Currents.qI_Component2;
   \   0000004C   0xF8D1 0x1400      LDR      R1,[R1, #+1024]
   \   00000050   0x88C0             LDRH     R0,[R0, #+6]
   \   00000052   0xEBC0 0x0041      RSB      R0,R0,R1, LSL #+1
   \   00000056   0x1A80             SUBS     R0,R0,R2
    494                      //Saturation of Ia
    495                      if (wAux> S16_MAX)
   \   00000058   0xF300 0x000F      SSAT     R0,#+16,R0
   \   0000005C   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \   00000060   0xE013             B.N      ??SVPWM_3ShuntGetPhaseCurrentValues_1
    496                      {
    497                         Local_Stator_Currents.qI_Component1 = S16_MAX;
    498                      }
    499                      else  if (wAux <S16_MIN)
    500                            {
    501                             Local_Stator_Currents.qI_Component1 = S16_MIN;
    502                            }
    503                            else
    504                            {  
    505                              Local_Stator_Currents.qI_Component1 = wAux;
    506                            }
    507                     break;
    508                     
    509             case 2:
    510             case 3:  // Current on Phase B not accessible
    511                      // Ia = (hPhaseAOffset)-(ADC Channel 11 value)     
    512                      wAux = (s32)(hPhaseAOffset)-((ADC1->JDR1)<<1);
   \                     ??SVPWM_3ShuntGetPhaseCurrentValues_5:
   \   00000062   0x.... 0x....      LDR.W    R1,??DataTable6_9  ;; 0x4001243c
   \   00000066   0x8842             LDRH     R2,[R0, #+2]
   \   00000068   0x680B             LDR      R3,[R1, #+0]
   \   0000006A   0xEBA2 0x0243      SUB      R2,R2,R3, LSL #+1
    513                      //Saturation of Ia 
    514                      if (wAux < S16_MIN)
   \   0000006E   0xF302 0x020F      SSAT     R2,#+16,R2
   \   00000072   0xF8AD 0x2000      STRH     R2,[SP, #+0]
    515                      {
    516                        Local_Stator_Currents.qI_Component1= S16_MIN;
    517                      }  
    518                      else  if (wAux > S16_MAX)
    519                            { 
    520                              Local_Stator_Currents.qI_Component1= S16_MAX;
    521                            }
    522                            else
    523                            {
    524                              Local_Stator_Currents.qI_Component1= wAux;
    525                            }
    526               
    527                      // Ib = -Ic-Ia;
    528                      wAux = ((ADC2->JDR1)<<1) - hPhaseCOffset - 
    529                                                      Local_Stator_Currents.qI_Component1;
   \   00000076   0xF8D1 0x1400      LDR      R1,[R1, #+1024]
   \   0000007A   0x88C0             LDRH     R0,[R0, #+6]
   \   0000007C   0xEBC0 0x0041      RSB      R0,R0,R1, LSL #+1
   \   00000080   0x1A80             SUBS     R0,R0,R2
    530                      // Saturation of Ib
    531                      if (wAux> S16_MAX)
   \                     ??SVPWM_3ShuntGetPhaseCurrentValues_3:
   \   00000082   0xF300 0x000F      SSAT     R0,#+16,R0
   \   00000086   0xF8AD 0x0002      STRH     R0,[SP, #+2]
    532                      {
    533                        Local_Stator_Currents.qI_Component2=S16_MAX;
    534                      }
    535                      else  if (wAux <S16_MIN)
    536                            {  
    537                              Local_Stator_Currents.qI_Component2 = S16_MIN;
    538                            }
    539                            else  
    540                            {
    541                              Local_Stator_Currents.qI_Component2 = wAux;
    542                            }                     
    543                     break;
    544          
    545             default:
    546                     break;
    547             } 
    548            
    549            return(Local_Stator_Currents); 
   \                     ??SVPWM_3ShuntGetPhaseCurrentValues_1:
   \   0000008A   0x9800             LDR      R0,[SP, #+0]
   \   0000008C   0xB001             ADD      SP,SP,#+4
   \   0000008E   0x4770             BX       LR               ;; return
    550          }
    551          
    552          /*******************************************************************************
    553          * Function Name  : SVPWM_3ShuntCalcDutyCycles
    554          * Description    : Computes duty cycle values corresponding to the input value
    555          		   and configures the AD converter and TIM0 for next period 
    556          		   current reading conversion synchronization
    557          * Input          : Stat_Volt_alfa_beta
    558          * Output         : None
    559          * Return         : None
    560          *******************************************************************************/
    561          

   \                                 In section .text, align 4, keep-with-next
    562          void SVPWM_3ShuntCalcDutyCycles (Volt_Components Stat_Volt_Input)
    563          {
   \                     SVPWM_3ShuntCalcDutyCycles:
   \   00000000   0xE92D 0x41F1      PUSH     {R0,R4-R8,LR}
    564             s32 wX, wY, wZ, wUAlpha, wUBeta;
    565             u16  hTimePhA=0, hTimePhB=0, hTimePhC=0, hTimePhD=0;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x4602             MOV      R2,R0
   \   0000000A   0x4603             MOV      R3,R0
    566             u16  hDeltaDuty;
    567              
    568             wUAlpha = Stat_Volt_Input.qV_Component1 * T_SQRT3 ;
   \   0000000C   0xF9BD 0x4000      LDRSH    R4,[SP, #+0]
   \   00000010   0xF244 0x35A8      MOVW     R5,#+17320
   \   00000014   0x4365             MULS     R5,R5,R4
    569             wUBeta = -(Stat_Volt_Input.qV_Component2 * T);
   \   00000016   0xF9BD 0x4002      LDRSH    R4,[SP, #+2]
   \   0000001A   0x.... 0x....      LDR.W    R6,??DataTable6_10  ;; 0xffffd8f0
   \   0000001E   0x4374             MULS     R4,R4,R6
    570          
    571             wX = wUBeta;
    572             wY = (wUBeta + wUAlpha)/2;
   \   00000020   0x192E             ADDS     R6,R5,R4
   \   00000022   0xEB06 0x76D6      ADD      R6,R6,R6, LSR #+31
   \   00000026   0x1077             ASRS     R7,R6,#+1
    573             wZ = (wUBeta - wUAlpha)/2;
   \   00000028   0x1B65             SUBS     R5,R4,R5
   \   0000002A   0xEB05 0x75D5      ADD      R5,R5,R5, LSR #+31
   \   0000002E   0xEA4F 0x0E65      ASR      LR,R5,#+1
    574             
    575            // Sector calculation from wX, wY, wZ
    576             if (wY<0)
   \   00000032   0x2F00             CMP      R7,#+0
   \   00000034   0xD509             BPL.N    ??SVPWM_3ShuntCalcDutyCycles_1
    577             {
    578                if (wZ<0)
   \   00000036   0xF1BE 0x0F00      CMP      LR,#+0
   \   0000003A   0xBF48             IT       MI 
   \   0000003C   0x2605             MOVMI    R6,#+5
    579                {
    580                  bSector = SECTOR_5;
   \   0000003E   0xD40D             BMI.N    ??SVPWM_3ShuntCalcDutyCycles_2
    581                }
    582                else // wZ >= 0
    583                  if (wX<=0)
   \   00000040   0x2C01             CMP      R4,#+1
   \   00000042   0xBFAC             ITE      GE 
   \   00000044   0x2603             MOVGE    R6,#+3
   \   00000046   0x2604             MOVLT    R6,#+4
    584                  {
    585                    bSector = SECTOR_4;
   \   00000048   0xE008             B.N      ??SVPWM_3ShuntCalcDutyCycles_2
    586                  }
    587                  else // wX > 0
    588                  {
    589                    bSector = SECTOR_3;
    590                  }
    591             }
    592             else // wY > 0
    593             {
    594               if (wZ>=0)
   \                     ??SVPWM_3ShuntCalcDutyCycles_1:
   \   0000004A   0xF1BE 0x0F00      CMP      LR,#+0
   \   0000004E   0xBF58             IT       PL 
   \   00000050   0x2602             MOVPL    R6,#+2
    595               {
    596                 bSector = SECTOR_2;
   \   00000052   0xD503             BPL.N    ??SVPWM_3ShuntCalcDutyCycles_2
    597               }
    598               else // wZ < 0
    599                 if (wX<=0)
   \   00000054   0x2C01             CMP      R4,#+1
   \   00000056   0xBFB4             ITE      LT 
   \   00000058   0x2606             MOVLT    R6,#+6
   \   0000005A   0x2601             MOVGE    R6,#+1
    600                 {  
    601                   bSector = SECTOR_6;
    602                 }
    603                 else // wX > 0
    604                 {
    605                   bSector = SECTOR_1;
   \                     ??SVPWM_3ShuntCalcDutyCycles_2:
   \   0000005C   0x....             LDR.N    R5,??DataTable6_7
   \   0000005E   0x702E             STRB     R6,[R5, #+0]
    606                 }
    607              }
    608             
    609             /* Duty cycles computation */
    610            PWM4Direction=PWM2_MODE;
   \   00000060   0x2600             MOVS     R6,#+0
    611              
    612            switch(bSector)
   \   00000062   0xF895 0x8000      LDRB     R8,[R5, #+0]
   \   00000066   0xF1A8 0x0801      SUB      R8,R8,#+1
   \   0000006A   0xF1B8 0x0F05      CMP      R8,#+5
   \   0000006E   0xD842             BHI.N    ??SVPWM_3ShuntCalcDutyCycles_3
   \   00000070   0xE8DF 0xF018      TBH      [PC, R8, LSL #+1]
   \                     ??SVPWM_3ShuntCalcDutyCycles_0:
   \   00000074   0x0006 0x004E      DC16     0x6,0x4E,0x84,0xB1
   \              0x0084 0x00B1
   \   0000007C   0x00E9 0x0116      DC16     0xE9,0x116
    613            {  
    614              case SECTOR_1:
    615                          hTimePhA = (T/8) + ((((T + wX) - wZ)/2)/131072);
   \                     ??SVPWM_3ShuntCalcDutyCycles_4:
   \   00000080   0xF504 0x501C      ADD      R0,R4,#+9984
   \   00000084   0x3010             ADDS     R0,R0,#+16
   \   00000086   0xEBA0 0x000E      SUB      R0,R0,LR
   \   0000008A   0xEB00 0x70D0      ADD      R0,R0,R0, LSR #+31
   \   0000008E   0x1040             ASRS     R0,R0,#+1
   \   00000090   0x1401             ASRS     R1,R0,#+16
   \   00000092   0xEB00 0x30D1      ADD      R0,R0,R1, LSR #+15
   \   00000096   0x1440             ASRS     R0,R0,#+17
   \   00000098   0xF200 0x40E2      ADDW     R0,R0,#+1250
   \   0000009C   0xB280             UXTH     R0,R0
    616          				hTimePhB = hTimePhA + wZ/131072;
   \   0000009E   0xEA4F 0x412E      ASR      R1,LR,#+16
   \   000000A2   0xEB0E 0x31D1      ADD      R1,LR,R1, LSR #+15
   \   000000A6   0xEB00 0x4161      ADD      R1,R0,R1, ASR #+17
   \   000000AA   0xB289             UXTH     R1,R1
    617          				hTimePhC = hTimePhB - wX/131072;
   \   000000AC   0x1422             ASRS     R2,R4,#+16
   \   000000AE   0xEB04 0x32D2      ADD      R2,R4,R2, LSR #+15
   \   000000B2   0xEBA1 0x4262      SUB      R2,R1,R2, ASR #+17
   \   000000B6   0xB292             UXTH     R2,R2
    618                          
    619                          // ADC Syncronization setting value             
    620                          if ((u16)(PWM_PERIOD-hTimePhA) > TW_AFTER)
   \   000000B8   0xF640 0x13C4      MOVW     R3,#+2500
   \   000000BC   0x1A1B             SUBS     R3,R3,R0
   \   000000BE   0xB29B             UXTH     R3,R3
   \   000000C0   0x2BF2             CMP      R3,#+242
   \   000000C2   0xF080 0x810D      BCS.W    ??SVPWM_3ShuntCalcDutyCycles_5
    621                          {
    622                            hTimePhD = PWM_PERIOD - 1;
    623                          }
    624                          else
    625                          {
    626                            hDeltaDuty = (u16)(hTimePhA - hTimePhB);
    627                            
    628          				  // Definition of crossing point
    629                            if (hDeltaDuty > (u16)(PWM_PERIOD-hTimePhA)*2) 
   \   000000C6   0x005B             LSLS     R3,R3,#+1
   \   000000C8   0x1A44             SUBS     R4,R0,R1
   \   000000CA   0xB2A4             UXTH     R4,R4
   \   000000CC   0x42A3             CMP      R3,R4
   \   000000CE   0xF2C0 0x8110      BLT.W    ??SVPWM_3ShuntCalcDutyCycles_6
    630                            {
    631                                hTimePhD = hTimePhA - TW_BEFORE; // Ts before Phase A 
    632                            }
    633                            else
    634                            {
    635                                hTimePhD = hTimePhA + TW_AFTER; // DT + Tn after Phase A
    636                               
    637                              if (hTimePhD >= PWM_PERIOD)
    638                              {
    639                                // Trigger of ADC at Falling Edge PWM4
    640                                // OCR update
    641                                
    642                                //Set Polarity of CC4 Low
    643                                PWM4Direction=PWM1_MODE;
    644                                
    645                                hTimePhD = (2 * PWM_PERIOD) - hTimePhD-1;
    646                              }
    647                            }
    648                          }
    649                          
    650                          // ADC_InjectedChannelConfig(ADC1, PHASE_B_CHANNEL,1,
    651                          //                                    SAMPLING_TIME_CK);               
    652                          ADC1->JSQR = PHASE_B_MSK + BUS_VOLT_FDBK_MSK + SEQUENCE_LENGHT;
    653                          //ADC_InjectedChannelConfig(ADC2, PHASE_C_CHANNEL,1,
    654                          //                                    SAMPLING_TIME_CK);                     
    655                          ADC2->JSQR = PHASE_C_MSK + TEMP_FDBK_MSK + SEQUENCE_LENGHT;                                         
    656                          break;
    657              case SECTOR_2:
    658                          hTimePhA = (T/8) + ((((T + wY) - wZ)/2)/131072);
    659          				hTimePhB = hTimePhA + wZ/131072;
    660          				hTimePhC = hTimePhA - wY/131072;
    661                          
    662                          // ADC Syncronization setting value
    663                          if ((u16)(PWM_PERIOD-hTimePhB) > TW_AFTER)
    664                          {
    665                            hTimePhD = PWM_PERIOD - 1;
    666                          }
    667                          else
    668                          {
    669                            hDeltaDuty = (u16)(hTimePhB - hTimePhA);
    670                            
    671                            // Definition of crossing point
    672                            if (hDeltaDuty > (u16)(PWM_PERIOD-hTimePhB)*2) 
    673                            {
    674                              hTimePhD = hTimePhB - TW_BEFORE; // Ts before Phase B 
    675                            }
    676                            else
    677                            {
    678                              hTimePhD = hTimePhB + TW_AFTER; // DT + Tn after Phase B
    679                              
    680                              if (hTimePhD >= PWM_PERIOD)
    681                              {
    682                                // Trigger of ADC at Falling Edge PWM4
    683                                // OCR update
    684                                
    685                                //Set Polarity of CC4 Low
    686                                PWM4Direction=PWM1_MODE;
    687                                
    688                                hTimePhD = (2 * PWM_PERIOD) - hTimePhD-1;
    689                              }
    690                            }
    691                          }
    692                          
    693                          //ADC_InjectedChannelConfig(ADC1, PHASE_A_CHANNEL,1,
    694                          //                                     SAMPLING_TIME_CK);               
    695                          ADC1->JSQR = PHASE_A_MSK + BUS_VOLT_FDBK_MSK + SEQUENCE_LENGHT;                
    696                          //ADC_InjectedChannelConfig(ADC2, 
    697                          //                   PHASE_C_CHANNEL,1,SAMPLING_TIME_CK);                              
    698          				ADC2->JSQR = PHASE_C_MSK + TEMP_FDBK_MSK + SEQUENCE_LENGHT;
    699                          break;
    700          
    701              case SECTOR_3:
    702                          hTimePhA = (T/8) + ((((T - wX) + wY)/2)/131072);
    703          				hTimePhC = hTimePhA - wY/131072;
    704          				hTimePhB = hTimePhC + wX/131072;
    705          		
    706                          // ADC Syncronization setting value
    707                          if ((u16)(PWM_PERIOD-hTimePhB) > TW_AFTER)
    708                          {
    709                            hTimePhD = PWM_PERIOD - 1;
    710                          }
    711                          else
    712                          {
    713                            hDeltaDuty = (u16)(hTimePhB - hTimePhC);
    714                            
    715                            // Definition of crossing point
    716                            if (hDeltaDuty > (u16)(PWM_PERIOD-hTimePhB)*2) 
    717                            {
    718                              hTimePhD = hTimePhB - TW_BEFORE; // Ts before Phase B 
    719                            }
    720                            else
    721                            {
    722                              hTimePhD = hTimePhB + TW_AFTER; // DT + Tn after Phase B
    723                              
    724                              if (hTimePhD >= PWM_PERIOD)
    725                              {
    726                                // Trigger of ADC at Falling Edge PWM4
    727                                // OCR update
    728                                
    729                                //Set Polarity of CC4 Low
    730                                PWM4Direction=PWM1_MODE;
    731                                
    732                                hTimePhD = (2 * PWM_PERIOD) - hTimePhD-1;
    733                              }
    734                            }
    735                          }
    736                          
    737                          //ADC_InjectedChannelConfig(ADC1, PHASE_A_CHANNEL,1,
    738                          //                                    SAMPLING_TIME_CK);               
    739                          ADC1->JSQR = PHASE_A_MSK + BUS_VOLT_FDBK_MSK + SEQUENCE_LENGHT;                
    740                          //ADC_InjectedChannelConfig(ADC2, PHASE_C_CHANNEL,1,
    741                          //                                    SAMPLING_TIME_CK);                                        
    742          				ADC2->JSQR = PHASE_C_MSK + TEMP_FDBK_MSK + SEQUENCE_LENGHT;
    743                          break;
    744              
    745              case SECTOR_4:
    746                          hTimePhA = (T/8) + ((((T + wX) - wZ)/2)/131072);
    747                          hTimePhB = hTimePhA + wZ/131072;
    748                          hTimePhC = hTimePhB - wX/131072;
    749                          
    750                          // ADC Syncronization setting value
    751                          if ((u16)(PWM_PERIOD-hTimePhC) > TW_AFTER)
    752                          {
    753                            hTimePhD = PWM_PERIOD - 1;
    754                          }
    755                          else
    756                          {
    757                            hDeltaDuty = (u16)(hTimePhC - hTimePhB);
    758                            
    759                            // Definition of crossing point
    760                            if (hDeltaDuty > (u16)(PWM_PERIOD-hTimePhC)*2)
    761                            {
    762                              hTimePhD = hTimePhC - TW_BEFORE; // Ts before Phase C 
    763                            }
    764                            else
    765                            {
    766                              hTimePhD = hTimePhC + TW_AFTER; // DT + Tn after Phase C
    767                              
    768                              if (hTimePhD >= PWM_PERIOD)
    769                              {
    770                                // Trigger of ADC at Falling Edge PWM4
    771                                // OCR update
    772                                
    773                                //Set Polarity of CC4 Low
    774                                PWM4Direction=PWM1_MODE;
    775                                
    776                                hTimePhD = (2 * PWM_PERIOD) - hTimePhD-1;
    777                              }
    778                            }
    779                          }
    780                          
    781                          //ADC_InjectedChannelConfig(ADC1, PHASE_A_CHANNEL,1,
    782                          //                                    SAMPLING_TIME_CK);             
    783                          ADC1->JSQR = PHASE_A_MSK + BUS_VOLT_FDBK_MSK + SEQUENCE_LENGHT;                
    784                          //ADC_InjectedChannelConfig(ADC2, PHASE_B_CHANNEL,1,
    785                          //                                     SAMPLING_TIME_CK);                                    
    786          				ADC2->JSQR = PHASE_B_MSK + TEMP_FDBK_MSK + SEQUENCE_LENGHT;
    787                          break;  
    788              
    789              case SECTOR_5:
    790                          hTimePhA = (T/8) + ((((T + wY) - wZ)/2)/131072);
    791          				hTimePhB = hTimePhA + wZ/131072;
    792          				hTimePhC = hTimePhA - wY/131072;
    793                          
    794                          // ADC Syncronization setting value
    795                          if ((u16)(PWM_PERIOD-hTimePhC) > TW_AFTER)
    796                          {
    797                            hTimePhD = PWM_PERIOD - 1;
    798                          }
    799                          else
    800                          {
    801                            hDeltaDuty = (u16)(hTimePhC - hTimePhA);
    802                            
    803                            // Definition of crossing point
    804                            if (hDeltaDuty > (u16)(PWM_PERIOD-hTimePhC)*2) 
    805                            {
    806                              hTimePhD = hTimePhC - TW_BEFORE; // Ts before Phase C 
    807                            }
    808                            else
    809                            {
    810                              hTimePhD = hTimePhC + TW_AFTER; // DT + Tn after Phase C
    811                              
    812                              if (hTimePhD >= PWM_PERIOD)
    813                              {
    814                                // Trigger of ADC at Falling Edge PWM4
    815                                // OCR update
    816                                
    817                                //Set Polarity of CC4 Low
    818                                PWM4Direction=PWM1_MODE;
    819                                
    820                                hTimePhD = (2 * PWM_PERIOD) - hTimePhD-1;
    821                              }
    822                            }
    823                          }
    824                          
    825                          //ADC_InjectedChannelConfig(ADC1, PHASE_A_CHANNEL,1,
    826                          //                                   SAMPLING_TIME_CK);              
    827                          ADC1->JSQR = PHASE_A_MSK + BUS_VOLT_FDBK_MSK + SEQUENCE_LENGHT;                
    828                          //ADC_InjectedChannelConfig(ADC2, PHASE_B_CHANNEL,1,
    829                          //                                     SAMPLING_TIME_CK);                                      
    830          				ADC2->JSQR = PHASE_B_MSK + TEMP_FDBK_MSK + SEQUENCE_LENGHT;
    831          		break;
    832                          
    833              case SECTOR_6:
    834                          hTimePhA = (T/8) + ((((T - wX) + wY)/2)/131072);
    835          				hTimePhC = hTimePhA - wY/131072;
    836          				hTimePhB = hTimePhC + wX/131072;
    837                          
    838                          // ADC Syncronization setting value
    839                          if ((u16)(PWM_PERIOD-hTimePhA) > TW_AFTER)
    840                          {
    841                            hTimePhD = PWM_PERIOD - 1;
    842                          }
    843                          else
    844                          {
    845                            hDeltaDuty = (u16)(hTimePhA - hTimePhC);
    846                            
    847                            // Definition of crossing point
    848                            if (hDeltaDuty > (u16)(PWM_PERIOD-hTimePhA)*2) 
    849                            {
    850                              hTimePhD = hTimePhA - TW_BEFORE; // Ts before Phase A 
    851                            }
    852                            else
    853                            {
    854                              hTimePhD = hTimePhA + TW_AFTER; // DT + Tn after Phase A
   \                     ??SVPWM_3ShuntCalcDutyCycles_7:
   \   000000D2   0xF100 0x03F1      ADD      R3,R0,#+241
   \   000000D6   0xB29B             UXTH     R3,R3
    855                              
    856                              if (hTimePhD >= PWM_PERIOD)
   \   000000D8   0xF640 0x14C4      MOVW     R4,#+2500
   \   000000DC   0x42A3             CMP      R3,R4
   \   000000DE   0xDB04             BLT.N    ??SVPWM_3ShuntCalcDutyCycles_8
    857                              {
    858                                // Trigger of ADC at Falling Edge PWM4
    859                                // OCR update
    860                                
    861                                //Set Polarity of CC4 Low
    862                                PWM4Direction=PWM1_MODE;
   \   000000E0   0x2601             MOVS     R6,#+1
    863                                
    864                                hTimePhD = (2 * PWM_PERIOD) - hTimePhD-1;
   \   000000E2   0xF241 0x3487      MOVW     R4,#+4999
   \   000000E6   0x1AE3             SUBS     R3,R4,R3
   \                     ??SVPWM_3ShuntCalcDutyCycles_9:
   \   000000E8   0xB29B             UXTH     R3,R3
    865                              }
    866                            }
    867                          }
    868                          
    869                          //ADC_InjectedChannelConfig(ADC1, PHASE_B_CHANNEL,1,
    870                          //                                    SAMPLING_TIME_CK);     
    871                          ADC1->JSQR = PHASE_B_MSK + BUS_VOLT_FDBK_MSK + SEQUENCE_LENGHT;                
   \                     ??SVPWM_3ShuntCalcDutyCycles_8:
   \   000000EA   0x....             LDR.N    R4,??DataTable6_11  ;; 0x40012438
   \   000000EC   0x....             LDR.N    R7,??DataTable6_12  ;; 0x11b000
   \                     ??SVPWM_3ShuntCalcDutyCycles_10:
   \   000000EE   0x6027             STR      R7,[R4, #+0]
    872                          //ADC_InjectedChannelConfig(ADC2, PHASE_C_CHANNEL,1,
    873                          //                                    SAMPLING_TIME_CK);                               
    874          				ADC2->JSQR = PHASE_C_MSK + TEMP_FDBK_MSK + SEQUENCE_LENGHT;
   \   000000F0   0x....             LDR.N    R7,??DataTable6_13  ;; 0x153400
   \                     ??SVPWM_3ShuntCalcDutyCycles_11:
   \   000000F2   0xF8C4 0x7400      STR      R7,[R4, #+1024]
    875                          break;
   \                     ??SVPWM_3ShuntCalcDutyCycles_3:
   \   000000F6   0x706E             STRB     R6,[R5, #+1]
    876              default:
    877          		break;
    878             }
    879            
    880            if (PWM4Direction == PWM2_MODE)
   \   000000F8   0x....             LDR.N    R4,??DataTable6_11  ;; 0x40012438
   \   000000FA   0x786D             LDRB     R5,[R5, #+1]
   \   000000FC   0x07ED             LSLS     R5,R5,#+31
   \   000000FE   0xF8B4 0x57E8      LDRH     R5,[R4, #+2024]
   \   00000102   0xBF5A             ITTE     PL 
   \   00000104   0xF64D 0x76FF      MOVWPL   R6,#+57343
   \   00000108   0x4035             ANDPL    R5,R6,R5
   \   0000010A   0xF445 0x5500      ORRMI    R5,R5,#0x2000
    881            {
    882              //Set Polarity of CC4 High
    883              TIM1->CCER &= 0xDFFF;    
   \   0000010E   0xE0F3             B.N      ??SVPWM_3ShuntCalcDutyCycles_12
    884            }
   \                     ??SVPWM_3ShuntCalcDutyCycles_13:
   \   00000110   0xF507 0x501C      ADD      R0,R7,#+9984
   \   00000114   0x3010             ADDS     R0,R0,#+16
   \   00000116   0xEBA0 0x000E      SUB      R0,R0,LR
   \   0000011A   0xEB00 0x70D0      ADD      R0,R0,R0, LSR #+31
   \   0000011E   0x1040             ASRS     R0,R0,#+1
   \   00000120   0x1401             ASRS     R1,R0,#+16
   \   00000122   0xEB00 0x30D1      ADD      R0,R0,R1, LSR #+15
   \   00000126   0x1440             ASRS     R0,R0,#+17
   \   00000128   0xF200 0x40E2      ADDW     R0,R0,#+1250
   \   0000012C   0xB280             UXTH     R0,R0
   \   0000012E   0xEA4F 0x412E      ASR      R1,LR,#+16
   \   00000132   0xEB0E 0x31D1      ADD      R1,LR,R1, LSR #+15
   \   00000136   0xEB00 0x4161      ADD      R1,R0,R1, ASR #+17
   \   0000013A   0xB289             UXTH     R1,R1
   \   0000013C   0x143A             ASRS     R2,R7,#+16
   \   0000013E   0xEB07 0x32D2      ADD      R2,R7,R2, LSR #+15
   \   00000142   0xEBA0 0x4262      SUB      R2,R0,R2, ASR #+17
   \   00000146   0xB292             UXTH     R2,R2
   \   00000148   0xF640 0x13C4      MOVW     R3,#+2500
   \   0000014C   0x1A5B             SUBS     R3,R3,R1
   \   0000014E   0xB29B             UXTH     R3,R3
   \   00000150   0x2BF2             CMP      R3,#+242
   \   00000152   0xD233             BCS.N    ??SVPWM_3ShuntCalcDutyCycles_14
   \   00000154   0x005B             LSLS     R3,R3,#+1
   \   00000156   0x1A0C             SUBS     R4,R1,R0
   \   00000158   0xB2A4             UXTH     R4,R4
   \   0000015A   0x42A3             CMP      R3,R4
   \   0000015C   0xDB38             BLT.N    ??SVPWM_3ShuntCalcDutyCycles_15
   \                     ??SVPWM_3ShuntCalcDutyCycles_16:
   \   0000015E   0xF101 0x03F1      ADD      R3,R1,#+241
   \   00000162   0xB29B             UXTH     R3,R3
   \   00000164   0xF640 0x14C4      MOVW     R4,#+2500
   \   00000168   0x42A3             CMP      R3,R4
   \   0000016A   0xDB04             BLT.N    ??SVPWM_3ShuntCalcDutyCycles_17
   \   0000016C   0x2601             MOVS     R6,#+1
   \   0000016E   0xF241 0x3487      MOVW     R4,#+4999
   \   00000172   0x1AE3             SUBS     R3,R4,R3
   \                     ??SVPWM_3ShuntCalcDutyCycles_18:
   \   00000174   0xB29B             UXTH     R3,R3
   \                     ??SVPWM_3ShuntCalcDutyCycles_17:
   \   00000176   0x....             LDR.N    R4,??DataTable6_11  ;; 0x40012438
   \   00000178   0x....             LDR.N    R7,??DataTable6_14  ;; 0x11ac00
   \   0000017A   0xE7B8             B.N      ??SVPWM_3ShuntCalcDutyCycles_10
   \                     ??SVPWM_3ShuntCalcDutyCycles_19:
   \   0000017C   0xF242 0x7010      MOVW     R0,#+10000
   \   00000180   0x1B00             SUBS     R0,R0,R4
   \   00000182   0x1838             ADDS     R0,R7,R0
   \   00000184   0xEB00 0x70D0      ADD      R0,R0,R0, LSR #+31
   \   00000188   0x1040             ASRS     R0,R0,#+1
   \   0000018A   0x1401             ASRS     R1,R0,#+16
   \   0000018C   0xEB00 0x30D1      ADD      R0,R0,R1, LSR #+15
   \   00000190   0x1440             ASRS     R0,R0,#+17
   \   00000192   0xF200 0x40E2      ADDW     R0,R0,#+1250
   \   00000196   0xB280             UXTH     R0,R0
   \   00000198   0x1439             ASRS     R1,R7,#+16
   \   0000019A   0xEB07 0x31D1      ADD      R1,R7,R1, LSR #+15
   \   0000019E   0xEBA0 0x4261      SUB      R2,R0,R1, ASR #+17
   \   000001A2   0xB292             UXTH     R2,R2
   \   000001A4   0x1421             ASRS     R1,R4,#+16
   \   000001A6   0xEB04 0x31D1      ADD      R1,R4,R1, LSR #+15
   \   000001AA   0xEB02 0x4161      ADD      R1,R2,R1, ASR #+17
   \   000001AE   0xB289             UXTH     R1,R1
   \   000001B0   0xF640 0x13C4      MOVW     R3,#+2500
   \   000001B4   0x1A5B             SUBS     R3,R3,R1
   \   000001B6   0xB29B             UXTH     R3,R3
   \   000001B8   0x2BF2             CMP      R3,#+242
   \   000001BA   0xD304             BCC.N    ??SVPWM_3ShuntCalcDutyCycles_20
   \                     ??SVPWM_3ShuntCalcDutyCycles_14:
   \   000001BC   0xF640 0x13C3      MOVW     R3,#+2499
   \   000001C0   0x....             LDR.N    R4,??DataTable6_11  ;; 0x40012438
   \   000001C2   0x....             LDR.N    R7,??DataTable6_14  ;; 0x11ac00
   \   000001C4   0xE793             B.N      ??SVPWM_3ShuntCalcDutyCycles_10
   \                     ??SVPWM_3ShuntCalcDutyCycles_20:
   \   000001C6   0x005B             LSLS     R3,R3,#+1
   \   000001C8   0x1A8C             SUBS     R4,R1,R2
   \   000001CA   0xB2A4             UXTH     R4,R4
   \   000001CC   0x42A3             CMP      R3,R4
   \   000001CE   0xDAC6             BGE.N    ??SVPWM_3ShuntCalcDutyCycles_16
   \                     ??SVPWM_3ShuntCalcDutyCycles_15:
   \   000001D0   0x460B             MOV      R3,R1
   \   000001D2   0x3B33             SUBS     R3,R3,#+51
   \   000001D4   0xE7CE             B.N      ??SVPWM_3ShuntCalcDutyCycles_18
   \                     ??SVPWM_3ShuntCalcDutyCycles_21:
   \   000001D6   0xF504 0x501C      ADD      R0,R4,#+9984
   \   000001DA   0x3010             ADDS     R0,R0,#+16
   \   000001DC   0xEBA0 0x000E      SUB      R0,R0,LR
   \   000001E0   0xEB00 0x70D0      ADD      R0,R0,R0, LSR #+31
   \   000001E4   0x1040             ASRS     R0,R0,#+1
   \   000001E6   0x1401             ASRS     R1,R0,#+16
   \   000001E8   0xEB00 0x30D1      ADD      R0,R0,R1, LSR #+15
   \   000001EC   0x1440             ASRS     R0,R0,#+17
   \   000001EE   0xF200 0x40E2      ADDW     R0,R0,#+1250
   \   000001F2   0xB280             UXTH     R0,R0
   \   000001F4   0xEA4F 0x412E      ASR      R1,LR,#+16
   \   000001F8   0xEB0E 0x31D1      ADD      R1,LR,R1, LSR #+15
   \   000001FC   0xEB00 0x4161      ADD      R1,R0,R1, ASR #+17
   \   00000200   0xB289             UXTH     R1,R1
   \   00000202   0x1422             ASRS     R2,R4,#+16
   \   00000204   0xEB04 0x32D2      ADD      R2,R4,R2, LSR #+15
   \   00000208   0xEBA1 0x4262      SUB      R2,R1,R2, ASR #+17
   \   0000020C   0xB292             UXTH     R2,R2
   \   0000020E   0xF640 0x13C4      MOVW     R3,#+2500
   \   00000212   0x1A9B             SUBS     R3,R3,R2
   \   00000214   0xB29B             UXTH     R3,R3
   \   00000216   0x2BF2             CMP      R3,#+242
   \   00000218   0xD237             BCS.N    ??SVPWM_3ShuntCalcDutyCycles_22
   \   0000021A   0x005B             LSLS     R3,R3,#+1
   \   0000021C   0x1A54             SUBS     R4,R2,R1
   \   0000021E   0xB2A4             UXTH     R4,R4
   \   00000220   0x42A3             CMP      R3,R4
   \   00000222   0xDB3A             BLT.N    ??SVPWM_3ShuntCalcDutyCycles_23
   \                     ??SVPWM_3ShuntCalcDutyCycles_24:
   \   00000224   0xF102 0x03F1      ADD      R3,R2,#+241
   \   00000228   0xB29B             UXTH     R3,R3
   \   0000022A   0xF640 0x14C4      MOVW     R4,#+2500
   \   0000022E   0x42A3             CMP      R3,R4
   \   00000230   0xDB04             BLT.N    ??SVPWM_3ShuntCalcDutyCycles_25
   \   00000232   0x2601             MOVS     R6,#+1
   \   00000234   0xF241 0x3487      MOVW     R4,#+4999
   \   00000238   0x1AE3             SUBS     R3,R4,R3
   \                     ??SVPWM_3ShuntCalcDutyCycles_26:
   \   0000023A   0xB29B             UXTH     R3,R3
   \                     ??SVPWM_3ShuntCalcDutyCycles_25:
   \   0000023C   0x....             LDR.N    R4,??DataTable6_11  ;; 0x40012438
   \   0000023E   0x....             LDR.N    R7,??DataTable6_14  ;; 0x11ac00
   \   00000240   0x6027             STR      R7,[R4, #+0]
   \   00000242   0x....             LDR.N    R7,??DataTable6_15  ;; 0x153000
   \   00000244   0xE755             B.N      ??SVPWM_3ShuntCalcDutyCycles_11
   \                     ??SVPWM_3ShuntCalcDutyCycles_27:
   \   00000246   0xF507 0x501C      ADD      R0,R7,#+9984
   \   0000024A   0x3010             ADDS     R0,R0,#+16
   \   0000024C   0xEBA0 0x000E      SUB      R0,R0,LR
   \   00000250   0xEB00 0x70D0      ADD      R0,R0,R0, LSR #+31
   \   00000254   0x1040             ASRS     R0,R0,#+1
   \   00000256   0x1401             ASRS     R1,R0,#+16
   \   00000258   0xEB00 0x30D1      ADD      R0,R0,R1, LSR #+15
   \   0000025C   0x1440             ASRS     R0,R0,#+17
   \   0000025E   0xF200 0x40E2      ADDW     R0,R0,#+1250
   \   00000262   0xB280             UXTH     R0,R0
   \   00000264   0xEA4F 0x412E      ASR      R1,LR,#+16
   \   00000268   0xEB0E 0x31D1      ADD      R1,LR,R1, LSR #+15
   \   0000026C   0xEB00 0x4161      ADD      R1,R0,R1, ASR #+17
   \   00000270   0xB289             UXTH     R1,R1
   \   00000272   0x143A             ASRS     R2,R7,#+16
   \   00000274   0xEB07 0x32D2      ADD      R2,R7,R2, LSR #+15
   \   00000278   0xEBA0 0x4262      SUB      R2,R0,R2, ASR #+17
   \   0000027C   0xB292             UXTH     R2,R2
   \   0000027E   0xF640 0x13C4      MOVW     R3,#+2500
   \   00000282   0x1A9B             SUBS     R3,R3,R2
   \   00000284   0xB29B             UXTH     R3,R3
   \   00000286   0x2BF2             CMP      R3,#+242
   \   00000288   0xD302             BCC.N    ??SVPWM_3ShuntCalcDutyCycles_28
   \                     ??SVPWM_3ShuntCalcDutyCycles_22:
   \   0000028A   0xF640 0x13C3      MOVW     R3,#+2499
   \   0000028E   0xE7D5             B.N      ??SVPWM_3ShuntCalcDutyCycles_25
   \                     ??SVPWM_3ShuntCalcDutyCycles_28:
   \   00000290   0x005B             LSLS     R3,R3,#+1
   \   00000292   0x1A14             SUBS     R4,R2,R0
   \   00000294   0xB2A4             UXTH     R4,R4
   \   00000296   0x42A3             CMP      R3,R4
   \   00000298   0xDAC4             BGE.N    ??SVPWM_3ShuntCalcDutyCycles_24
   \                     ??SVPWM_3ShuntCalcDutyCycles_23:
   \   0000029A   0x4613             MOV      R3,R2
   \   0000029C   0x3B33             SUBS     R3,R3,#+51
   \   0000029E   0xE7CC             B.N      ??SVPWM_3ShuntCalcDutyCycles_26
   \                     ??SVPWM_3ShuntCalcDutyCycles_29:
   \   000002A0   0xF242 0x7010      MOVW     R0,#+10000
   \   000002A4   0x1B00             SUBS     R0,R0,R4
   \   000002A6   0x1838             ADDS     R0,R7,R0
   \   000002A8   0xEB00 0x70D0      ADD      R0,R0,R0, LSR #+31
   \   000002AC   0x1040             ASRS     R0,R0,#+1
   \   000002AE   0x1401             ASRS     R1,R0,#+16
   \   000002B0   0xEB00 0x30D1      ADD      R0,R0,R1, LSR #+15
   \   000002B4   0x1440             ASRS     R0,R0,#+17
   \   000002B6   0xF200 0x40E2      ADDW     R0,R0,#+1250
   \   000002BA   0xB280             UXTH     R0,R0
   \   000002BC   0x1439             ASRS     R1,R7,#+16
   \   000002BE   0xEB07 0x31D1      ADD      R1,R7,R1, LSR #+15
   \   000002C2   0xEBA0 0x4261      SUB      R2,R0,R1, ASR #+17
   \   000002C6   0xB292             UXTH     R2,R2
   \   000002C8   0x1421             ASRS     R1,R4,#+16
   \   000002CA   0xEB04 0x31D1      ADD      R1,R4,R1, LSR #+15
   \   000002CE   0xEB02 0x4161      ADD      R1,R2,R1, ASR #+17
   \   000002D2   0xB289             UXTH     R1,R1
   \   000002D4   0xF640 0x13C4      MOVW     R3,#+2500
   \   000002D8   0x1A1B             SUBS     R3,R3,R0
   \   000002DA   0xB29B             UXTH     R3,R3
   \   000002DC   0x2BF2             CMP      R3,#+242
   \   000002DE   0xD302             BCC.N    ??SVPWM_3ShuntCalcDutyCycles_30
   \                     ??SVPWM_3ShuntCalcDutyCycles_5:
   \   000002E0   0xF640 0x13C3      MOVW     R3,#+2499
   \   000002E4   0xE701             B.N      ??SVPWM_3ShuntCalcDutyCycles_8
   \                     ??SVPWM_3ShuntCalcDutyCycles_30:
   \   000002E6   0x005B             LSLS     R3,R3,#+1
   \   000002E8   0x1A84             SUBS     R4,R0,R2
   \   000002EA   0xB2A4             UXTH     R4,R4
   \   000002EC   0x42A3             CMP      R3,R4
   \   000002EE   0xF6BF 0xAEF0      BGE.W    ??SVPWM_3ShuntCalcDutyCycles_7
   \                     ??SVPWM_3ShuntCalcDutyCycles_6:
   \   000002F2   0x4603             MOV      R3,R0
   \   000002F4   0x3B33             SUBS     R3,R3,#+51
   \   000002F6   0xE6F7             B.N      ??SVPWM_3ShuntCalcDutyCycles_9
   \                     ??SVPWM_3ShuntCalcDutyCycles_12:
   \   000002F8   0xF8A4 0x57E8      STRH     R5,[R4, #+2024]
    885            else
    886            {
    887              //Set Polarity of CC4 Low
    888              TIM1->CCER |= 0x2000;
    889            }
    890            
    891            /* Load compare registers values */ 
    892            TIM1->CCR1 = hTimePhA;
   \   000002FC   0xF8A4 0x07FC      STRH     R0,[R4, #+2044]
    893            TIM1->CCR2 = hTimePhB;
   \   00000300   0xF8A4 0x1800      STRH     R1,[R4, #+2048]
    894            TIM1->CCR3 = hTimePhC;
   \   00000304   0xF8A4 0x2804      STRH     R2,[R4, #+2052]
    895            TIM1->CCR4 = hTimePhD; // To Syncronyze the ADC
   \   00000308   0xF8A4 0x3808      STRH     R3,[R4, #+2056]
    896          }
   \   0000030C   0xB001             ADD      SP,SP,#+4
   \   0000030E   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    897          
    898          /*******************************************************************************
    899          * Function Name  : SVPWM_3ShuntAdvCurrentReading
    900          * Description    :  It is used to enable or disable the advanced current reading.
    901          			if disabled the current readign will be performed after update event
    902          * Input          : cmd (ENABLE or DISABLE)
    903          * Output         : None
    904          * Return         : None
    905          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    906          void SVPWM_3ShuntAdvCurrentReading(FunctionalState cmd)
    907          {
   \                     SVPWM_3ShuntAdvCurrentReading:
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
    908            if (cmd == ENABLE)
   \   00000004   0x....             LDR.N    R4,??DataTable6_2  ;; 0x40012c00
   \   00000006   0x....             LDR.N    R5,??DataTable6_16  ;; 0x40012408
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD10F             BNE.N    ??SVPWM_3ShuntAdvCurrentReading_0
    909            {
    910              // Enable ADC trigger sync with CC4
    911              //ADC_ExternalTrigInjectedConvConfig(ADC1, ADC_ExternalTrigInjecConv_T1_CC4);  
    912              ADC1->CR2 |= 0x00001000;
   \   0000000C   0x6828             LDR      R0,[R5, #+0]
   \   0000000E   0xF440 0x5080      ORR      R0,R0,#0x1000
   \   00000012   0x6028             STR      R0,[R5, #+0]
    913              
    914              // Enable UPDATE ISR
    915              // Clear Update Flag
    916              TIM_ClearFlag(TIM1, TIM_FLAG_Update);
   \   00000014   0x2101             MOVS     R1,#+1
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       TIM_ClearFlag
    917              TIM_ITConfig(TIM1, TIM_IT_Update, ENABLE);
   \   0000001C   0x2201             MOVS     R2,#+1
   \   0000001E   0x2101             MOVS     R1,#+1
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0xB001             ADD      SP,SP,#+4
   \   00000024   0xE8BD 0x4030      POP      {R4,R5,LR}
   \   00000028   0x.... 0x....      B.W      TIM_ITConfig
    918            }
    919            else
    920            {
    921              // Disable UPDATE ISR
    922              TIM_ITConfig(TIM1, TIM_IT_Update, DISABLE);
   \                     ??SVPWM_3ShuntAdvCurrentReading_0:
   \   0000002C   0x2200             MOVS     R2,#+0
   \   0000002E   0x2101             MOVS     R1,#+1
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0x.... 0x....      BL       TIM_ITConfig
    923          
    924              // Sync ADC trigger with Update
    925              //ADC_ExternalTrigInjectedConvConfig(ADC1, ADC_ExternalTrigInjecConv_T1_TRGO);
    926              ADC1->CR2 &=0xFFFFEFFF;
   \   00000036   0x6828             LDR      R0,[R5, #+0]
   \   00000038   0xF420 0x5080      BIC      R0,R0,#0x1000
   \   0000003C   0x6028             STR      R0,[R5, #+0]
    927              
    928              // ReEnable EXT. ADC Triggering
    929              ADC1->CR2 |=0x00008000;    
   \   0000003E   0x6828             LDR      R0,[R5, #+0]
   \   00000040   0xF440 0x4000      ORR      R0,R0,#0x8000
   \   00000044   0x6028             STR      R0,[R5, #+0]
    930            }
    931          }
   \   00000046   0xB001             ADD      SP,SP,#+4
   \   00000048   0xBD30             POP      {R4,R5,PC}       ;; return
    932          
    933          /*******************************************************************************
    934          * Function Name  : SVPWMUpdateEvent
    935          * Description    :  Routine to be performed inside the update event ISR  it reenable the ext adc. triggering
    936          		        It must be assigned to pSVPWM_UpdateEvent pointer.	
    937          * Input           : None
    938          * Output         : None
    939          * Return         : None
    940          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    941          void SVPWMUpdateEvent(void)
    942          {
    943            // ReEnable EXT. ADC Triggering
    944            ADC1->CR2 |= 0x00008000;
   \                     SVPWMUpdateEvent:
   \   00000000   0x....             LDR.N    R0,??DataTable6_5  ;; 0x40012400
   \   00000002   0x6881             LDR      R1,[R0, #+8]
   \   00000004   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   00000008   0x6081             STR      R1,[R0, #+8]
    945            
    946            // Clear unwanted current sampling
    947            ADC_ClearFlag(ADC1, ADC_FLAG_JEOC);
   \   0000000A   0x2104             MOVS     R1,#+4
   \   0000000C   0x.... 0x....      B.W      ADC_ClearFlag
    948          }
    949          
    950          /*******************************************************************************
    951          * Function Name  : SVPWMEOCEvent
    952          * Description    :  Routine to be performed inside the end of conversion ISR
    953          		         It computes the bus voltage and temperature sensor sampling 
    954          		        and disable the ext. adc triggering.	
    955          * Input           : None
    956          * Output         : None
    957          * Return         : None
    958          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    959          u8 SVPWMEOCEvent(void)
    960          {
   \                     SVPWMEOCEvent:
   \   00000000   0xB510             PUSH     {R4,LR}
    961            // Store the Bus Voltage and temperature sampled values
    962            h_ADCTemp = ADC_GetInjectedConversionValue(ADC2,ADC_InjectedChannel_2);
   \   00000002   0x2118             MOVS     R1,#+24
   \   00000004   0x....             LDR.N    R0,??DataTable6_6  ;; 0x40012800
   \   00000006   0x.... 0x....      BL       ADC_GetInjectedConversionValue
   \   0000000A   0x....             LDR.N    R1,??DataTable6_17
   \   0000000C   0x8008             STRH     R0,[R1, #+0]
    963            h_ADCBusvolt = ADC_GetInjectedConversionValue(ADC1,ADC_InjectedChannel_2);
   \   0000000E   0x....             LDR.N    R4,??DataTable6_5  ;; 0x40012400
   \   00000010   0x2118             MOVS     R1,#+24
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0x.... 0x....      BL       ADC_GetInjectedConversionValue
   \   00000018   0x....             LDR.N    R1,??DataTable6_18
   \   0000001A   0x8008             STRH     R0,[R1, #+0]
    964              
    965            if ((State == START) || (State == RUN))
   \   0000001C   0x....             LDR.N    R0,??DataTable6_19
   \   0000001E   0x7801             LDRB     R1,[R0, #+0]
   \   00000020   0x2902             CMP      R1,#+2
   \   00000022   0xBF1C             ITT      NE 
   \   00000024   0x7800             LDRBNE   R0,[R0, #+0]
   \   00000026   0x2803             CMPNE    R0,#+3
   \   00000028   0xD103             BNE.N    ??SVPWMEOCEvent_0
    966            {          
    967              // Disable EXT. ADC Triggering
    968              ADC1->CR2 = ADC1->CR2 & 0xFFFF7FFF;
   \   0000002A   0x68A0             LDR      R0,[R4, #+8]
   \   0000002C   0xF420 0x4000      BIC      R0,R0,#0x8000
   \   00000030   0x60A0             STR      R0,[R4, #+8]
    969            }
    970            return ((u8)(1));
   \                     ??SVPWMEOCEvent_0:
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0xBD10             POP      {R4,PC}          ;; return
    971          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x40011000         DC32     0x40011000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0x40010800         DC32     0x40010800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   0x40012C00         DC32     0x40012c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \   00000000   0x001600C0         DC32     0x1600c0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_4:
   \   00000000   0x40011800         DC32     0x40011800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_5:
   \   00000000   0x40012400         DC32     0x40012400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_6:
   \   00000000   0x40012800         DC32     0x40012800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_7:
   \   00000000   0x........         DC32     bSector

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_8:
   \   00000000   0x00400200         DC32     0x400200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_9:
   \   00000000   0x4001243C         DC32     0x4001243c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_10:
   \   00000000   0xFFFFD8F0         DC32     0xffffd8f0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_11:
   \   00000000   0x40012438         DC32     0x40012438

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_12:
   \   00000000   0x0011B000         DC32     0x11b000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_13:
   \   00000000   0x00153400         DC32     0x153400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_14:
   \   00000000   0x0011AC00         DC32     0x11ac00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_15:
   \   00000000   0x00153000         DC32     0x153000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_16:
   \   00000000   0x40012408         DC32     0x40012408

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_17:
   \   00000000   0x........         DC32     h_ADCTemp

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_18:
   \   00000000   0x........         DC32     h_ADCBusvolt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_19:
   \   00000000   0x........         DC32     State
    972          
    973          #endif
    974          
    975          /******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/  

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        8  SVPWMEOCEvent
              8 -> ADC_GetInjectedConversionValue
        0  SVPWMUpdateEvent
              0 -> ADC_ClearFlag
       16  SVPWM_3ShuntAdvCurrentReading
             16 -> TIM_ClearFlag
              0 -> TIM_ITConfig
             16 -> TIM_ITConfig
       28  SVPWM_3ShuntCalcDutyCycles
       16  SVPWM_3ShuntCurrentReadingCalibration
             16 -> ADC_ClearFlag
             16 -> ADC_ExternalTrigInjectedConvCmd
             16 -> ADC_ExternalTrigInjectedConvConfig
             16 -> ADC_GetFlagStatus
             16 -> ADC_GetInjectedConversionValue
             16 -> ADC_ITConfig
             16 -> ADC_InjectedChannelConfig
             16 -> ADC_InjectedSequencerLengthConfig
             16 -> ADC_SoftwareStartInjectedConvCmd
              0 -> SVPWM_InjectedConvConfig
        4  SVPWM_3ShuntGetPhaseCurrentValues
       96  SVPWM_3ShuntInit
             96 -> ADC_Cmd
             96 -> ADC_DeInit
             96 -> ADC_GetCalibrationStatus
             96 -> ADC_Init
             96 -> ADC_InjectedChannelConfig
             96 -> ADC_InjectedSequencerLengthConfig
             96 -> ADC_StartCalibration
             96 -> ADC_StructInit
             96 -> GPIO_Init
             96 -> GPIO_PinLockConfig
             96 -> GPIO_PinRemapConfig
             96 -> GPIO_StructInit
             96 -> NVIC_Init
             96 -> NVIC_PriorityGroupConfig
             96 -> NVIC_StructInit
             96 -> RCC_ADCCLKConfig
             96 -> RCC_AHBPeriphClockCmd
             96 -> RCC_APB2PeriphClockCmd
             96 -> SVPWM_3ShuntCurrentReadingCalibration
             96 -> TIM_BDTRConfig
             96 -> TIM_ClearFlag
             96 -> TIM_ClearITPendingBit
             96 -> TIM_Cmd
             96 -> TIM_DeInit
             96 -> TIM_GenerateEvent
             96 -> TIM_ITConfig
             96 -> TIM_OC1Init
             96 -> TIM_OC1PreloadConfig
             96 -> TIM_OC2Init
             96 -> TIM_OC2PreloadConfig
             96 -> TIM_OC3Init
             96 -> TIM_OC3PreloadConfig
             96 -> TIM_OC4Init
             96 -> TIM_OC4PreloadConfig
             96 -> TIM_OCStructInit
             96 -> TIM_SelectOutputTrigger
             96 -> TIM_TimeBaseInit
             96 -> TIM_TimeBaseStructInit
       16  SVPWM_InjectedConvConfig
             16 -> ADC_AnalogWatchdogCmd
             16 -> ADC_AnalogWatchdogSingleChannelConfig
             16 -> ADC_AnalogWatchdogThresholdsConfig
             16 -> ADC_ExternalTrigInjectedConvCmd
             16 -> ADC_ExternalTrigInjectedConvConfig
              0 -> ADC_ITConfig
             16 -> ADC_InjectedChannelConfig
             16 -> ADC_InjectedSequencerLengthConfig


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_10
       4  ??DataTable6_11
       4  ??DataTable6_12
       4  ??DataTable6_13
       4  ??DataTable6_14
       4  ??DataTable6_15
       4  ??DataTable6_16
       4  ??DataTable6_17
       4  ??DataTable6_18
       4  ??DataTable6_19
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
       4  ??DataTable6_7
       4  ??DataTable6_8
       4  ??DataTable6_9
      54  SVPWMEOCEvent
      16  SVPWMUpdateEvent
      74  SVPWM_3ShuntAdvCurrentReading
     786  SVPWM_3ShuntCalcDutyCycles
     208  SVPWM_3ShuntCurrentReadingCalibration
     144  SVPWM_3ShuntGetPhaseCurrentValues
     820  SVPWM_3ShuntInit
     116  SVPWM_InjectedConvConfig
      10  bSector
          PWM4Direction
          hPhaseAOffset
          hPhaseBOffset
          hPhaseCOffset
          bIndex

 
    10 bytes in section .bss
 2 298 bytes in section .text
 
 2 298 bytes of CODE memory
    10 bytes of DATA memory

Errors: none
Warnings: 4
