###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     04/Nov/2013  13:19:55 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\st\stm32 foc firwmare libraries                       #
#                    v2.0\STM32_FOC_PMSM\src\MC_FOC_Drive.c                   #
#    Command line =  "D:\st\stm32 foc firwmare libraries                      #
#                    v2.0\STM32_FOC_PMSM\src\MC_FOC_Drive.c" -D               #
#                    VECT_TAB_FLASH -lCN "D:\st\stm32 foc firwmare libraries  #
#                    v2.0\STM32_FOC_PMSM\EWARM\Debug\List\" --diag_error      #
#                    Pe068,Pe069 -o "D:\st\stm32 foc firwmare libraries       #
#                    v2.0\STM32_FOC_PMSM\EWARM\Debug\Obj\" --debug            #
#                    --endian=little --cpu=Cortex-M3 --fpu=None               #
#                    --dlib_config D:\IAR\arm\INC\c\DLib_Config_Normal.h -I   #
#                    "D:\st\stm32 foc firwmare libraries                      #
#                    v2.0\STM32_FOC_PMSM\EWARM\..\" -I "D:\st\stm32 foc       #
#                    firwmare libraries v2.0\STM32_FOC_PMSM\EWARM\..\..\STM32 #
#                    F10XFWLIB\inc\" -I "D:\st\stm32 foc firwmare libraries   #
#                    v2.0\STM32_FOC_PMSM\EWARM\..\inc\" -Ohs                  #
#                    --use_c++_inline --require_prototypes                    #
#    List file    =  D:\st\stm32 foc firwmare libraries                       #
#                    v2.0\STM32_FOC_PMSM\EWARM\Debug\List\MC_FOC_Drive.lst    #
#    Object file  =  D:\st\stm32 foc firwmare libraries                       #
#                    v2.0\STM32_FOC_PMSM\EWARM\Debug\Obj\MC_FOC_Drive.o       #
#                                                                             #
#                                                                             #
###############################################################################

D:\st\stm32 foc firwmare libraries v2.0\STM32_FOC_PMSM\src\MC_FOC_Drive.c
      1          /******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
      2          * File Name          : MC_FOC_Drive.c
      3          * Author             : IMS Systems Lab 
      4          * Date First Issued  : 21/11/07
      5          * Description        : This file provides all the PMSM FOC drive functions.
      6          * 
      7          ********************************************************************************
      8          * History:
      9          * 21/11/07 v1.0
     10          * 29/05/08 v2.0
     11          * 14/07/08 v2.0.1
     12          * 28/08/08 v2.0.2
     13          * 04/09/08 v2.0.3
     14          ********************************************************************************
     15          * THE PRESENT SOFTWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     16          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
     17          * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
     18          * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
     19          * CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
     20          * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     21          *
     22          * THIS SOURCE CODE IS PROTECTED BY A LICENSE.
     23          * FOR MORE INFORMATION PLEASE CAREFULLY READ THE LICENSE AGREEMENT FILE LOCATED
     24          * IN THE ROOT DIRECTORY OF THIS FIRMWARE PACKAGE.
     25          *******************************************************************************/
     26          
     27          /* Includes ------------------------------------------------------------------*/
     28          #include "stm32f10x_lib.h"
     29          #include "stm32f10x_MClib.h"
     30          #include "MC_Globals.h"
     31          #include "MC_const.h"
     32          #include "MC_FOC_Drive.h"
     33          #include "MC_PMSM_motor_param.h"
     34          
     35          /* Private typedef -----------------------------------------------------------*/
     36          /* Private define ------------------------------------------------------------*/
     37          #define FW_KDDIV        1
     38          #define FW_KD_GAIN      0
     39          #define FW_D_TERM_INIT  0
     40          #define VOLTAGE_SAMPLING_BUFFER 128
     41          /* Private macro -------------------------------------------------------------*/
     42          #define SATURATION_TO_S16(a)    if (a > S16_MAX)              \
     43                                          {                             \
     44                                            a = S16_MAX;                \
     45                                          }                             \
     46                                          else if (a < -S16_MAX)        \
     47                                          {                             \
     48                                            a = -S16_MAX;               \
     49                                          }                             \
     50          /* Private functions ---------------------------------------------------------*/
     51          /* Private variable ----------------------------------------------------------*/

   \                                 In section .bss, align 4
     52          static volatile Curr_Components Stat_Curr_q_d_ref;
   \                     Stat_Curr_q_d_ref:
   \   00000000                      DS8 4

   \                                 In section .data, align 4
     53          static Curr_Components Stat_Curr_q_d_ref_ref;
     54          
     55          #ifdef FEED_FORWARD_CURRENT_REGULATION
     56          static Volt_Components Stat_Volt_q_d_3;
     57          static Volt_Components Stat_Volt_q_d_2;
     58          #endif
     59          
     60          #ifdef FLUX_WEAKENING
     61          static Volt_Components Stat_Volt_q_d_1;
   \                     Stat_Volt_q_d_1:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000004   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
     62          s16 hFW_V_Ref = FW_VOLTAGE_REF;
   \                     hFW_V_Ref:
   \   00000008   0x03D9             DC16 985
     63          s16 hFW_P_Gain = FW_KP_GAIN;
   \                     hFW_P_Gain:
   \   0000000A   0x0BB8             DC16 3000
     64          s16 hFW_I_Gain = FW_KI_GAIN;
   \                     hFW_I_Gain:
   \   0000000C   0x1388             DC16 5000
     65          s16 hVMagn = 0;
   \                     hVMagn:
   \   0000000E   0x0000             DC16 0
     66          #endif
     67          
     68          /*******************************************************************************
     69          * Function Name : FOC_Init
     70          * Description   : The purpose of this function is to initialize to proper values
     71          *                 all the variables related to the field-oriented control
     72          *                 algorithm. To be called once prior to every motor startup.
     73          * Input         : None.
     74          * Output        : None.
     75          * Return        : None.
     76          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     77          void FOC_Init (void)
     78          {
   \                     FOC_Init:
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
     79          #ifdef FLUX_WEAKENING  
     80            FOC_FluxRegulatorInterface_Init();
   \   00000004   0x.... 0x....      BL       FOC_FluxRegulatorInterface_Init
     81            
     82            Stat_Volt_q_d_1.qV_Component1 = 0;
   \   00000008   0x....             LDR.N    R0,??DataTable4
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x6001             STR      R1,[R0, #+0]
     83            Stat_Volt_q_d_1.qV_Component2 = 0;
     84          
     85            hVMagn = 0;
   \   0000000E   0x81C1             STRH     R1,[R0, #+14]
     86          #endif
     87          
     88          #ifdef IPMSM_MTPA
     89            FOC_MTPAInterface_Init();
     90          #endif  
     91            
     92          #ifdef FEED_FORWARD_CURRENT_REGULATION  
     93            Stat_Volt_q_d_3.qV_Component1 = 0;
     94            Stat_Volt_q_d_3.qV_Component2 = 0; 
     95            Stat_Volt_q_d_2.qV_Component1 = 0;
     96            Stat_Volt_q_d_2.qV_Component2 = 0;
     97            FOC_FF_CurrReg_Init(CONSTANT1_Q,CONSTANT1_D,CONSTANT2);  
     98          #endif
     99            
    100            Stat_Curr_q_d_ref_ref.qI_Component1 = 0;
   \   00000010   0x6041             STR      R1,[R0, #+4]
    101            Stat_Curr_q_d_ref_ref.qI_Component2 = 0;  
    102            
    103            Stat_Curr_q_d_ref.qI_Component1 = 0;
   \   00000012   0x....             LDR.N    R0,??DataTable4_1
   \   00000014   0x8001             STRH     R1,[R0, #+0]
    104            Stat_Curr_q_d_ref.qI_Component2 = 0;
   \   00000016   0x8041             STRH     R1,[R0, #+2]
    105          }
   \   00000018   0xB001             ADD      SP,SP,#+4
   \   0000001A   0xBD00             POP      {PC}             ;; return
    106          
    107          /*******************************************************************************
    108          * Function Name : FOC_Model
    109          * Description   : The purpose of this function is to perform PMSM torque and 
    110          *                 flux regulation, implementing the FOC vector algorithm.
    111          * Input         : None.
    112          * Output        : None.
    113          * Return        : None.
    114          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    115          void FOC_Model(void)
    116          {
   \                     FOC_Model:
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    117          #ifdef FEED_FORWARD_CURRENT_REGULATION  
    118            Volt_Components Stat_Volt_q_d_4;
    119            s32 wtemp;
    120          #endif
    121            
    122          #if defined HALL_SENSORS
    123            //Integrate Speed for rotor angle update
    124            HALL_IncElectricalAngle();
    125          #endif    
    126            
    127            /**********STARTS THE VECTOR CONTROL ************************/  
    128           
    129            Stat_Curr_a_b = GET_PHASE_CURRENTS();
   \   00000004   0x.... 0x....      BL       SVPWM_3ShuntGetPhaseCurrentValues
   \   00000008   0x9000             STR      R0,[SP, #+0]
   \   0000000A   0x....             LDR.N    R0,??DataTable4_2
   \   0000000C   0xA900             ADD      R1,SP,#+0
   \   0000000E   0x880A             LDRH     R2,[R1, #0]
   \   00000010   0x8002             STRH     R2,[R0, #+0]
   \   00000012   0x884A             LDRH     R2,[R1, #+2]
   \   00000014   0x8042             STRH     R2,[R0, #+2]
   \   00000016   0x8802             LDRH     R2,[R0, #0]
   \   00000018   0x800A             STRH     R2,[R1, #+0]
   \   0000001A   0x8842             LDRH     R2,[R0, #+2]
   \   0000001C   0x804A             STRH     R2,[R1, #+2]
    130            
    131            Stat_Curr_alfa_beta = Clarke(Stat_Curr_a_b);
   \   0000001E   0x9800             LDR      R0,[SP, #+0]
   \   00000020   0x.... 0x....      BL       Clarke
   \   00000024   0x9001             STR      R0,[SP, #+4]
   \   00000026   0x....             LDR.N    R4,??DataTable4_3
   \   00000028   0xA801             ADD      R0,SP,#+4
   \   0000002A   0x8801             LDRH     R1,[R0, #0]
   \   0000002C   0x8021             STRH     R1,[R4, #+0]
   \   0000002E   0x8841             LDRH     R1,[R0, #+2]
   \   00000030   0x8061             STRH     R1,[R4, #+2]
    132            
    133            Stat_Curr_q_d = Park(Stat_Curr_alfa_beta,GET_ELECTRICAL_ANGLE);  
   \   00000032   0x.... 0x....      BL       STO_Get_Electrical_Angle
   \   00000036   0xA900             ADD      R1,SP,#+0
   \   00000038   0x8822             LDRH     R2,[R4, #0]
   \   0000003A   0x800A             STRH     R2,[R1, #+0]
   \   0000003C   0x8862             LDRH     R2,[R4, #+2]
   \   0000003E   0x804A             STRH     R2,[R1, #+2]
   \   00000040   0x4601             MOV      R1,R0
   \   00000042   0x9800             LDR      R0,[SP, #+0]
   \   00000044   0x.... 0x....      BL       Park
   \   00000048   0x9001             STR      R0,[SP, #+4]
   \   0000004A   0x....             LDR.N    R5,??DataTable4_4
   \   0000004C   0xA801             ADD      R0,SP,#+4
   \   0000004E   0x8801             LDRH     R1,[R0, #0]
   \   00000050   0x8029             STRH     R1,[R5, #+0]
   \   00000052   0x8841             LDRH     R1,[R0, #+2]
   \   00000054   0x8069             STRH     R1,[R5, #+2]
    134          
    135          #ifdef NO_SPEED_SENSORS  
    136            STO_Calc_Rotor_Angle(Stat_Volt_alfa_beta,Stat_Curr_alfa_beta,MCL_Get_BusVolt());
   \   00000056   0x.... 0x....      BL       MCL_Get_BusVolt
   \   0000005A   0x4602             MOV      R2,R0
   \   0000005C   0x....             LDR.N    R6,??DataTable4_5
   \   0000005E   0xA800             ADD      R0,SP,#+0
   \   00000060   0x8821             LDRH     R1,[R4, #0]
   \   00000062   0x8001             STRH     R1,[R0, #+0]
   \   00000064   0x8861             LDRH     R1,[R4, #+2]
   \   00000066   0x8041             STRH     R1,[R0, #+2]
   \   00000068   0xA801             ADD      R0,SP,#+4
   \   0000006A   0x8831             LDRH     R1,[R6, #0]
   \   0000006C   0x8001             STRH     R1,[R0, #+0]
   \   0000006E   0x8871             LDRH     R1,[R6, #+2]
   \   00000070   0x8041             STRH     R1,[R0, #+2]
   \   00000072   0x9900             LDR      R1,[SP, #+0]
   \   00000074   0x9801             LDR      R0,[SP, #+4]
   \   00000076   0x.... 0x....      BL       STO_Calc_Rotor_Angle
    137          #endif
    138          
    139          #ifdef FEED_FORWARD_CURRENT_REGULATION   
    140            /*loads the Torque Regulator output reference voltage Vqs*/   
    141            Stat_Volt_q_d_4.qV_Component1 = PID_Regulator(Stat_Curr_q_d_ref_ref.qI_Component1,
    142                                   Stat_Curr_q_d.qI_Component1,&PID_Torque_InitStructure);                                                   
    143          
    144            
    145            /*loads the Flux Regulator output reference voltage Vds*/
    146            Stat_Volt_q_d_4.qV_Component2 = PID_Regulator(Stat_Curr_q_d_ref_ref.qI_Component2,
    147                                   Stat_Curr_q_d.qI_Component2,&PID_Flux_InitStructure);  
    148          
    149           
    150            wtemp = (s32)(Stat_Volt_q_d_4.qV_Component1 + Stat_Volt_q_d_3.qV_Component1);
    151            
    152            SATURATION_TO_S16(wtemp);
    153            
    154            Stat_Volt_q_d.qV_Component1 = (s16)wtemp;  
    155          
    156            wtemp = (s32)(Stat_Volt_q_d_4.qV_Component2 + Stat_Volt_q_d_3.qV_Component2);
    157            
    158            SATURATION_TO_S16(wtemp);
    159            
    160            Stat_Volt_q_d.qV_Component2 = (s16)wtemp;
    161            
    162          #else
    163            /*loads the Torque Regulator output reference voltage Vqs*/   
    164            Stat_Volt_q_d.qV_Component1 = PID_Regulator(Stat_Curr_q_d_ref_ref.qI_Component1, 
    165                                  Stat_Curr_q_d.qI_Component1, &PID_Torque_InitStructure);
   \   0000007A   0x....             LDR.N    R7,??DataTable4_6
   \   0000007C   0x....             LDR.N    R4,??DataTable4
   \   0000007E   0x....             LDR.N    R2,??DataTable4_7
   \   00000080   0xF9B5 0x1000      LDRSH    R1,[R5, #+0]
   \   00000084   0xF9B4 0x0004      LDRSH    R0,[R4, #+4]
   \   00000088   0x.... 0x....      BL       PID_Regulator
   \   0000008C   0x8038             STRH     R0,[R7, #+0]
    166          
    167            
    168            /*loads the Flux Regulator output reference voltage Vds*/
    169            Stat_Volt_q_d.qV_Component2 = PID_Regulator(Stat_Curr_q_d_ref_ref.qI_Component2, 
    170                                    Stat_Curr_q_d.qI_Component2, &PID_Flux_InitStructure);  
   \   0000008E   0x....             LDR.N    R2,??DataTable4_8
   \   00000090   0xF9B5 0x1002      LDRSH    R1,[R5, #+2]
   \   00000094   0xF9B4 0x0006      LDRSH    R0,[R4, #+6]
   \   00000098   0x.... 0x....      BL       PID_Regulator
   \   0000009C   0x8078             STRH     R0,[R7, #+2]
    171          #endif
    172            
    173            //circle limitation
    174            RevPark_Circle_Limitation();
   \   0000009E   0x.... 0x....      BL       RevPark_Circle_Limitation
   \   000000A2   0xA801             ADD      R0,SP,#+4
   \   000000A4   0x8839             LDRH     R1,[R7, #0]
   \   000000A6   0x8001             STRH     R1,[R0, #+0]
   \   000000A8   0x8879             LDRH     R1,[R7, #+2]
   \   000000AA   0x8041             STRH     R1,[R0, #+2]
    175           
    176            /*Performs the Reverse Park transformation,
    177            i.e transforms stator voltages Vqs and Vds into Valpha and Vbeta on a 
    178            stationary reference frame*/
    179          
    180            Stat_Volt_alfa_beta = Rev_Park(Stat_Volt_q_d);
   \   000000AC   0x9801             LDR      R0,[SP, #+4]
   \   000000AE   0x.... 0x....      BL       Rev_Park
   \   000000B2   0x9000             STR      R0,[SP, #+0]
   \   000000B4   0xA800             ADD      R0,SP,#+0
   \   000000B6   0x8801             LDRH     R1,[R0, #0]
   \   000000B8   0x8031             STRH     R1,[R6, #+0]
   \   000000BA   0x8841             LDRH     R1,[R0, #+2]
   \   000000BC   0x8071             STRH     R1,[R6, #+2]
   \   000000BE   0x8831             LDRH     R1,[R6, #0]
   \   000000C0   0x8001             STRH     R1,[R0, #+0]
   \   000000C2   0x8871             LDRH     R1,[R6, #+2]
   \   000000C4   0x8041             STRH     R1,[R0, #+2]
    181          
    182            /*Valpha and Vbeta finally drive the power stage*/ 
    183            CALC_SVPWM(Stat_Volt_alfa_beta);
   \   000000C6   0x9800             LDR      R0,[SP, #+0]
   \   000000C8   0x.... 0x....      BL       SVPWM_3ShuntCalcDutyCycles
    184            
    185          #ifdef FEED_FORWARD_CURRENT_REGULATION  
    186            Stat_Volt_q_d_2.qV_Component1 = (s16)((Stat_Volt_q_d_2.qV_Component1*
    187                                            (VOLTAGE_SAMPLING_BUFFER-1)+
    188                                            Stat_Volt_q_d_4.qV_Component1)/
    189                                            VOLTAGE_SAMPLING_BUFFER);
    190            Stat_Volt_q_d_2.qV_Component2 = (s16)((Stat_Volt_q_d_2.qV_Component2*
    191                                            (VOLTAGE_SAMPLING_BUFFER-1)+
    192                                            Stat_Volt_q_d_4.qV_Component2)/
    193                                            VOLTAGE_SAMPLING_BUFFER);
    194          #endif 
    195          #ifdef FLUX_WEAKENING
    196            
    197            Stat_Volt_q_d_1.qV_Component1 = (s16)((Stat_Volt_q_d_1.qV_Component1*
    198                                            (VOLTAGE_SAMPLING_BUFFER-1)+
    199                                            Stat_Volt_q_d.qV_Component1)/
    200                                            VOLTAGE_SAMPLING_BUFFER);
   \   000000CC   0xF9B4 0x0000      LDRSH    R0,[R4, #+0]
   \   000000D0   0xEBC0 0x10C0      RSB      R0,R0,R0, LSL #+7
   \   000000D4   0xF9B7 0x1000      LDRSH    R1,[R7, #+0]
   \   000000D8   0x1808             ADDS     R0,R1,R0
   \   000000DA   0x1181             ASRS     R1,R0,#+6
   \   000000DC   0xEB00 0x6051      ADD      R0,R0,R1, LSR #+25
   \   000000E0   0x11C0             ASRS     R0,R0,#+7
   \   000000E2   0x8020             STRH     R0,[R4, #+0]
    201            Stat_Volt_q_d_1.qV_Component2 = (s16)((Stat_Volt_q_d_1.qV_Component2*
    202                                            (VOLTAGE_SAMPLING_BUFFER-1)+
    203                                            Stat_Volt_q_d.qV_Component2)/
    204                                            VOLTAGE_SAMPLING_BUFFER);
   \   000000E4   0xF9B4 0x0002      LDRSH    R0,[R4, #+2]
   \   000000E8   0xEBC0 0x10C0      RSB      R0,R0,R0, LSL #+7
   \   000000EC   0xF9B7 0x1002      LDRSH    R1,[R7, #+2]
   \   000000F0   0x1808             ADDS     R0,R1,R0
   \   000000F2   0x1181             ASRS     R1,R0,#+6
   \   000000F4   0xEB00 0x6051      ADD      R0,R0,R1, LSR #+25
   \   000000F8   0x11C0             ASRS     R0,R0,#+7
   \   000000FA   0x8060             STRH     R0,[R4, #+2]
    205          #endif  
    206          }
   \   000000FC   0xB003             ADD      SP,SP,#+12
   \   000000FE   0xBDF0             POP      {R4-R7,PC}       ;; return
    207          
    208          /*******************************************************************************
    209          * Function Name   : FOC_CalcFluxTorqueRef
    210          * Description     : This function provides current components Iqs* and Ids* to be
    211          *                   used as reference values (by the FOC_Model function) when in
    212          *                   speed control mode
    213          * Input           : None.
    214          * Output          : None.
    215          * Return          : None.
    216          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    217          void FOC_CalcFluxTorqueRef(void)
    218          {
   \                     FOC_CalcFluxTorqueRef:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
    219            Stat_Curr_q_d_ref.qI_Component1 = PID_Regulator(hSpeed_Reference,
    220                                              GET_SPEED_0_1HZ,&PID_Speed_InitStructure);
   \   00000004   0x.... 0x....      BL       STO_Get_Speed_Hz
   \   00000008   0x....             LDR.N    R4,??DataTable4_1
   \   0000000A   0x....             LDR.N    R5,??DataTable4_9
   \   0000000C   0x462A             MOV      R2,R5
   \   0000000E   0x4601             MOV      R1,R0
   \   00000010   0x....             LDR.N    R0,??DataTable4_10
   \   00000012   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000016   0x.... 0x....      BL       PID_Regulator
   \   0000001A   0x8020             STRH     R0,[R4, #+0]
    221          
    222          #ifdef IPMSM_MTPA  
    223            Stat_Curr_q_d_ref.qI_Component2 = FOC_MTPA(Stat_Curr_q_d_ref.qI_Component1);  
    224          #else
    225            Stat_Curr_q_d_ref.qI_Component2 = 0;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x8060             STRH     R0,[R4, #+2]
    226          #endif
    227          
    228          #ifdef FLUX_WEAKENING
    229            {
    230              s16 hVoltageLimit_Reference;
    231              
    232              Curr_Components Stat_Curr_q_d_temp;
    233              
    234              hVoltageLimit_Reference = (s16)((hFW_V_Ref*MAX_MODULE)/1000);
    235              
    236              Stat_Curr_q_d_temp = FOC_FluxRegulator(Stat_Curr_q_d_ref,Stat_Volt_q_d_1,
    237                                                     hVoltageLimit_Reference);
   \   00000020   0xA802             ADD      R0,SP,#+8
   \   00000022   0x8821             LDRH     R1,[R4, #0]
   \   00000024   0x8001             STRH     R1,[R0, #+0]
   \   00000026   0x8861             LDRH     R1,[R4, #+2]
   \   00000028   0x8041             STRH     R1,[R0, #+2]
   \   0000002A   0x....             LDR.N    R6,??DataTable4
   \   0000002C   0x6830             LDR      R0,[R6, #+0]
   \   0000002E   0x9001             STR      R0,[SP, #+4]
   \   00000030   0xF9B6 0x0008      LDRSH    R0,[R6, #+8]
   \   00000034   0xF647 0x21E0      MOVW     R1,#+31456
   \   00000038   0x4348             MULS     R0,R0,R1
   \   0000003A   0xF44F 0x717A      MOV      R1,#+1000
   \   0000003E   0xFB90 0xF2F1      SDIV     R2,R0,R1
   \   00000042   0xB212             SXTH     R2,R2
   \   00000044   0x9901             LDR      R1,[SP, #+4]
   \   00000046   0x9802             LDR      R0,[SP, #+8]
   \   00000048   0x.... 0x....      BL       FOC_FluxRegulator
   \   0000004C   0x9000             STR      R0,[SP, #+0]
    238              
    239              PID_Speed_InitStructure.wLower_Limit_Integral =
    240                                      -((s32)(Stat_Curr_q_d_temp.qI_Component1)*SP_KIDIV);
   \   0000004E   0xF9BD 0x0000      LDRSH    R0,[SP, #+0]
   \   00000052   0x0201             LSLS     R1,R0,#+8
   \   00000054   0x424A             RSBS     R2,R1,#+0
   \   00000056   0x60EA             STR      R2,[R5, #+12]
    241              PID_Speed_InitStructure.wUpper_Limit_Integral = 
    242                                       ((s32)(Stat_Curr_q_d_temp.qI_Component1)*SP_KIDIV);
   \   00000058   0x6129             STR      R1,[R5, #+16]
    243              
    244              if (Stat_Curr_q_d_ref.qI_Component1 > Stat_Curr_q_d_temp.qI_Component1)
   \   0000005A   0xF9BD 0x1000      LDRSH    R1,[SP, #+0]
   \   0000005E   0xF9B4 0x2000      LDRSH    R2,[R4, #+0]
   \   00000062   0x4291             CMP      R1,R2
   \   00000064   0xBFB8             IT       LT 
   \   00000066   0x4608             MOVLT    R0,R1
    245              {
    246                Stat_Curr_q_d_ref_ref.qI_Component1 = Stat_Curr_q_d_temp.qI_Component1;
   \   00000068   0xDB06             BLT.N    ??FOC_CalcFluxTorqueRef_0
    247              }
    248              else if (Stat_Curr_q_d_ref.qI_Component1 < -Stat_Curr_q_d_temp.qI_Component1)
   \   0000006A   0x4240             RSBS     R0,R0,#+0
   \   0000006C   0xF9B4 0x1000      LDRSH    R1,[R4, #+0]
   \   00000070   0x4281             CMP      R1,R0
   \   00000072   0xBFA8             IT       GE 
   \   00000074   0xF9B4 0x0000      LDRSHGE  R0,[R4, #+0]
    249              {
    250                Stat_Curr_q_d_ref_ref.qI_Component1 = -Stat_Curr_q_d_temp.qI_Component1;
    251              }
    252              else
    253              {
    254                Stat_Curr_q_d_ref_ref.qI_Component1 = Stat_Curr_q_d_ref.qI_Component1;
   \                     ??FOC_CalcFluxTorqueRef_0:
   \   00000078   0x80B0             STRH     R0,[R6, #+4]
    255              }
    256              
    257              Stat_Curr_q_d_ref_ref.qI_Component2 = Stat_Curr_q_d_temp.qI_Component2;
   \   0000007A   0xF8BD 0x0002      LDRH     R0,[SP, #+2]
   \   0000007E   0x80F0             STRH     R0,[R6, #+6]
    258            }
    259            hVMagn = FOC_FluxRegulator_Update(hFW_P_Gain, hFW_I_Gain);
   \   00000080   0xF9B6 0x100C      LDRSH    R1,[R6, #+12]
   \   00000084   0xF9B6 0x000A      LDRSH    R0,[R6, #+10]
   \   00000088   0x.... 0x....      BL       FOC_FluxRegulator_Update
   \   0000008C   0x81F0             STRH     R0,[R6, #+14]
    260              
    261          #else
    262            Stat_Curr_q_d_ref_ref = Stat_Curr_q_d_ref;
    263          #endif
    264          
    265          #ifdef FEED_FORWARD_CURRENT_REGULATION
    266            Stat_Volt_q_d_3 = FOC_FF_CurrReg(Stat_Curr_q_d_ref_ref,Stat_Volt_q_d_2,
    267                                                  GET_SPEED_DPP,MCL_Get_BusVolt());
    268          #endif
    269            
    270            hTorque_Reference = Stat_Curr_q_d_ref_ref.qI_Component1;
   \   0000008E   0x88B0             LDRH     R0,[R6, #+4]
   \   00000090   0x....             LDR.N    R1,??DataTable4_11
   \   00000092   0x8008             STRH     R0,[R1, #+0]
    271            hFlux_Reference = Stat_Curr_q_d_ref_ref.qI_Component2;  
   \   00000094   0x88F0             LDRH     R0,[R6, #+6]
   \   00000096   0x....             LDR.N    R1,??DataTable4_12
   \   00000098   0x8008             STRH     R0,[R1, #+0]
    272          }
   \   0000009A   0xB004             ADD      SP,SP,#+16
   \   0000009C   0xBD70             POP      {R4-R6,PC}       ;; return
    273          
    274          /*******************************************************************************
    275          * Function Name   : FOC_TorqueCntrl
    276          * Description     : This function provides current components Iqs* and Ids* to be
    277          *                   used as reference values (by the FOC_Model function) when in
    278          *                   Torque control mode
    279          * Input           : None.
    280          * Output          : None.
    281          * Return          : None.
    282          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    283          void FOC_TorqueCtrl(void)
    284          {
    285            Stat_Curr_q_d_ref_ref.qI_Component1 = hTorque_Reference;
   \                     FOC_TorqueCtrl:
   \   00000000   0x....             LDR.N    R0,??DataTable4
   \   00000002   0x....             LDR.N    R1,??DataTable4_11
   \   00000004   0x8809             LDRH     R1,[R1, #+0]
   \   00000006   0x8081             STRH     R1,[R0, #+4]
    286            Stat_Curr_q_d_ref_ref.qI_Component2 = hFlux_Reference;
   \   00000008   0x....             LDR.N    R1,??DataTable4_12
   \   0000000A   0x8809             LDRH     R1,[R1, #+0]
   \   0000000C   0x80C1             STRH     R1,[R0, #+6]
    287          #ifdef FEED_FORWARD_CURRENT_REGULATION
    288            Stat_Volt_q_d_3 = FOC_FF_CurrReg(Stat_Curr_q_d_ref_ref,Stat_Volt_q_d_2,
    289                                                    GET_SPEED_DPP,MCL_Get_BusVolt());
    290          #endif  
    291          }
   \   0000000E   0x4770             BX       LR               ;; return
    292          
    293          /*******************************************************************************
    294          * Function Name   : FOC_MTPAInterface_Init
    295          * Description     : According to the motor parameters written in the MTPA
    296          *                   section of MC_PMSM_motor_param.h, it initializes all the
    297          *                   variables related to the MTPA trajectory generator to proper
    298          *                   values (FOC_MTPA function). It has to be called at least
    299          *                   once before the first motor startup.
    300          * Input           : None.
    301          * Output          : None.
    302          * Return          : None.
    303          *******************************************************************************/
    304          #ifdef IPMSM_MTPA
    305          void FOC_MTPAInterface_Init(void)
    306          {
    307            MTPA_Const MTPA_InitStructure = {SEGDIV,ANGC,OFST};
    308            FOC_MTPA_Init(MTPA_InitStructure, ID_DEMAG);
    309          }
    310          #endif
    311          
    312          /*******************************************************************************
    313          * Function Name   : FOC_FluxRegulatorInterface_Init
    314          * Description     : According to the motor parameters written in the
    315          *                   fluxweakening section of MC_PMSM_motor_param.h,
    316          *                   it initializes all the variables related to flux-weakening
    317          *                   operations to proper values (FOC_Flux_Regulator function).
    318          *                   It has to be called before every motor startup.
    319          * Input           : None.
    320          * Output          : None.
    321          * Return          : None.
    322          *******************************************************************************/
    323          #ifdef FLUX_WEAKENING

   \                                 In section .text, align 2, keep-with-next
    324          void FOC_FluxRegulatorInterface_Init(void)
    325          {
   \                     FOC_FluxRegulatorInterface_Init:
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB089             SUB      SP,SP,#+36
    326            PID_Struct_t PI_Stat_Volt_InitStructure;
    327            
    328            PI_Stat_Volt_InitStructure.hKp_Gain = hFW_P_Gain;
   \   00000004   0x....             LDR.N    R0,??DataTable4
   \   00000006   0x8941             LDRH     R1,[R0, #+10]
   \   00000008   0xF8AD 0x1000      STRH     R1,[SP, #+0]
    329            PI_Stat_Volt_InitStructure.hKp_Divisor = FW_KPDIV;
   \   0000000C   0xF44F 0x4100      MOV      R1,#+32768
   \   00000010   0xF8AD 0x1002      STRH     R1,[SP, #+2]
    330            PI_Stat_Volt_InitStructure.hKi_Gain = hFW_I_Gain;
   \   00000014   0x8980             LDRH     R0,[R0, #+12]
   \   00000016   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    331            PI_Stat_Volt_InitStructure.hKi_Divisor = FW_KIDIV; 
   \   0000001A   0xF8AD 0x1006      STRH     R1,[SP, #+6]
    332            //Lower Limit for Output limitation
    333            PI_Stat_Volt_InitStructure.hLower_Limit_Output = ID_DEMAG;
   \   0000001E   0x....             LDR.N    R0,??DataTable4_13  ;; 0xffffa351
   \   00000020   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    334            //Upper Limit for Output limitation
    335            PI_Stat_Volt_InitStructure.hUpper_Limit_Output = 0;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xF8AD 0x000A      STRH     R0,[SP, #+10]
    336            PI_Stat_Volt_InitStructure.wLower_Limit_Integral = 
    337                                        PI_Stat_Volt_InitStructure.hLower_Limit_Output *
    338                                        PI_Stat_Volt_InitStructure.hKi_Divisor;   //Lower Limit for Integral term limitation
   \   0000002A   0xF9BD 0x0008      LDRSH    R0,[SP, #+8]
   \   0000002E   0xF8BD 0x1006      LDRH     R1,[SP, #+6]
   \   00000032   0x4348             MULS     R0,R0,R1
   \   00000034   0x9003             STR      R0,[SP, #+12]
    339            PI_Stat_Volt_InitStructure.wUpper_Limit_Integral = 0;   //Lower Limit for Integral term limitation
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x9004             STR      R0,[SP, #+16]
    340            PI_Stat_Volt_InitStructure.wIntegral = 0;
   \   0000003A   0x9005             STR      R0,[SP, #+20]
    341            
    342            PI_Stat_Volt_InitStructure.hKd_Gain = FW_KD_GAIN;
   \   0000003C   0xF8AD 0x0018      STRH     R0,[SP, #+24]
    343            PI_Stat_Volt_InitStructure.hKd_Divisor = FW_KDDIV;
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0xF8AD 0x001A      STRH     R0,[SP, #+26]
    344            PI_Stat_Volt_InitStructure.wPreviousError = FW_D_TERM_INIT;
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x9007             STR      R0,[SP, #+28]
    345            
    346            FOC_FluxRegulator_Init(&PI_Stat_Volt_InitStructure,NOMINAL_CURRENT);  
   \   0000004A   0xF645 0x41AF      MOVW     R1,#+23727
   \   0000004E   0xA800             ADD      R0,SP,#+0
   \   00000050   0x.... 0x....      BL       FOC_FluxRegulator_Init
    347          }
   \   00000054   0xB009             ADD      SP,SP,#+36
   \   00000056   0xBD00             POP      {PC}             ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x........         DC32     Stat_Volt_q_d_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x........         DC32     Stat_Curr_q_d_ref

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x........         DC32     Stat_Curr_a_b

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   0x........         DC32     Stat_Curr_alfa_beta

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \   00000000   0x........         DC32     Stat_Curr_q_d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_5:
   \   00000000   0x........         DC32     Stat_Volt_alfa_beta

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_6:
   \   00000000   0x........         DC32     Stat_Volt_q_d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_7:
   \   00000000   0x........         DC32     PID_Torque_InitStructure

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_8:
   \   00000000   0x........         DC32     PID_Flux_InitStructure

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_9:
   \   00000000   0x........         DC32     PID_Speed_InitStructure

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_10:
   \   00000000   0x........         DC32     hSpeed_Reference

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_11:
   \   00000000   0x........         DC32     hTorque_Reference

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_12:
   \   00000000   0x........         DC32     hFlux_Reference

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_13:
   \   00000000   0xFFFFA351         DC32     0xffffa351
    348          #endif
    349          
    350          /******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       32  FOC_CalcFluxTorqueRef
             32 -> FOC_FluxRegulator
             32 -> FOC_FluxRegulator_Update
             32 -> PID_Regulator
             32 -> STO_Get_Speed_Hz
       40  FOC_FluxRegulatorInterface_Init
             40 -> FOC_FluxRegulator_Init
        8  FOC_Init
              8 -> FOC_FluxRegulatorInterface_Init
       32  FOC_Model
             32 -> Clarke
             32 -> MCL_Get_BusVolt
             32 -> PID_Regulator
             32 -> Park
             32 -> RevPark_Circle_Limitation
             32 -> Rev_Park
             32 -> STO_Calc_Rotor_Angle
             32 -> STO_Get_Electrical_Angle
             32 -> SVPWM_3ShuntCalcDutyCycles
             32 -> SVPWM_3ShuntGetPhaseCurrentValues
        0  FOC_TorqueCtrl


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_10
       4  ??DataTable4_11
       4  ??DataTable4_12
       4  ??DataTable4_13
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
       4  ??DataTable4_7
       4  ??DataTable4_8
       4  ??DataTable4_9
     158  FOC_CalcFluxTorqueRef
      88  FOC_FluxRegulatorInterface_Init
      28  FOC_Init
     256  FOC_Model
      16  FOC_TorqueCtrl
       4  Stat_Curr_q_d_ref
      16  Stat_Volt_q_d_1
          Stat_Curr_q_d_ref_ref
          hFW_V_Ref
          hFW_P_Gain
          hFW_I_Gain
          hVMagn

 
   4 bytes in section .bss
  16 bytes in section .data
 602 bytes in section .text
 
 602 bytes of CODE memory
  20 bytes of DATA memory

Errors: none
Warnings: 4
