###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     04/Nov/2013  13:20:00 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\st\stm32 foc firwmare libraries                       #
#                    v2.0\STM32_FOC_PMSM\src\stm32f10x_encoder.c              #
#    Command line =  "D:\st\stm32 foc firwmare libraries                      #
#                    v2.0\STM32_FOC_PMSM\src\stm32f10x_encoder.c" -D          #
#                    VECT_TAB_FLASH -lCN "D:\st\stm32 foc firwmare libraries  #
#                    v2.0\STM32_FOC_PMSM\EWARM\Debug\List\" --diag_error      #
#                    Pe068,Pe069 -o "D:\st\stm32 foc firwmare libraries       #
#                    v2.0\STM32_FOC_PMSM\EWARM\Debug\Obj\" --debug            #
#                    --endian=little --cpu=Cortex-M3 --fpu=None               #
#                    --dlib_config D:\IAR\arm\INC\c\DLib_Config_Normal.h -I   #
#                    "D:\st\stm32 foc firwmare libraries                      #
#                    v2.0\STM32_FOC_PMSM\EWARM\..\" -I "D:\st\stm32 foc       #
#                    firwmare libraries v2.0\STM32_FOC_PMSM\EWARM\..\..\STM32 #
#                    F10XFWLIB\inc\" -I "D:\st\stm32 foc firwmare libraries   #
#                    v2.0\STM32_FOC_PMSM\EWARM\..\inc\" -Oh --use_c++_inline  #
#                    --require_prototypes                                     #
#    List file    =  D:\st\stm32 foc firwmare libraries                       #
#                    v2.0\STM32_FOC_PMSM\EWARM\Debug\List\stm32f10x_encoder.l #
#                    st                                                       #
#    Object file  =  D:\st\stm32 foc firwmare libraries                       #
#                    v2.0\STM32_FOC_PMSM\EWARM\Debug\Obj\stm32f10x_encoder.o  #
#                                                                             #
#                                                                             #
###############################################################################

D:\st\stm32 foc firwmare libraries v2.0\STM32_FOC_PMSM\src\stm32f10x_encoder.c
      1          /******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
      2          * File Name          : stm32f10x_encoder.c 
      3          * Author             : IMS Systems Lab  
      4          * Date First Issued  : 21/11/07
      5          * Description        : This file contains the software implementation for the
      6          *                      encoder unit
      7          ********************************************************************************
      8          * History:
      9          * 21/11/07 v1.0
     10          * 29/05/08 v2.0
     11          ********************************************************************************
     12          * THE PRESENT SOFTWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     13          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
     14          * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
     15          * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
     16          * CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
     17          * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     18          *
     19          * THIS SOURCE CODE IS PROTECTED BY A LICENSE.
     20          * FOR MORE INFORMATION PLEASE CAREFULLY READ THE LICENSE AGREEMENT FILE LOCATED
     21          * IN THE ROOT DIRECTORY OF THIS FIRMWARE PACKAGE.
     22          *******************************************************************************/
     23          /* Includes ------------------------------------------------------------------*/
     24          #include "stm32f10x_lib.h"
     25          #include "stm32f10x_encoder.h"
     26          #include "stm32f10x_it.h"
     27          #include "MC_Globals.h"
     28          #include "stm32f10x_MClib.h"
     29          
     30          /* Private typedef -----------------------------------------------------------*/
     31          /* Private define ------------------------------------------------------------*/
     32          #define COUNTER_RESET       (u16) ((((s32)(ALIGNMENT_ANGLE)*4*ENCODER_PPR/360)\
     33                                                                        -1)/POLE_PAIR_NUM)
     34          #define ICx_FILTER          (u8) 8 // 8<-> 670nsec
     35          
     36          #define SPEED_SAMPLING_FREQ (u16)(2000/(SPEED_SAMPLING_TIME+1))
     37          
     38          #define TIMx_PRE_EMPTION_PRIORITY 2
     39          #define TIMx_SUB_PRIORITY 0
     40          
     41          #define SPEED_SAMPLING_TIME   PID_SPEED_SAMPLING_TIME
     42          
     43          /* Private macro -------------------------------------------------------------*/
     44          // To avoid obvious initialization errors...
     45          #if  ( (defined(TIMER2_HANDLES_ENCODER) && defined(TIMER3_HANDLES_ENCODER)) \
     46              || (defined(TIMER2_HANDLES_ENCODER) && defined(TIMER4_HANDLES_ENCODER)) \
     47              || (defined(TIMER3_HANDLES_ENCODER) && defined(TIMER4_HANDLES_ENCODER)))
     48            #error "Invalid encoder setup: 2 timers selected"
     49          #endif
     50          
     51          #ifdef ENCODER
     52          
     53          // Warning message if encoder unit not connected
     54          #ifndef TIMER2_HANDLES_ENCODER
     55          #ifndef TIMER3_HANDLES_ENCODER
     56          #ifndef TIMER4_HANDLES_ENCODER
     57          #warning "Encoder not selected"
     58          #endif
     59          #endif
     60          #endif
     61          #endif  // ENCODER
     62          
     63          /* Private functions ---------------------------------------------------------*/
     64          s16 ENC_Calc_Rot_Speed(void);
     65          
     66          /* Private variables ---------------------------------------------------------*/
     67          static s16 hPrevious_angle, hSpeed_Buffer[SPEED_BUFFER_SIZE], hRot_Speed;
     68          static u8 bSpeed_Buffer_Index = 0;
     69          static volatile u16 hEncoder_Timer_Overflow; 
     70          static bool bIs_First_Measurement = TRUE;
     71          static bool bError_Speed_Measurement = FALSE;
     72          
     73          /*******************************************************************************
     74          * Function Name  : ENC_Init
     75          * Description    : General Purpose Timer x set-up for encoder speed/position 
     76          *                  sensors
     77          * Input          : None
     78          * Output         : None
     79          * Return         : None
     80          *******************************************************************************/
     81          

   \                                 In section .text, align 2, keep-with-next
     82          void ENC_Init(void)
     83          {
   \                     ENC_Init:
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB089             SUB      SP,SP,#+36
     84            TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
     85            TIM_ICInitTypeDef TIM_ICInitStructure;
     86            
     87          #if defined(TIMER2_HANDLES_ENCODER)   // Encoder unit connected to TIM2, 4X mode
     88              
     89            GPIO_InitTypeDef GPIO_InitStructure;
     90            NVIC_InitTypeDef NVIC_InitStructure;
     91              
     92            /* TIM2 clock source enable */
     93            RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0x.... 0x....      BL       RCC_APB1PeriphClockCmd
     94            /* Enable GPIOA, clock */
     95            RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0x2004             MOVS     R0,#+4
   \   00000010   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     96            
     97            GPIO_StructInit(&GPIO_InitStructure);
   \   00000014   0xA801             ADD      R0,SP,#+4
   \   00000016   0x.... 0x....      BL       GPIO_StructInit
     98            /* Configure PA.00,01 as encoder input */
     99            GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1;
   \   0000001A   0x2003             MOVS     R0,#+3
   \   0000001C   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    100            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
   \   00000020   0x2004             MOVS     R0,#+4
   \   00000022   0xF88D 0x0007      STRB     R0,[SP, #+7]
    101            GPIO_Init(GPIOA, &GPIO_InitStructure);
   \   00000026   0xA901             ADD      R1,SP,#+4
   \   00000028   0x....             LDR.N    R0,??DataTable9  ;; 0x40010800
   \   0000002A   0x.... 0x....      BL       GPIO_Init
    102            
    103            /* Enable the TIM2 Update Interrupt */
    104            NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQChannel;
   \   0000002E   0x201C             MOVS     R0,#+28
   \   00000030   0xF88D 0x0000      STRB     R0,[SP, #+0]
    105            NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = TIMx_PRE_EMPTION_PRIORITY;
   \   00000034   0x2002             MOVS     R0,#+2
   \   00000036   0xF88D 0x0001      STRB     R0,[SP, #+1]
    106            NVIC_InitStructure.NVIC_IRQChannelSubPriority = TIMx_SUB_PRIORITY;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xF88D 0x0002      STRB     R0,[SP, #+2]
    107            NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0xF88D 0x0003      STRB     R0,[SP, #+3]
    108            NVIC_Init(&NVIC_InitStructure);
   \   00000046   0xA800             ADD      R0,SP,#+0
   \   00000048   0x.... 0x....      BL       NVIC_Init
    109          
    110          #elif defined(TIMER3_HANDLES_ENCODER) // Encoder unit connected to TIM3, 4X mode
    111            GPIO_InitTypeDef GPIO_InitStructure;
    112            NVIC_InitTypeDef NVIC_InitStructure;
    113            
    114            /* TIM3 clock source enable */
    115            RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);
    116            /* Enable GPIOA, clock */
    117            RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
    118            
    119            GPIO_StructInit(&GPIO_InitStructure);
    120            /* Configure PA.06,07 as encoder input */
    121            GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7;
    122            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    123            GPIO_Init(GPIOA, &GPIO_InitStructure);
    124            
    125            /* Enable the TIM3 Update Interrupt */
    126            NVIC_InitStructure.NVIC_IRQChannel = TIM3_IRQChannel;
    127            NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = TIMx_PRE_EMPTION_PRIORITY;
    128            NVIC_InitStructure.NVIC_IRQChannelSubPriority = TIMx_SUB_PRIORITY;
    129            NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    130            NVIC_Init(&NVIC_InitStructure);
    131          
    132          #elif defined(TIMER4_HANDLES_ENCODER) // Encoder unit connected to TIM4, 4X mode
    133            GPIO_InitTypeDef GPIO_InitStructure;
    134            NVIC_InitTypeDef NVIC_InitStructure;
    135            
    136            /* TIM4 clock source enable */
    137            RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4, ENABLE);
    138            /* Enable GPIOA, clock */
    139            RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
    140            
    141            GPIO_StructInit(&GPIO_InitStructure);
    142            /* Configure PB.06,07 as encoder input */
    143            GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7;
    144            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    145            GPIO_Init(GPIOB, &GPIO_InitStructure);
    146            
    147            /* Enable the TIM4 Update Interrupt */
    148            NVIC_InitStructure.NVIC_IRQChannel = TIM4_IRQChannel;
    149            NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = TIMx_PRE_EMPTION_PRIORITY;
    150            NVIC_InitStructure.NVIC_IRQChannelSubPriority = TIMx_SUB_PRIORITY;
    151            NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    152            NVIC_Init(&NVIC_InitStructure);
    153          #endif
    154          
    155            /* Timer configuration in Encoder mode */
    156            TIM_DeInit(ENCODER_TIMER);
   \   0000004C   0xF04F 0x4080      MOV      R0,#+1073741824
   \   00000050   0x.... 0x....      BL       TIM_DeInit
    157            TIM_TimeBaseStructInit(&TIM_TimeBaseStructure);
   \   00000054   0xA805             ADD      R0,SP,#+20
   \   00000056   0x.... 0x....      BL       TIM_TimeBaseStructInit
    158            
    159            TIM_TimeBaseStructure.TIM_Prescaler = 0x0;  // No prescaling 
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0xF8AD 0x0014      STRH     R0,[SP, #+20]
    160            TIM_TimeBaseStructure.TIM_Period = (4*ENCODER_PPR)-1;  
   \   00000060   0xF240 0x603F      MOVW     R0,#+1599
   \   00000064   0xF8AD 0x0018      STRH     R0,[SP, #+24]
    161            TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1;
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0xF8AD 0x001A      STRH     R0,[SP, #+26]
    162            TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;   
   \   0000006E   0xF8AD 0x0016      STRH     R0,[SP, #+22]
    163            TIM_TimeBaseInit(ENCODER_TIMER, &TIM_TimeBaseStructure);
   \   00000072   0xA905             ADD      R1,SP,#+20
   \   00000074   0xF04F 0x4080      MOV      R0,#+1073741824
   \   00000078   0x.... 0x....      BL       TIM_TimeBaseInit
    164           
    165            TIM_EncoderInterfaceConfig(ENCODER_TIMER, TIM_EncoderMode_TI12, 
    166                                       TIM_ICPolarity_Rising, TIM_ICPolarity_Rising);
   \   0000007C   0x2300             MOVS     R3,#+0
   \   0000007E   0x461A             MOV      R2,R3
   \   00000080   0x2103             MOVS     R1,#+3
   \   00000082   0xF04F 0x4080      MOV      R0,#+1073741824
   \   00000086   0x.... 0x....      BL       TIM_EncoderInterfaceConfig
    167            TIM_ICStructInit(&TIM_ICInitStructure);
   \   0000008A   0xA802             ADD      R0,SP,#+8
   \   0000008C   0x.... 0x....      BL       TIM_ICStructInit
    168            
    169            TIM_ICInitStructure.TIM_ICFilter = ICx_FILTER;
   \   00000090   0x2008             MOVS     R0,#+8
   \   00000092   0xF8AD 0x0010      STRH     R0,[SP, #+16]
    170            TIM_ICInit(ENCODER_TIMER, &TIM_ICInitStructure);
   \   00000096   0xA902             ADD      R1,SP,#+8
   \   00000098   0xF04F 0x4080      MOV      R0,#+1073741824
   \   0000009C   0x.... 0x....      BL       TIM_ICInit
    171            
    172            TIM_ICInitStructure.TIM_Channel = TIM_Channel_2;
   \   000000A0   0x2004             MOVS     R0,#+4
   \   000000A2   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    173            TIM_ICInit(ENCODER_TIMER, &TIM_ICInitStructure);
   \   000000A6   0xA902             ADD      R1,SP,#+8
   \   000000A8   0xF04F 0x4080      MOV      R0,#+1073741824
   \   000000AC   0x.... 0x....      BL       TIM_ICInit
    174                
    175           // Clear all pending interrupts
    176            TIM_ClearFlag(ENCODER_TIMER, TIM_FLAG_Update);
   \   000000B0   0x2101             MOVS     R1,#+1
   \   000000B2   0xF04F 0x4080      MOV      R0,#+1073741824
   \   000000B6   0x.... 0x....      BL       TIM_ClearFlag
    177            TIM_ITConfig(ENCODER_TIMER, TIM_IT_Update, ENABLE);
   \   000000BA   0x2201             MOVS     R2,#+1
   \   000000BC   0x4611             MOV      R1,R2
   \   000000BE   0xF04F 0x4080      MOV      R0,#+1073741824
   \   000000C2   0x.... 0x....      BL       TIM_ITConfig
    178            //Reset counter
    179            TIM2->CNT = COUNTER_RESET;
   \   000000C6   0xF04F 0x4080      MOV      R0,#+1073741824
   \   000000CA   0x21C7             MOVS     R1,#+199
   \   000000CC   0x8481             STRH     R1,[R0, #+36]
    180            
    181            TIM_Cmd(ENCODER_TIMER, ENABLE);
   \   000000CE   0x2101             MOVS     R1,#+1
   \   000000D0   0x.... 0x....      BL       TIM_Cmd
    182          }
   \   000000D4   0xB009             ADD      SP,SP,#+36
   \   000000D6   0xBD00             POP      {PC}             ;; return
    183          
    184          /*******************************************************************************
    185          * Function Name  : ENC_Get_Electrical_Angle
    186          * Description    : Returns the absolute electrical Rotor angle 
    187          * Input          : None
    188          * Output         : None
    189          * Return         : Rotor electrical angle: 0 -> 0 degrees, 
    190          *                                          S16_MAX-> 180 degrees, 
    191          *                                          S16_MIN-> -180 degrees
    192          *                  Mechanical angle can be derived calling this function and 
    193          *                  dividing by POLE_PAIR_NUM
    194          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    195          s16 ENC_Get_Electrical_Angle(void)
    196          {
   \                     ENC_Get_Electrical_Angle:
   \   00000000   0xB580             PUSH     {R7,LR}
    197            s32 temp;
    198            
    199            temp = (s32)(TIM_GetCounter(ENCODER_TIMER)) * (s32)(U32_MAX / (4*ENCODER_PPR));         
    200            temp *= POLE_PAIR_NUM;  
    201            return((s16)(temp/65536)); // s16 result
   \   00000002   0xF04F 0x4080      MOV      R0,#+1073741824
   \   00000006   0x.... 0x....      BL       TIM_GetCounter
   \   0000000A   0x....             LDR.N    R1,??DataTable9_1  ;; 0x51eb84
   \   0000000C   0x....             B.N      ?Subroutine0
    202          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0:
   \   00000000   0x4348             MULS     R0,R1,R0
   \   00000002   0x13C1             ASRS     R1,R0,#+15
   \   00000004   0xEB00 0x4011      ADD      R0,R0,R1, LSR #+16
   \   00000008   0x1400             ASRS     R0,R0,#+16
   \   0000000A   0xBD02             POP      {R1,PC}          ;; return
    203          
    204          /*******************************************************************************
    205          * Function Name  : ENC_Get_Mechanical_Angle
    206          * Description    : Returns the absolute mechanical Rotor angle 
    207          * Input          : None
    208          * Output         : None
    209          * Return         : Rotor mechanical angle: 0 -> 0 degrees, S16_MAX-> 180 degrees, 
    210                                                      S16_MIN-> -180 degrees
    211          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    212          s16 ENC_Get_Mechanical_Angle(void)
    213          {
   \                     ENC_Get_Mechanical_Angle:
   \   00000000   0xB580             PUSH     {R7,LR}
    214            s32 temp;
    215            
    216            temp = (s32)(TIM_GetCounter(ENCODER_TIMER)) * (s32)(U32_MAX / (4*ENCODER_PPR)) ;
    217            return((s16)(temp/65536)); // s16 result
   \   00000002   0xF04F 0x4080      MOV      R0,#+1073741824
   \   00000006   0x.... 0x....      BL       TIM_GetCounter
   \   0000000A   0x....             LDR.N    R1,??DataTable9_2  ;; 0x28f5c2
   \   0000000C                      REQUIRE ?Subroutine0
   \   0000000C                      ;; // Fall through to label ?Subroutine0
    218          }
    219          
    220          /*******************************************************************************
    221          * Function Name  : ENC_ResetEncoder
    222          * Description    : Write the encoder counter with the value corresponding to
    223          *                  ALIGNMENT_ANGLE
    224          * Input          : None
    225          * Output         : None
    226          * Return         : None
    227          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    228          void ENC_ResetEncoder(void)
    229          {
    230            //Reset counter
    231            TIM2->CNT = COUNTER_RESET;
   \                     ENC_ResetEncoder:
   \   00000000   0x....             LDR.N    R0,??DataTable9_3  ;; 0x40000024
   \   00000002   0x21C7             MOVS     R1,#+199
   \   00000004   0x8001             STRH     R1,[R0, #+0]
    232          }
   \   00000006   0x4770             BX       LR               ;; return
    233          
    234                       
    235          /*******************************************************************************
    236          * Function Name  : ENC_Clear_Speed_Buffer
    237          * Description    : Clear speed buffer used for average speed calculation  
    238          * Input          : None
    239          * Output         : None
    240          * Return         : None
    241          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    242          void ENC_Clear_Speed_Buffer(void)
    243          {   
   \                     ENC_Clear_Speed_Buffer:
   \   00000000   0xB510             PUSH     {R4,LR}
    244            u32 i;
    245          
    246            for (i=0;i<SPEED_BUFFER_SIZE;i++)
    247            {
    248              hSpeed_Buffer[i] = 0;
   \   00000002   0x....             LDR.N    R4,??DataTable9_4
   \   00000004   0x2110             MOVS     R1,#+16
   \   00000006   0xF104 0x000C      ADD      R0,R4,#+12
   \   0000000A   0x.... 0x....      BL       __aeabi_memclr
    249            }
    250            bIs_First_Measurement = TRUE;
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x7060             STRB     R0,[R4, #+1]
    251          }
   \   00000012   0xBD10             POP      {R4,PC}          ;; return
    252          
    253          /*******************************************************************************
    254          * Function Name  : ENC_Calc_Rot_Speed
    255          * Description    : Compute return latest speed measurement 
    256          * Input          : None
    257          * Output         : s16
    258          * Return         : Return motor speed in 0.1 Hz resolution. Since the encoder is
    259                             used as speed sensor, this routine will return the mechanical
    260                             speed of the motor (NOT the electrical frequency)
    261                             Mechanical frequency is equal to electrical frequency/(number 
    262                             of pair poles).
    263          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    264          s16 ENC_Calc_Rot_Speed(void)
    265          {   
   \                     ENC_Calc_Rot_Speed:
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
    266            s32 wDelta_angle;
    267            u16 hEnc_Timer_Overflow_sample_one, hEnc_Timer_Overflow_sample_two;
    268            u16 hCurrent_angle_sample_one, hCurrent_angle_sample_two;
    269            signed long long temp;
    270            s16 haux;
    271            
    272            if (!bIs_First_Measurement)
   \   00000002   0xF04F 0x4280      MOV      R2,#+1073741824
   \   00000006   0x....             LDR.N    R4,??DataTable9_4
   \   00000008   0x7860             LDRB     R0,[R4, #+1]
   \   0000000A   0xBB38             CBNZ.N   R0,??ENC_Calc_Rot_Speed_0
    273            {
    274              // 1st reading of overflow counter    
    275              hEnc_Timer_Overflow_sample_one = hEncoder_Timer_Overflow; 
   \   0000000C   0x8920             LDRH     R0,[R4, #+8]
    276              // 1st reading of encoder timer counter
    277              hCurrent_angle_sample_one = ENCODER_TIMER->CNT;
   \   0000000E   0x8C91             LDRH     R1,[R2, #+36]
    278              // 2nd reading of overflow counter
    279              hEnc_Timer_Overflow_sample_two = hEncoder_Timer_Overflow;  
   \   00000010   0x8923             LDRH     R3,[R4, #+8]
    280              // 2nd reading of encoder timer counter
    281              hCurrent_angle_sample_two = ENCODER_TIMER->CNT;      
   \   00000012   0x8C96             LDRH     R6,[R2, #+36]
    282          
    283              // Reset hEncoder_Timer_Overflow and read the counter value for the next
    284              // measurement
    285              hEncoder_Timer_Overflow = 0;
   \   00000014   0x2500             MOVS     R5,#+0
   \   00000016   0x8125             STRH     R5,[R4, #+8]
    286              haux = ENCODER_TIMER->CNT;   
   \   00000018   0xF9B2 0x5024      LDRSH    R5,[R2, #+36]
    287              
    288              if (hEncoder_Timer_Overflow != 0) 
   \   0000001C   0x8927             LDRH     R7,[R4, #+8]
   \   0000001E   0xB11F             CBZ.N    R7,??ENC_Calc_Rot_Speed_1
    289              {
    290                haux = ENCODER_TIMER->CNT; 
   \   00000020   0xF9B2 0x5024      LDRSH    R5,[R2, #+36]
    291                hEncoder_Timer_Overflow = 0;            
   \   00000024   0x2700             MOVS     R7,#+0
   \   00000026   0x8127             STRH     R7,[R4, #+8]
    292              }
    293               
    294              if (hEnc_Timer_Overflow_sample_one != hEnc_Timer_Overflow_sample_two)
   \                     ??ENC_Calc_Rot_Speed_1:
   \   00000028   0x4298             CMP      R0,R3
   \   0000002A   0xBF1C             ITT      NE 
   \   0000002C   0x4631             MOVNE    R1,R6
   \   0000002E   0x4618             MOVNE    R0,R3
    295              { //Compare sample 1 & 2 and check if an overflow has been generated right 
    296                //after the reading of encoder timer. If yes, copy sample 2 result in 
    297                //sample 1 for next process 
    298                hCurrent_angle_sample_one = hCurrent_angle_sample_two;
    299                hEnc_Timer_Overflow_sample_one = hEnc_Timer_Overflow_sample_two;
    300              }
    301              
    302              if ( (ENCODER_TIMER->CR1 & TIM_CounterMode_Down) == TIM_CounterMode_Down)  
   \   00000030   0xF9B4 0x3004      LDRSH    R3,[R4, #+4]
   \   00000034   0x1AC9             SUBS     R1,R1,R3
   \   00000036   0xF44F 0x63C8      MOV      R3,#+1600
   \   0000003A   0x4358             MULS     R0,R3,R0
   \   0000003C   0x8812             LDRH     R2,[R2, #+0]
   \   0000003E   0x06D2             LSLS     R2,R2,#+27
   \   00000040   0xBF4C             ITE      MI 
   \   00000042   0x1A08             SUBMI    R0,R1,R0
   \   00000044   0x1840             ADDPL    R0,R0,R1
    303              {// encoder timer down-counting
    304                wDelta_angle = (s32)(hCurrent_angle_sample_one - hPrevious_angle - 
    305                              (hEnc_Timer_Overflow_sample_one) * (4*ENCODER_PPR));
    306              }
    307              else  
    308              {//encoder timer up-counting
    309                wDelta_angle = (s32)(hCurrent_angle_sample_one - hPrevious_angle + 
    310                              (hEnc_Timer_Overflow_sample_one) * (4*ENCODER_PPR));
    311              }
    312              
    313              // speed computation as delta angle * 1/(speed sempling time)
    314              temp = (signed long long)(wDelta_angle * SPEED_SAMPLING_FREQ);                                                                
    315              temp *= 10;  // 0.1 Hz resolution
    316              temp /= (4*ENCODER_PPR);
   \   00000046   0xF44F 0x71FA      MOV      R1,#+500
   \   0000004A   0x4348             MULS     R0,R1,R0
   \   0000004C   0x210A             MOVS     R1,#+10
   \   0000004E   0xFB81 0x0100      SMULL    R0,R1,R1,R0
   \   00000052   0x461A             MOV      R2,R3
   \   00000054   0x2300             MOVS     R3,#+0
   \   00000056   0x.... 0x....      BL       __aeabi_ldivmod
   \   0000005A   0xE009             B.N      ??ENC_Calc_Rot_Speed_2
    317                  
    318            } //is first measurement, discard it
    319            else
    320            {
    321              bIs_First_Measurement = FALSE;
   \                     ??ENC_Calc_Rot_Speed_0:
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x7060             STRB     R0,[R4, #+1]
    322              temp = 0;
    323              hEncoder_Timer_Overflow = 0;
   \   00000060   0x8120             STRH     R0,[R4, #+8]
    324              haux = ENCODER_TIMER->CNT;       
   \   00000062   0xF9B2 0x5024      LDRSH    R5,[R2, #+36]
    325              // Check if Encoder_Timer_Overflow is still zero. In case an overflow IT 
    326              // occured it resets overflow counter and wPWM_Counter_Angular_Velocity
    327              if (hEncoder_Timer_Overflow != 0) 
   \   00000066   0x8923             LDRH     R3,[R4, #+8]
   \   00000068   0xB113             CBZ.N    R3,??ENC_Calc_Rot_Speed_2
    328              {
    329                haux = ENCODER_TIMER->CNT; 
   \   0000006A   0xF9B2 0x5024      LDRSH    R5,[R2, #+36]
    330                hEncoder_Timer_Overflow = 0;            
   \   0000006E   0x8120             STRH     R0,[R4, #+8]
    331              }
    332            }
    333            
    334            hPrevious_angle = haux;  
   \                     ??ENC_Calc_Rot_Speed_2:
   \   00000070   0x80A5             STRH     R5,[R4, #+4]
    335           
    336            return((s16) temp);
   \   00000072   0xB200             SXTH     R0,R0
   \   00000074   0xBDF0             POP      {R4-R7,PC}       ;; return
    337          }
    338          
    339          /*******************************************************************************
    340          * Function Name  : ENC_Get_Mechanical_Speed
    341          * Description    : Export the value of the smoothed motor speed computed in 
    342          *                  ENC_Calc_Average_Speed function  
    343          * Input          : None
    344          * Output         : s16
    345          * Return         : Return motor speed in 0.1 Hz resolution. This routine 
    346                             will return the average mechanical speed of the motor.
    347          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    348          s16 ENC_Get_Mechanical_Speed(void)
    349          {
    350            return(hRot_Speed);
   \                     ENC_Get_Mechanical_Speed:
   \   00000000   0x....             LDR.N    R0,??DataTable9_4
   \   00000002   0xF9B0 0x0006      LDRSH    R0,[R0, #+6]
   \   00000006   0x4770             BX       LR               ;; return
    351          }
    352          
    353          /*******************************************************************************
    354          * Function Name  : ENC_Calc_Average_Speed
    355          * Description    : Compute smoothed motor speed based on last SPEED_BUFFER_SIZE
    356                             informations and store it variable  
    357          * Input          : None
    358          * Output         : s16
    359          * Return         : Return rotor speed in 0.1 Hz resolution. This routine 
    360                             will return the average mechanical speed of the motor.
    361          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    362          void ENC_Calc_Average_Speed(void)
    363          {   
   \                     ENC_Calc_Average_Speed:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    364            s32 wtemp;
    365            u16 hAbstemp;
    366            u32 i;
    367            u8 static bError_counter;
    368            
    369            wtemp = ENC_Calc_Rot_Speed();
   \   00000002   0x.... 0x....      BL       ENC_Calc_Rot_Speed
    370            hAbstemp = ( wtemp < 0 ? - wtemp :  wtemp);
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xBF4C             ITE      MI 
   \   0000000A   0x4242             RSBMI    R2,R0,#+0
   \   0000000C   0x4602             MOVPL    R2,R0
    371          
    372          /* Checks for speed measurement errors when in RUN State and saturates if 
    373                                                                              necessary*/  
    374            if (State == RUN)
   \   0000000E   0x....             LDR.N    R1,??DataTable9_5
   \   00000010   0x780B             LDRB     R3,[R1, #+0]
   \   00000012   0x....             LDR.N    R1,??DataTable9_4
   \   00000014   0x78CC             LDRB     R4,[R1, #+3]
   \   00000016   0x780D             LDRB     R5,[R1, #+0]
   \   00000018   0x2B03             CMP      R3,#+3
   \   0000001A   0xD11B             BNE.N    ??ENC_Calc_Average_Speed_0
    375            {    
    376              if(hAbstemp < MINIMUM_MECHANICAL_SPEED)
   \   0000001C   0xB292             UXTH     R2,R2
   \   0000001E   0x2A0A             CMP      R2,#+10
   \   00000020   0xD205             BCS.N    ??ENC_Calc_Average_Speed_1
    377              { 
    378                if (wtemp < 0)
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xBF54             ITE      PL 
   \   00000026   0x200A             MOVPL    R0,#+10
   \   00000028   0xF06F 0x0009      MVNMI    R0,#+9
    379                {
    380                  wtemp = -(s32)(MINIMUM_MECHANICAL_SPEED);
   \   0000002C   0xE008             B.N      ??ENC_Calc_Average_Speed_2
    381                }
    382                else
    383                {
    384                  wtemp = MINIMUM_MECHANICAL_SPEED;
    385                }
    386                bError_counter++;
    387              }
    388              else  if (hAbstemp > MAXIMUM_MECHANICAL_SPEED) 
   \                     ??ENC_Calc_Average_Speed_1:
   \   0000002E   0xF241 0x7371      MOVW     R3,#+6001
   \   00000032   0x429A             CMP      R2,R3
   \   00000034   0xD30B             BCC.N    ??ENC_Calc_Average_Speed_3
    389                    {
    390                      if (wtemp < 0)
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xBF4C             ITE      MI 
   \   0000003A   0x....             LDRMI.N  R0,??DataTable9_6  ;; 0xffffe890
   \   0000003C   0xF241 0x7070      MOVWPL   R0,#+6000
    391                      {
    392                        wtemp = -(s32)(MAXIMUM_MECHANICAL_SPEED);
    393                      }
    394                      else
    395                      {
    396                        wtemp = MAXIMUM_MECHANICAL_SPEED;
    397                      }
    398                      bError_counter++;
   \                     ??ENC_Calc_Average_Speed_2:
   \   00000040   0x1C62             ADDS     R2,R4,#+1
    399                    }
    400                    else
    401                    { 
    402                      bError_counter = 0;
    403                    }
    404            
    405              if (bError_counter >= MAXIMUM_ERROR_NUMBER)
   \   00000042   0xB2D2             UXTB     R2,R2
   \   00000044   0x2A19             CMP      R2,#+25
   \   00000046   0x419B             SBCS     R3,R3,R3
   \   00000048   0x43DB             MVNS     R3,R3
   \   0000004A   0x0FDB             LSRS     R3,R3,#+31
   \   0000004C   0xE004             B.N      ??ENC_Calc_Average_Speed_4
   \                     ??ENC_Calc_Average_Speed_3:
   \   0000004E   0x2200             MOVS     R2,#+0
    406              {
    407               bError_Speed_Measurement = TRUE;
    408              }
    409              else
    410              {
    411               bError_Speed_Measurement = FALSE;
   \   00000050   0x2300             MOVS     R3,#+0
   \   00000052   0xE001             B.N      ??ENC_Calc_Average_Speed_4
    412              }
    413            }
    414            else
    415            {
    416              bError_Speed_Measurement = FALSE;
   \                     ??ENC_Calc_Average_Speed_0:
   \   00000054   0x2300             MOVS     R3,#+0
    417              bError_counter = 0;
   \   00000056   0x2200             MOVS     R2,#+0
   \                     ??ENC_Calc_Average_Speed_4:
   \   00000058   0x708B             STRB     R3,[R1, #+2]
   \   0000005A   0x70CA             STRB     R2,[R1, #+3]
    418            }
    419            
    420          /* Compute the average of the read speeds */
    421            
    422            hSpeed_Buffer[bSpeed_Buffer_Index] = (s16)wtemp;
   \   0000005C   0xEB01 0x0245      ADD      R2,R1,R5, LSL #+1
   \   00000060   0x8190             STRH     R0,[R2, #+12]
    423            bSpeed_Buffer_Index++;
   \   00000062   0x1C68             ADDS     R0,R5,#+1
    424            
    425            if (bSpeed_Buffer_Index == SPEED_BUFFER_SIZE) 
   \   00000064   0xB2C0             UXTB     R0,R0
   \   00000066   0x2808             CMP      R0,#+8
   \   00000068   0xBF08             IT       EQ 
   \   0000006A   0x2000             MOVEQ    R0,#+0
    426            {
    427              bSpeed_Buffer_Index = 0;
   \   0000006C   0x7008             STRB     R0,[R1, #+0]
    428            }
    429          
    430            wtemp=0;
    431          
    432            for (i=0;i<SPEED_BUFFER_SIZE;i++)
    433              {
    434              wtemp += hSpeed_Buffer[i];
    435              }
    436            wtemp /= SPEED_BUFFER_SIZE;
    437            
    438            hRot_Speed = ((s16)(wtemp));
   \   0000006E   0xF9B1 0x000C      LDRSH    R0,[R1, #+12]
   \   00000072   0xF9B1 0x200E      LDRSH    R2,[R1, #+14]
   \   00000076   0x1810             ADDS     R0,R2,R0
   \   00000078   0xF9B1 0x2010      LDRSH    R2,[R1, #+16]
   \   0000007C   0x1810             ADDS     R0,R2,R0
   \   0000007E   0xF9B1 0x2012      LDRSH    R2,[R1, #+18]
   \   00000082   0x1810             ADDS     R0,R2,R0
   \   00000084   0xF9B1 0x2014      LDRSH    R2,[R1, #+20]
   \   00000088   0x1810             ADDS     R0,R2,R0
   \   0000008A   0xF9B1 0x2016      LDRSH    R2,[R1, #+22]
   \   0000008E   0x1810             ADDS     R0,R2,R0
   \   00000090   0xF9B1 0x2018      LDRSH    R2,[R1, #+24]
   \   00000094   0x1810             ADDS     R0,R2,R0
   \   00000096   0xF9B1 0x201A      LDRSH    R2,[R1, #+26]
   \   0000009A   0x1810             ADDS     R0,R2,R0
   \   0000009C   0x1082             ASRS     R2,R0,#+2
   \   0000009E   0xEB00 0x7052      ADD      R0,R0,R2, LSR #+29
   \   000000A2   0x10C0             ASRS     R0,R0,#+3
   \   000000A4   0x80C8             STRH     R0,[R1, #+6]
    439          }
   \   000000A6   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .data, align 4
   \                     bSpeed_Buffer_Index:
   \   00000000   0x00               DC8 0
   \   00000001   0x01               DC8 1
   \   00000002   0x00               DC8 0
   \   00000003   0x00               DC8 0
   \   00000004   0x00 0x00          DC8 0, 0
   \   00000006   0x00 0x00          DC8 0, 0
   \   00000008   0x00 0x00          DC8 0, 0
   \   0000000A   0x00 0x00          DC8 0, 0
   \   0000000C   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
    440          
    441          /*******************************************************************************
    442          * Function Name  : ENC_ErrorOnFeedback
    443          * Description    : Check for possible errors on speed measurement when State is 
    444          *                  RUN. After MAXIMUM_ERROR_NUMBER consecutive speed measurement
    445          *                  errors, the function return TRUE, else FALSE.
    446          *                  Function return 
    447          * Input          : None
    448          * Output         : s16
    449          * Return         : boolean variable
    450          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    451          bool ENC_ErrorOnFeedback(void)
    452          {
    453           return(bError_Speed_Measurement); 
   \                     ENC_ErrorOnFeedback:
   \   00000000   0x....             LDR.N    R0,??DataTable9_4
   \   00000002   0x7880             LDRB     R0,[R0, #+2]
   \   00000004   0x4770             BX       LR               ;; return
    454          }
    455          
    456          /*******************************************************************************
    457          * Function Name : ENC_Start_Up
    458          * Description   : The purpose of this function is to perform the alignment of 
    459          *                 PMSM torque and flux regulation during the alignment phase.
    460          * Input : details the input parameters.
    461          * Output : details the output parameters.
    462          * Return : details the return value.
    463          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    464          void ENC_Start_Up(void)
    465          {
    466            static u32 wTimebase=0;
    467            
    468            if ( (wGlobal_Flags & FIRST_START) == FIRST_START)
   \                     ENC_Start_Up:
   \   00000000   0x....             LDR.N    R0,??DataTable9_7
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x0789             LSLS     R1,R1,#+30
   \   00000006   0xD400             BMI.N    ??ENC_Start_Up_0
    469              {
    470                // First Motor start-up, alignment must be performed
    471                wTimebase++;
   \   00000008   0x4770             BX       LR
   \                     ??ENC_Start_Up_0:
   \   0000000A   0xB5F0             PUSH     {R4-R7,LR}
   \   0000000C   0xB083             SUB      SP,SP,#+12
   \   0000000E   0x....             LDR.N    R1,??DataTable9_8
   \   00000010   0x680A             LDR      R2,[R1, #+0]
   \   00000012   0x1C52             ADDS     R2,R2,#+1
   \   00000014   0x600A             STR      R2,[R1, #+0]
    472                if(wTimebase <= T_ALIGNMENT_PWM_STEPS)
   \   00000016   0x....             LDR.N    R4,??DataTable9_9
   \   00000018   0x....             LDR.N    R5,??DataTable9_10
   \   0000001A   0x....             LDR.N    R6,??DataTable9_11
   \   0000001C   0xF242 0x7361      MOVW     R3,#+10081
   \   00000020   0x429A             CMP      R2,R3
   \   00000022   0xD25C             BCS.N    ??ENC_Start_Up_1
    473                {                  
    474                  hFlux_Reference = I_ALIGNMENT * wTimebase / T_ALIGNMENT_PWM_STEPS;               
   \   00000024   0xF245 0x50F0      MOVW     R0,#+22000
   \   00000028   0x4350             MULS     R0,R0,R2
   \   0000002A   0xF242 0x7160      MOVW     R1,#+10080
   \   0000002E   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000032   0x8030             STRH     R0,[R6, #+0]
    475                  hTorque_Reference = 0;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x8028             STRH     R0,[R5, #+0]
    476                  
    477                  Stat_Curr_a_b = GET_PHASE_CURRENTS(); 
   \   00000038   0x.... 0x....      BL       SVPWM_3ShuntGetPhaseCurrentValues
   \   0000003C   0x9000             STR      R0,[SP, #+0]
   \   0000003E   0x....             LDR.N    R0,??DataTable9_12
   \   00000040   0xA900             ADD      R1,SP,#+0
   \   00000042   0x880A             LDRH     R2,[R1, #0]
   \   00000044   0x8002             STRH     R2,[R0, #+0]
   \   00000046   0x884A             LDRH     R2,[R1, #+2]
   \   00000048   0x8042             STRH     R2,[R0, #+2]
   \   0000004A   0x8802             LDRH     R2,[R0, #0]
   \   0000004C   0x800A             STRH     R2,[R1, #+0]
   \   0000004E   0x8842             LDRH     R2,[R0, #+2]
   \   00000050   0x804A             STRH     R2,[R1, #+2]
    478                  Stat_Curr_alfa_beta = Clarke(Stat_Curr_a_b); 
   \   00000052   0x9800             LDR      R0,[SP, #+0]
   \   00000054   0x.... 0x....      BL       Clarke
   \   00000058   0x9001             STR      R0,[SP, #+4]
   \   0000005A   0x....             LDR.N    R0,??DataTable9_13
   \   0000005C   0xA901             ADD      R1,SP,#+4
   \   0000005E   0x880A             LDRH     R2,[R1, #0]
   \   00000060   0x8002             STRH     R2,[R0, #+0]
   \   00000062   0x884A             LDRH     R2,[R1, #+2]
   \   00000064   0x8042             STRH     R2,[R0, #+2]
   \   00000066   0xA900             ADD      R1,SP,#+0
   \   00000068   0x8802             LDRH     R2,[R0, #0]
   \   0000006A   0x800A             STRH     R2,[R1, #+0]
   \   0000006C   0x8842             LDRH     R2,[R0, #+2]
   \   0000006E   0x804A             STRH     R2,[R1, #+2]
    479                  Stat_Curr_q_d = Park(Stat_Curr_alfa_beta, ALIGNMENT_ANGLE_S16);  
   \   00000070   0xF44F 0x4180      MOV      R1,#+16384
   \   00000074   0x9800             LDR      R0,[SP, #+0]
   \   00000076   0x.... 0x....      BL       Park
   \   0000007A   0x9001             STR      R0,[SP, #+4]
   \   0000007C   0x....             LDR.N    R7,??DataTable9_14
   \   0000007E   0xA801             ADD      R0,SP,#+4
   \   00000080   0x8801             LDRH     R1,[R0, #0]
   \   00000082   0x8039             STRH     R1,[R7, #+0]
   \   00000084   0x8841             LDRH     R1,[R0, #+2]
   \   00000086   0x8079             STRH     R1,[R7, #+2]
    480                  /*loads the Torque Regulator output reference voltage Vqs*/   
    481                  Stat_Volt_q_d.qV_Component1 = PID_Regulator(hTorque_Reference, 
    482                                  Stat_Curr_q_d.qI_Component1, &PID_Torque_InitStructure);   
   \   00000088   0x....             LDR.N    R2,??DataTable9_15
   \   0000008A   0xF9B7 0x1000      LDRSH    R1,[R7, #+0]
   \   0000008E   0xF9B5 0x0000      LDRSH    R0,[R5, #+0]
   \   00000092   0x.... 0x....      BL       PID_Regulator
   \   00000096   0x8020             STRH     R0,[R4, #+0]
    483                  
    484                  /*loads the Flux Regulator output reference voltage Vds*/
    485                  Stat_Volt_q_d.qV_Component2 = PID_Regulator(hFlux_Reference, 
    486                                    Stat_Curr_q_d.qI_Component2, &PID_Flux_InitStructure); 
   \   00000098   0x....             LDR.N    R2,??DataTable9_16
   \   0000009A   0xF9B7 0x1002      LDRSH    R1,[R7, #+2]
   \   0000009E   0xF9B6 0x0000      LDRSH    R0,[R6, #+0]
   \   000000A2   0x.... 0x....      BL       PID_Regulator
   \   000000A6   0x8060             STRH     R0,[R4, #+2]
    487            
    488                  RevPark_Circle_Limitation();
   \   000000A8   0x.... 0x....      BL       RevPark_Circle_Limitation
   \   000000AC   0xA800             ADD      R0,SP,#+0
   \   000000AE   0x8821             LDRH     R1,[R4, #0]
   \   000000B0   0x8001             STRH     R1,[R0, #+0]
   \   000000B2   0x8861             LDRH     R1,[R4, #+2]
   \   000000B4   0x8041             STRH     R1,[R0, #+2]
    489          
    490                  /*Performs the Reverse Park transformation,
    491                  i.e transforms stator voltages Vqs and Vds into Valpha and Vbeta on a 
    492                  stationary reference frame*/
    493            
    494                  Stat_Volt_alfa_beta = Rev_Park(Stat_Volt_q_d);
   \   000000B6   0x9800             LDR      R0,[SP, #+0]
   \   000000B8   0x.... 0x....      BL       Rev_Park
   \   000000BC   0x9001             STR      R0,[SP, #+4]
   \   000000BE   0x....             LDR.N    R0,??DataTable9_17
   \   000000C0   0xA901             ADD      R1,SP,#+4
   \   000000C2   0x880A             LDRH     R2,[R1, #0]
   \   000000C4   0x8002             STRH     R2,[R0, #+0]
   \   000000C6   0x884A             LDRH     R2,[R1, #+2]
   \   000000C8   0x8042             STRH     R2,[R0, #+2]
   \   000000CA   0xA900             ADD      R1,SP,#+0
   \   000000CC   0x8802             LDRH     R2,[R0, #0]
   \   000000CE   0x800A             STRH     R2,[R1, #+0]
   \   000000D0   0x8842             LDRH     R2,[R0, #+2]
   \   000000D2   0x804A             STRH     R2,[R1, #+2]
    495          
    496                  /*Valpha and Vbeta finally drive the power stage*/ 
    497                  CALC_SVPWM(Stat_Volt_alfa_beta);
   \   000000D4   0x9800             LDR      R0,[SP, #+0]
   \   000000D6   0x.... 0x....      BL       SVPWM_3ShuntCalcDutyCycles
   \   000000DA   0xB003             ADD      SP,SP,#+12
   \   000000DC   0xBDF0             POP      {R4-R7,PC}
    498                }
    499                else
    500                {
    501                  wTimebase = 0;              
   \                     ??ENC_Start_Up_1:
   \   000000DE   0x2200             MOVS     R2,#+0
   \   000000E0   0x600A             STR      R2,[R1, #+0]
    502                  ENC_ResetEncoder();          
   \   000000E2   0x....             LDR.N    R1,??DataTable9_3  ;; 0x40000024
   \   000000E4   0x22C7             MOVS     R2,#+199
   \   000000E6   0x800A             STRH     R2,[R1, #+0]
    503                  Stat_Volt_q_d.qV_Component1 = Stat_Volt_q_d.qV_Component2 = 0;
   \   000000E8   0x2100             MOVS     R1,#+0
   \   000000EA   0x8061             STRH     R1,[R4, #+2]
   \   000000EC   0x8021             STRH     R1,[R4, #+0]
    504                  hTorque_Reference = PID_TORQUE_REFERENCE;
   \   000000EE   0xF241 0x1194      MOVW     R1,#+4500
   \   000000F2   0x8029             STRH     R1,[R5, #+0]
    505                  hFlux_Reference = PID_FLUX_REFERENCE;
   \   000000F4   0x2100             MOVS     R1,#+0
   \   000000F6   0x8031             STRH     R1,[R6, #+0]
    506                  wGlobal_Flags &= ~FIRST_START;   // alignment done only once 
   \   000000F8   0x6801             LDR      R1,[R0, #+0]
   \   000000FA   0xF021 0x0102      BIC      R1,R1,#0x2
   \   000000FE   0x6001             STR      R1,[R0, #+0]
    507                  //Clear the speed acquisition of the alignment phase
    508                  ENC_Clear_Speed_Buffer();
   \   00000100   0x.... 0x....      BL       ENC_Clear_Speed_Buffer
    509          #ifdef ENCODER
    510                  State = RUN;
    511          #endif
    512                }
    513              }
    514            else
    515            {
    516          #ifdef ENCODER
    517              State = RUN;
    518          #endif
    519            }
    520          } 
   \   00000104   0xB003             ADD      SP,SP,#+12
   \   00000106   0xBDF0             POP      {R4-R7,PC}       ;; return

   \                                 In section .bss, align 4
   \                     ??wTimebase:
   \   00000000                      DS8 4
    521          
    522          /*******************************************************************************
    523          * Function Name  : TIMx_IRQHandler
    524          * Description    : This function handles TIMx Update interrupt request.
    525                             Encoder unit connected to TIMx (x = 2,3 or 4)
    526          * Input          : None
    527          * Output         : None
    528          * Return         : None
    529          *******************************************************************************/
    530          #if defined(TIMER2_HANDLES_ENCODER)

   \                                 In section .text, align 2, keep-with-next
    531            void TIM2_IRQHandler(void)
    532            {  
   \                     TIM2_IRQHandler:
   \   00000000   0xB580             PUSH     {R7,LR}
    533              /* Clear the interrupt pending flag */
    534              TIM_ClearFlag(ENCODER_TIMER, TIM_FLAG_Update);
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0xF04F 0x4080      MOV      R0,#+1073741824
   \   00000008   0x.... 0x....      BL       TIM_ClearFlag
    535              
    536              if (hEncoder_Timer_Overflow != U16_MAX)  
   \   0000000C   0x....             LDR.N    R0,??DataTable9_4
   \   0000000E   0x8901             LDRH     R1,[R0, #+8]
   \   00000010   0xF64F 0x72FF      MOVW     R2,#+65535
   \   00000014   0x4291             CMP      R1,R2
   \   00000016   0xD002             BEQ.N    ??TIM2_IRQHandler_0
    537              {
    538               hEncoder_Timer_Overflow++;
   \   00000018   0x8901             LDRH     R1,[R0, #+8]
   \   0000001A   0x1C49             ADDS     R1,R1,#+1
   \   0000001C   0x8101             STRH     R1,[R0, #+8]
    539              }
    540            }
   \                     ??TIM2_IRQHandler_0:
   \   0000001E   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x40010800         DC32     0x40010800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x0051EB84         DC32     0x51eb84

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x0028F5C2         DC32     0x28f5c2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x40000024         DC32     0x40000024

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0x........         DC32     bSpeed_Buffer_Index

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \   00000000   0x........         DC32     State

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_6:
   \   00000000   0xFFFFE890         DC32     0xffffe890

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_7:
   \   00000000   0x........         DC32     wGlobal_Flags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_8:
   \   00000000   0x........         DC32     ??wTimebase

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_9:
   \   00000000   0x........         DC32     Stat_Volt_q_d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_10:
   \   00000000   0x........         DC32     hTorque_Reference

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_11:
   \   00000000   0x........         DC32     hFlux_Reference

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_12:
   \   00000000   0x........         DC32     Stat_Curr_a_b

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_13:
   \   00000000   0x........         DC32     Stat_Curr_alfa_beta

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_14:
   \   00000000   0x........         DC32     Stat_Curr_q_d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_15:
   \   00000000   0x........         DC32     PID_Torque_InitStructure

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_16:
   \   00000000   0x........         DC32     PID_Flux_InitStructure

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_17:
   \   00000000   0x........         DC32     Stat_Volt_alfa_beta
    541          #elif defined(TIMER3_HANDLES_ENCODER)
    542          
    543            void TIM3_IRQHandler(void)
    544            {
    545              TIM_ClearFlag(ENCODER_TIMER, TIM_FLAG_Update);
    546              if (Encoder_Timer_Overflow != U16_MAX)  
    547              {
    548               Encoder_Timer_Overflow++;
    549              }
    550            
    551            }
    552          
    553          #elif defined(TIMER4_HANDLES_ENCODER)
    554              
    555            void TIM4_IRQHandler(void)
    556            {
    557              TIM_ClearFlag(ENCODER_TIMER, TIM_FLAG_Update);
    558              if (Encoder_Timer_Overflow != U16_MAX)  
    559              {
    560               Encoder_Timer_Overflow++;
    561              }  	
    562            }
    563          
    564          #endif // TIMER4_HANDLES_ENCODER
    565          
    566          /******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       16  ENC_Calc_Average_Speed
             16 -> ENC_Calc_Rot_Speed
       20  ENC_Calc_Rot_Speed
             20 -> __aeabi_ldivmod
        8  ENC_Clear_Speed_Buffer
              8 -> __aeabi_memclr
        0  ENC_ErrorOnFeedback
        8  ENC_Get_Electrical_Angle
              8 -> TIM_GetCounter
        8  ENC_Get_Mechanical_Angle
              8 -> TIM_GetCounter
        0  ENC_Get_Mechanical_Speed
       40  ENC_Init
             40 -> GPIO_Init
             40 -> GPIO_StructInit
             40 -> NVIC_Init
             40 -> RCC_APB1PeriphClockCmd
             40 -> RCC_APB2PeriphClockCmd
             40 -> TIM_ClearFlag
             40 -> TIM_Cmd
             40 -> TIM_DeInit
             40 -> TIM_EncoderInterfaceConfig
             40 -> TIM_ICInit
             40 -> TIM_ICStructInit
             40 -> TIM_ITConfig
             40 -> TIM_TimeBaseInit
             40 -> TIM_TimeBaseStructInit
        0  ENC_ResetEncoder
       32  ENC_Start_Up
             32 -> Clarke
             32 -> ENC_Clear_Speed_Buffer
             32 -> PID_Regulator
             32 -> Park
             32 -> RevPark_Circle_Limitation
             32 -> Rev_Park
             32 -> SVPWM_3ShuntCalcDutyCycles
             32 -> SVPWM_3ShuntGetPhaseCurrentValues
        8  TIM2_IRQHandler
              8 -> TIM_ClearFlag


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_10
       4  ??DataTable9_11
       4  ??DataTable9_12
       4  ??DataTable9_13
       4  ??DataTable9_14
       4  ??DataTable9_15
       4  ??DataTable9_16
       4  ??DataTable9_17
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
       4  ??DataTable9_7
       4  ??DataTable9_8
       4  ??DataTable9_9
      12  ?Subroutine0
     168  ENC_Calc_Average_Speed
     118  ENC_Calc_Rot_Speed
      20  ENC_Clear_Speed_Buffer
       6  ENC_ErrorOnFeedback
      14  ENC_Get_Electrical_Angle
      12  ENC_Get_Mechanical_Angle
       8  ENC_Get_Mechanical_Speed
     216  ENC_Init
       8  ENC_ResetEncoder
     264  ENC_Start_Up
      32  TIM2_IRQHandler
      28  bSpeed_Buffer_Index
          bIs_First_Measurement
          bError_Speed_Measurement
          bError_counter
          hPrevious_angle
          hRot_Speed
          hEncoder_Timer_Overflow
          hSpeed_Buffer
       4  wTimebase

 
   4 bytes in section .bss
  28 bytes in section .data
 950 bytes in section .text
 
 950 bytes of CODE memory
  32 bytes of DATA memory

Errors: none
Warnings: 4
